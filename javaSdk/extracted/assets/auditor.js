(function () {
    'use strict';

    const tabbableSelector = [
        `a[href]`,
        `area[href]`,
        `input:not([type="hidden"]):not(:disabled)`,
        `select:not(:disabled)`,
        `textarea:not(:disabled)`,
        `button:not(:disabled)`,
        `details > summary:first-of-type`,
        `audio[controls]`,
        `video[controls]`,
        `[tabindex]:not([tabindex=''])`,
    ]
        .map((s) => `${s}:not([tabindex^="-"], [inert], [inert] *)`)
        .join(", ");
    const allSelector = "*:not(svg *)";
    class Criteria {
        $els;
        dynamic = false;
        data;
    }
    const elementStore = new WeakMap();
    Object.defineProperties(SVGElement.prototype, {
        offsetWidth: {
            get: function offsetWidth() {
                const rect = this.getBoundingClientRect();
                return rect.width;
            },
        },
        offsetHeight: {
            get: function offsetWidth() {
                const rect = this.getBoundingClientRect();
                return rect.height;
            },
        },
    });
    const helper = {
        skipTags: ["SCRIPT", "OPTION", "NOSCRIPT", "STYLE", "BR", "LINK", "META", "BODY", "HTML", "HEAD"],
        dynamic: false,
        async runAuditMethods(criteriaObj, dynamic, $els, data) {
            if (typeof criteriaObj !== "object")
                return {};
            criteriaObj.$els = $els;
            criteriaObj.dynamic = dynamic;
            criteriaObj.data = data;
            const audits = {};
            const methodNames = Object.getOwnPropertyNames(Object.getPrototypeOf(criteriaObj)).filter((item) => {
                return (item !== "constructor" &&
                    item.substring(0, 1) !== "_" &&
                    typeof criteriaObj[item] === "function");
            });
            for (const methodName of methodNames)
                audits[methodName] = {};
            for (const m in audits) {
                const method = m;
                const func = criteriaObj[method];
                if (typeof func === "function") {
                    audits[method] = await func.bind(criteriaObj)($els);
                }
            }
            return audits;
        },
        reportObject($el, confidence, suggestionLabel, suggestionType) {
            confidence = Number(confidence) || 0;
            if (confidence > 0 && confidence < 100) {
                const options = [];
                for (let i = 0; i < 5; i++) {
                    const num = confidence + i;
                    options.push(num);
                    if (num >= 99)
                        break;
                }
                if (options.length > 1)
                    confidence = options[Math.floor(Math.random() * options.length)];
            }
            const data = {
                confidence,
                occurrences: 1,
                visible: true,
                success: false,
                dynamic: helper.dynamic,
                suggestionLabel: suggestionLabel || "",
                suggestionType: suggestionType || "",
                HTML: "",
                selector: "",
                src: "",
                offsetY: 0,
                offsetX: 0,
                width: 0,
                height: 0,
                engineVersions: null,
            };
            if ($el) {
                const offsets = this.elements.getOffsets($el);
                data.offsetY = Math.round(offsets.top) || 0;
                data.offsetX = Math.round(offsets.left) || 0;
                data.width = Math.round($el.offsetWidth) || 0;
                data.height = Math.round($el.offsetHeight) || 0;
                data.HTML = this.elements.getHTML($el);
                data.selector = this.elements.generateSelector($el);
                if ($el.closest('[data-aflw-hidden="true"], head') || ["BODY", "HTML"].includes($el.tagName))
                    data.visible = false;
            }
            return data;
        },
        aggregateReports(reports, report, key) {
            key = key || "selector";
            if (reports[report[key]]) {
                if (reports[report[key]].success && !report.success)
                    reports[report[key]] = report;
                reports[report[key]].occurrences = reports[report[key]].occurrences + 1;
                return reports;
            }
            reports[report[key]] = report;
            return reports;
        },
        generateAflwAuditedVar() {
            const name = new Error().stack?.toString().split("\n")[2]?.split(".")[1]?.split(" ")[0];
            return `aflw${name?.substring(0, 1).toUpperCase()}${name?.substring(1, name.length)}Audited`;
        },
        checkElementAudited($el, aflwVar) {
            const obj = elementStore.get($el) || {};
            elementStore.set($el, obj);
            const audited = !!obj[aflwVar];
            obj[aflwVar] = true;
            return audited;
        },
        isElementAudited($el, aflwVar) {
            const obj = elementStore.get($el) || {};
            const audited = !!obj[aflwVar];
            return audited;
        },
        removeElementAudited($el, aflwVar) {
            const obj = elementStore.get($el) || {};
            delete obj[aflwVar];
        },
        uris: {
            format(uri) {
                return encodeURI(uri.replace("https://", "").replace("http://", "").split("?")[0].split("#")[0]);
            },
            getExtension(uri) {
                let extension;
                const parts = this.format(uri).split("/");
                const end = parts[parts.length - 1];
                if (end.includes(".") && parts[0].includes("."))
                    extension = end.split(".").pop()?.toLowerCase() || "";
                return extension;
            },
            getDomainWebpath(uri) {
                uri = this.format(uri);
                if (uri.substring(0, 4) === "www.")
                    uri = uri.replace("www.", "");
                if (uri.substring(-1) === "/")
                    uri = uri.substring(0, uri.length - 1);
                if (uri.toLowerCase().substring(0, window.accessFlowData.domain.length) !==
                    window.accessFlowData.domain)
                    return null;
                uri = uri.replace(/\/\/+/gi, "/").replace(window.accessFlowData.domain, "");
                if (!uri)
                    uri = "/";
                if (uri.substring(0, 1) !== "/")
                    uri = `/${uri}`;
                const htmlExensions = /\.([a-z]?html?|aspx?|php\d?|jspx?|cgi)$/i;
                const anyExtension = /\.[a-z0-9]+$/i;
                if (htmlExensions.test(uri) || !anyExtension.test(uri))
                    return uri;
                return null;
            },
        },
        strings: {
            getOccurrences(str, substr) {
                return str.split(substr).length - 1;
            },
            removeWhiteSpaces(str) {
                return str.replace(/[\s\n\r]+/g, " ");
            },
            removeChars(str, chars, specialChars) {
                if (!str)
                    return str;
                if (specialChars)
                    chars = ["&", "?", '"', "'", "%", "#"].concat(chars);
                for (const v of chars)
                    str = str.split(v).join("");
                return str;
            },
            isNumber(str) {
                if (!str && str !== 0)
                    return false;
                return typeof str === "number" || !!str.match(/^[+-]?\d*\.?\d+(?:[Ee][+-]?\d+)?$/);
            },
        },
        elements: {
            generateSpecificSelector: undefined,
            // Elements that are not hidden by style, size, or overflow, are not SVG or AREA, and are
            // not inside a visually hidden element
            isVisible($el) {
                if (!$el ||
                    $el.tagName === "AFTERPAY-MODAL" ||
                    $el.getAttribute("data-acsb-force-visible") === "true") {
                    return true;
                }
                if ($el.closest("svg, head") ||
                    $el.getAttribute("data-acsb-force-hidden") === "true" ||
                    $el.parentElement?.closest('[data-aflw-hidden="true"]') ||
                    this.isHiddenByStyle($el) ||
                    this.isOverflowing($el) ||
                    this.isHiddenBySize($el)) {
                    return false;
                }
                return true;
            },
            // Elements that are links, buttons, or have cursor: pointer that have
            // less than 8 decendents and are not labels inside forms
            isClickable($el) {
                if ($el.matches("[data-aflw-role=link], a") || $el.matches("[data-aflw-role=button]"))
                    return true;
                if (($el.parentElement && $el.parentElement.closest("[data-aflw-clickable]")) ||
                    this.getStyle($el, "cursor") !== "pointer" ||
                    this.getStyle($el, "pointer-events") === "none" ||
                    ($el.tagName === "LABEL" && $el.closest("[data-aflw-role=form]")) ||
                    $el.querySelector("[data-aflw-clickable]") ||
                    $el.querySelectorAll("*:not(svg *, [data-aflw-group-formatting], [data-aflw-role=generic])")
                        .length > 5) {
                    return false;
                }
                return true;
            },
            // Elements that are inside overflow: auto or hidden that is not BODY, that are not inline,
            // that have edges that are outside of the overflow element where the overflow element is
            // larger than element
            isOverflowing($el) {
                if ($el.childElementCount > 0 &&
                    ["hidden", "auto hidden", "hidden auto"].includes(this.getStyle($el, "overflow"))) {
                    $el.setAttribute("data-aflw-overflower", "true");
                }
                if (this.getStyle($el, "display") === "inline" || $el.closest('[data-aflw-hidden="true"]'))
                    return false;
                const $overflower = $el.closest("[data-aflw-overflower]");
                if (!$overflower ||
                    !$overflower.parentElement ||
                    $overflower.parentElement.tagName === "BODY")
                    return false;
                if ($overflower.clientWidth < $el.offsetWidth || $overflower.clientHeight < $el.offsetHeight)
                    return false;
                const elOffsets = this.getOffsets($el, true);
                const overfOffsets = this.getOffsets($overflower, true);
                if (elOffsets.left - $el.offsetHeight <= 0 || elOffsets.top - $el.offsetHeight <= 0)
                    return false;
                if ($el.offsetWidth > 0 && this.getStyle($overflower, "overflow-x") === "hidden") {
                    if (elOffsets.left + $el.offsetWidth <= overfOffsets.left ||
                        elOffsets.left >= overfOffsets.left + $overflower.clientWidth) {
                        return true;
                    }
                }
                if ($el.offsetHeight > 0 && this.getStyle($overflower, "overflow-y") === "hidden") {
                    if (elOffsets.top + $el.offsetHeight <= overfOffsets.top ||
                        elOffsets.top >= overfOffsets.top + $overflower.clientHeight) {
                        return true;
                    }
                }
                return false;
            },
            // Form inputs that are not buttons
            isFormField($el) {
                return $el.matches("[data-aflw-group-input]");
            },
            // Form inputs that are buttons, plus button elements
            isButton($el) {
                return $el.matches("[data-aflw-role=button]");
            },
            // Links, or buttons, or form fields, that are not AREA, SVG, or [tabindex=-1]
            isNavigable($el) {
                let navigable = false;
                if ($el.getAttribute("tabindex") === "-1" || $el.matches(":disabled, [inert], [inert] *"))
                    return false;
                if ($el.getAttribute("data-aflw-clickable") === "true") {
                    if (!$el.parentElement || !$el.parentElement.closest("[data-aflw-navigable]")) {
                        navigable = true;
                    }
                }
                if (!navigable &&
                    ($el.matches("[data-aflw-role=button], [data-aflw-role=link]") || this.isFormField($el))) {
                    navigable = true;
                }
                if (navigable &&
                    ($el.tagName === "AREA" || ($el.parentElement && $el.parentElement.closest("svg")))) {
                    navigable = false;
                }
                if (!navigable &&
                    $el.closest('[data-aflw-hidden="true"], [data-aflw-clickable][data-aflw-navigable]')) {
                    // @TODO is this a typo?
                    const $navigParent = $el.closest("[data-aflw-now-navigable]");
                    if ($navigParent &&
                        $navigParent.matches("[data-aflw-role=link]") &&
                        this.isButton($navigParent) &&
                        this.getStyle($el, "cursor") === "pointer" &&
                        this.getStyle($el, "pointer-events") !== "none") {
                        const $hiddenChild = $navigParent.querySelector('[data-aflw-hidden="true"]');
                        if (($hiddenChild &&
                            $hiddenChild.contains($el) &&
                            $hiddenChild !== $el &&
                            this.getStyle($el, "cursor")) ||
                            $el.matches("[data-aflw-role=link]") ||
                            this.isButton($el)) {
                            navigable = true;
                        }
                    }
                }
                return navigable;
            },
            // Elements that are 0 or 1 width or height, that are not sr-only, that have no fixed decendents (with overflow)
            isHiddenBySize($el) {
                if ($el.offsetHeight > 0 &&
                    $el.offsetWidth > 0 &&
                    !($el.offsetWidth <= 2 &&
                        $el.offsetHeight <= 2 &&
                        this.getStyle($el, "overflow") === "hidden" &&
                        this.getStyle($el, "position") === "absolute")) {
                    return false;
                }
                const w = typeof $el.offsetWidth !== "number" ? $el.clientWidth : $el.offsetWidth;
                const h = typeof $el.offsetHeight !== "number" ? $el.clientHeight : $el.offsetHeight;
                if (h > 1 && w > 1)
                    return false;
                if (($el.offsetHeight === 0 && this.getStyle($el, "overflow-y") === "hidden") ||
                    ($el.offsetWidth === 0 && this.getStyle($el, "overflow-x") === "hidden")) {
                    let hasFixed = false;
                    for (const $child of $el.querySelectorAll(allSelector)) {
                        if (this.getStyle($child, "position") !== "fixed" ||
                            $child.offsetWidth < 1 ||
                            $child.offsetHeight < 1) {
                            continue;
                        }
                        hasFixed = true;
                        break;
                    }
                    if (!hasFixed)
                        return true;
                }
                const offsets = this.getOffsets($el, true);
                const $viewEl = document.elementFromPoint(offsets.left, offsets.top);
                if ($viewEl && ($viewEl === $el || $el.contains($viewEl)))
                    return false;
                if ($el.children.length < 1 || !this.hasVisibleChildren($el))
                    return true;
                return false;
            },
            // Elements that are disply: none, or visibility: hidden, or outside window, or opacity: 0, or z-index: -1 (that fail elementFromPoint())
            isHiddenByStyle($el) {
                const display = this.getStyle($el, "display");
                const opacity = this.getStyle($el, "opacity");
                const visibility = this.getStyle($el, "visibility");
                if (display === "none" ||
                    // @TODO $el.getAttribute("hidden") ||
                    ($el.getAttribute("type") === "hidden" && $el.tagName === "INPUT") ||
                    (this.getStyle($el, "max-height") === "0px" &&
                        ["block", "grid", "flex"].includes(display)) ||
                    !this.inDocument($el)) {
                    return true;
                }
                if ($el.offsetHeight > 0 &&
                    $el.offsetWidth > 0 &&
                    Number(this.getStyle($el, "z-index")) < 0 &&
                    ["absolute", "fixed"].includes(this.getStyle($el, "position"))) {
                    const offset = this.getOffsets($el, true);
                    const $offsetEl = document.elementFromPoint(offset.left, offset.top);
                    if ($el !== $offsetEl && !$el.contains($offsetEl))
                        return true;
                }
                if ((opacity === "0" || visibility === "hidden") &&
                    $el.getAttribute("data-acsb-watcher") !== "scrollAnimations") {
                    if (opacity === "0" &&
                        visibility !== "hidden" &&
                        this.getStyle($el, "animation").split(" ")[0] !== "0s") {
                        const offset = this.getOffsets($el, true);
                        const $offsetEl = document.elementFromPoint(offset.left, offset.top);
                        if ($el !== $offsetEl && !$el.contains($offsetEl))
                            return true;
                    }
                    else {
                        return true;
                    }
                }
                return false;
            },
            isOverlaying($el) {
                const style = $el.getAttribute("style");
                const display = this.getStyle($el, "display");
                const offsets = this.getOffsets($el, true);
                const offsetX = offsets.left;
                const offsetY = offsets.top;
                helper.checkElementAudited($el, "acsbIgnoreChange");
                $el.classList.add("aflw-hidden");
                if (style && style.includes("display"))
                    $el.style.display = "none";
                const $bottomEl = document.elementFromPoint(offsetX, offsetY);
                $el.classList.remove("aflw-hidden");
                if (style && style.includes("display"))
                    $el.style.display = display;
                let overlaying = false;
                if ($bottomEl && $bottomEl !== $el && $bottomEl.tagName !== "BODY") {
                    const points = [
                        { x: offsets.left, y: offsets.top },
                        { x: offsets.right, y: offsets.top },
                        { x: offsets.left + $el.offsetWidth / 2, y: offsets.top },
                        { x: offsets.left, y: offsets.top + $el.offsetHeight / 2 },
                        { x: offsets.right, y: offsets.top + $el.offsetHeight / 2 },
                        { x: offsets.left + $el.offsetWidth / 2, y: offsets.top + $el.offsetHeight / 2 },
                        { x: offsets.left, y: offsets.bottom },
                        { x: offsets.right, y: offsets.bottom },
                        { x: offsets.left + $el.offsetWidth / 2, y: offsets.bottom },
                    ];
                    for (const point of points) {
                        const $elFromPoint = document.elementFromPoint(point.x, point.y);
                        if (!$elFromPoint)
                            continue;
                        if ($el === $elFromPoint || $el.contains($elFromPoint) || $elFromPoint.contains($el)) {
                            overlaying = true;
                            break;
                        }
                    }
                }
                return overlaying;
            },
            // Elements that are within the document borders, or are inline
            inDocument($el) {
                if (this.getStyle($el, "display") === "inline")
                    return true;
                if (this.getStyle($el, "position") === "fixed") {
                    const viewOffsets = this.getOffsets($el, true);
                    if (!this.hasVisibleChildren($el) &&
                        (viewOffsets.top >= window.innerHeight ||
                            (viewOffsets.top < 0 && $el.offsetHeight - viewOffsets.top < 0))) {
                        return false;
                    }
                }
                let elementWidth = $el.scrollWidth > $el.offsetWidth ? $el.scrollWidth : $el.offsetWidth;
                let elementHeight = $el.scrollHeight > $el.offsetHeight ? $el.scrollHeight : $el.offsetHeight;
                if (elementHeight === 0)
                    elementHeight = 1;
                if (elementWidth === 0)
                    elementWidth = 1;
                const offset = this.getOffsets($el);
                if ((offset.left <= 0 && elementWidth + offset.left <= 0) ||
                    (offset.right <= 0 && elementWidth + offset.right <= 0) ||
                    (offset.top <= 0 && elementHeight + offset.top <= 0)) {
                    return false;
                }
                return true;
            },
            filterHiddens($els, type = "visible") {
                if (!$els)
                    $els = [];
                let sel = type === "sr" ? '[data-aflw-sr-hidden="true"]' : '[data-aflw-hidden="true"]';
                if (type === "sr-or-visible")
                    sel = '[data-aflw-sr-hidden="true"], [data-aflw-hidden="true"]';
                return Array.from($els).filter(($el) => !$el.closest(sel));
            },
            filterOutVisible($els) {
                if (!$els)
                    $els = [];
                return Array.from($els).filter(($el) => $el.closest('[data-aflw-hidden="true"]'));
            },
            filterToSelector($els, selector) {
                if (!$els)
                    $els = [];
                if (!selector)
                    return Array.from($els);
                return Array.from($els).filter(($el) => $el.closest(selector));
            },
            hasVisibleChildren($el) {
                let isChildVisible = false;
                for (const $child of $el.querySelectorAll(allSelector)) {
                    if ($el.offsetWidth <= 1 &&
                        $el.offsetHeight <= 1 &&
                        this.getStyle($el, "display") === "inline") {
                        $el.style.display = "block";
                    }
                    if ($child.offsetHeight > 0 && $child.offsetWidth > 0 && !this.isHiddenByStyle($child)) {
                        isChildVisible = true;
                        break;
                    }
                }
                return isChildVisible;
            },
            escapeSelector(selector) {
                // Some sites clobber `window.CSS` (or ship environments without `CSS.escape`),
                // which breaks selector generation and crashes the audit.
                const g = typeof globalThis !== "undefined"
                    ? globalThis
                    : typeof window !== "undefined"
                        ? window
                        : {};
                const nativeEscape = g?.CSS?.escape;
                if (typeof nativeEscape === "function")
                    return nativeEscape(String(selector));
                // MDN polyfill for CSS.escape (https://drafts.csswg.org/cssom/#serialize-an-identifier)
                const string = String(selector);
                const length = string.length;
                let index = -1;
                let codeUnit;
                let result = "";
                const firstCodeUnit = string.charCodeAt(0);
                while (++index < length) {
                    codeUnit = string.charCodeAt(index);
                    // Note: there’s no need to special-case astral symbols, surrogate pairs, or
                    // lone surrogates.
                    // If the character is NULL (U+0000), then the REPLACEMENT CHARACTER (U+FFFD).
                    if (codeUnit === 0x0000) {
                        result += "\uFFFD";
                        continue;
                    }
                    // If the character is in the range [1-31] (U+0001..U+001F) or U+007F,
                    // or is the first character and in [0-9] (U+0030..U+0039),
                    // or is the second character and in [0-9] (U+0030..U+0039) and the first is '-',
                    // then escape as code point.
                    if ((codeUnit >= 0x0001 && codeUnit <= 0x001f) ||
                        codeUnit === 0x007f ||
                        (index === 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
                        (index === 1 &&
                            codeUnit >= 0x0030 &&
                            codeUnit <= 0x0039 &&
                            firstCodeUnit === 0x002d)) {
                        result += "\\" + codeUnit.toString(16) + " ";
                        continue;
                    }
                    // If the character is the first character and is '-' and the string is 1 character long,
                    // escape it.
                    if (index === 0 && codeUnit === 0x002d && length === 1) {
                        result += "\\" + string.charAt(index);
                        continue;
                    }
                    // If the character is >= U+0080, or is '-' or '_', or is [0-9A-Za-z], no escaping needed.
                    if (codeUnit >= 0x0080 ||
                        codeUnit === 0x002d ||
                        codeUnit === 0x005f ||
                        (codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
                        (codeUnit >= 0x0041 && codeUnit <= 0x005a) ||
                        (codeUnit >= 0x0061 && codeUnit <= 0x007a)) {
                        result += string.charAt(index);
                        continue;
                    }
                    // Otherwise, escape the character.
                    result += "\\" + string.charAt(index);
                }
                return result;
            },
            generateSelector($el) {
                if (!$el)
                    return "";
                let selector;
                if (!this.generateSpecificSelector) {
                    this.generateSpecificSelector = ($el) => {
                        if (["BODY", "HTML", "HEAD"].includes($el.tagName))
                            return $el.tagName.toLowerCase();
                        let selector;
                        const className = $el
                            .getAttribute("class")
                            ?.replace(/(\s|\\n)+/gi, " ")
                            .trim() || "";
                        if ($el.id)
                            selector = `#${this.escapeSelector($el.id)}`;
                        if (className && !selector)
                            selector = `.${className.split(" ").map(this.escapeSelector).join(".")}`;
                        if (!selector && $el.attributes.length > 0) {
                            for (const obj of $el.attributes) {
                                if (obj.nodeName.substring(0, 4) !== "data" ||
                                    obj.nodeName.substring(0, 9) === "data-aflw" ||
                                    obj.nodeName.substring(0, 9) === "data-acsb") {
                                    continue;
                                }
                                selector = `[${this.escapeSelector(obj.nodeName)}${obj.nodeValue ? '="' + this.escapeSelector(obj.nodeValue) + '"' : ""}]`;
                            }
                        }
                        if (selector) {
                            const tags = [
                                "BUTTON",
                                "A",
                                "FORM",
                                "HEADER",
                                "SECTION",
                                "FOOTER",
                                "DIALOG",
                                "MAIN",
                                "NAV",
                                "ASIDE",
                                "INPUT",
                                "TEXTAREA",
                                "SELECT",
                            ];
                            if (tags.includes($el.tagName))
                                selector = `${$el.tagName.toLowerCase()}${selector}`;
                        }
                        else {
                            selector = $el.tagName.toLowerCase();
                        }
                        return selector;
                    };
                }
                if (helper.skipTags.includes($el.tagName)) {
                    selector = $el.tagName.toLowerCase();
                }
                else {
                    selector = `> ${this.generateSpecificSelector($el)}`;
                    let $parent = $el.parentElement;
                    let i = 0;
                    while ($parent) {
                        i++;
                        selector = `${this.generateSpecificSelector($parent)} ${selector}`;
                        $parent = $parent.parentElement;
                        if (i >= 10 || !$parent || helper.skipTags.includes($parent.tagName))
                            break;
                    }
                }
                return selector.substring(0, 1) === ">" ? selector.replace("> ", "") : selector;
            },
            getComputedStyle($el, pseudo) {
                return window.getComputedStyle($el, pseudo);
            },
            getStyle($el, style) {
                const v = window.getComputedStyle($el, null)[style];
                return !v ? "" : v;
            },
            getOffsets($el, viewport) {
                const rect = $el.getBoundingClientRect();
                if (viewport) {
                    return {
                        left: Math.round(rect.left),
                        right: Math.round(window.innerWidth - $el.offsetWidth - rect.left),
                        top: Math.round(rect.top),
                        bottom: Math.round(window.innerHeight - rect.top),
                    };
                }
                return {
                    left: Math.round(rect.left),
                    right: Math.round(window.innerWidth - $el.offsetWidth - rect.left),
                    top: Math.round(window.pageYOffset + rect.top),
                    bottom: Math.round(document.body.scrollHeight - window.pageYOffset + rect.top),
                };
            },
            getFieldLabel($field) {
                try {
                    if ($field.id) {
                        const $connectedLabel = document.querySelector(`label[for="${this.escapeSelector($field.id)}"]`);
                        if ($connectedLabel)
                            return $connectedLabel;
                    }
                }
                catch (err) { }
                const $parentLabel = $field.closest("label");
                const parentLabelText = helper.elements.getText($parentLabel);
                if ($parentLabel &&
                    parentLabelText !== "*" &&
                    parentLabelText.length > 0 &&
                    $parentLabel.querySelectorAll("[data-aflw-group-input]").length === 1) {
                    return $parentLabel;
                }
                const $prevLabel = helper.elements.getPrevious($field, "label")[0];
                const prevLabelText = helper.elements.getText($prevLabel);
                if ($prevLabel && prevLabelText !== "*" && prevLabelText.length > 0)
                    return $prevLabel;
                const $nextLabel = helper.elements.getNext($field, "label")[0];
                const nextLabelText = helper.elements.getText($nextLabel);
                if ($nextLabel &&
                    nextLabelText !== "*" &&
                    nextLabelText.length > 0 &&
                    $field.matches("[data-aflw-role=checkbox], [data-aflw-role=radio]")) {
                    return $nextLabel;
                }
                const $prevSpan = helper.elements.getPrevious($field, "span:not([data-aflw-button])")[0];
                const prevSpanText = helper.elements.getText($prevSpan);
                if ($prevSpan && prevSpanText !== "*" && prevSpanText.length > 0)
                    return $prevSpan;
                const $nextSpan = helper.elements.getNext($field, "span:not([data-aflw-button])")[0];
                const nextSpanText = helper.elements.getText($nextSpan);
                if ($nextSpan &&
                    nextSpanText !== "*" &&
                    nextSpanText.length > 0 &&
                    $field.matches("[data-aflw-role=checkbox], [data-aflw-role=radio]")) {
                    return $nextSpan;
                }
                let $nearestLabel = null;
                for (const obj of helper.elements.getNearestElements($field, ["label"])) {
                    let $connectedField;
                    try {
                        $connectedField = document.querySelector(`#${obj.$el.getAttribute("for")}`);
                    }
                    catch (err) { }
                    if (obj.distance > 100 ||
                        (!obj.isAbove && !obj.isLevel) ||
                        ($connectedField && $connectedField !== $field)) {
                        continue;
                    }
                    const nearestField = helper.elements.getNearestElements($field, [
                        "[data-aflw-group-input]",
                    ])[0];
                    if (!nearestField ||
                        nearestField.$el !== $field ||
                        document.querySelectorAll("[data-aflw-group-input]").length > 1) {
                        continue;
                    }
                    $nearestLabel = obj.$el;
                    break;
                }
                return $nearestLabel;
            },
            getNext($el, selector, all) {
                const results = [];
                while (($el = $el?.nextElementSibling)) {
                    if ($el.nodeType !== Node.ELEMENT_NODE)
                        continue;
                    if (!selector) {
                        results.push($el);
                    }
                    else {
                        if ($el.matches(selector))
                            results.push($el);
                    }
                    if (!all && results.length > 0)
                        break;
                }
                return results;
            },
            getPrevious($el, selector, all) {
                const results = [];
                while (($el = $el?.previousElementSibling)) {
                    if ($el.nodeType !== Node.ELEMENT_NODE)
                        continue;
                    if (!selector) {
                        results.push($el);
                    }
                    else {
                        if ($el.matches(selector))
                            results.push($el);
                    }
                    if (!all && results.length > 0)
                        break;
                }
                return results;
            },
            getParents($el, selector, until) {
                if (!$el || !$el.nodeType || $el.nodeType !== Node.ELEMENT_NODE || !$el.parentElement)
                    return [];
                let $search = $el.parentElement;
                const $results = [];
                while ($search.parentElement && !["HTML", "BODY"].includes($search.tagName)) {
                    if (!selector || $search.matches(selector)) {
                        $results.push($search);
                        if (until)
                            break;
                    }
                    $search = $search.parentElement;
                }
                return $results;
            },
            getTextNodesText($el) {
                if (!$el)
                    return "";
                let text = "";
                for (const $node of $el.childNodes)
                    if ($node.nodeType === Node.TEXT_NODE)
                        text = `${text} ${$node.textContent?.trim() || ""}`;
                return text.replace(/\s+/g, " ").trim();
            },
            getNearestElements($el, selectors) {
                if (!$el || !selectors || selectors.length < 1)
                    return [];
                const $els = [];
                const elOffset = this.getOffsets($el, false);
                for (const $nearEl of document.querySelectorAll(selectors.join(","))) {
                    if (!this.isVisible($nearEl))
                        continue;
                    const tagOffsets = this.getOffsets($nearEl, false);
                    let isAbove;
                    let isLeft;
                    let isLevel;
                    let distanceLeft;
                    let distanceRight;
                    let distanceY;
                    if (elOffset.left >= tagOffsets.left) {
                        isLeft = true;
                        distanceLeft = elOffset.left - (tagOffsets.left + $nearEl.offsetWidth);
                    }
                    else {
                        isLeft = false;
                        distanceLeft = tagOffsets.left - (elOffset.left + $el.offsetWidth);
                    }
                    if (elOffset.right - $el.offsetWidth >= tagOffsets.right - $nearEl.offsetWidth) {
                        distanceRight =
                            elOffset.right - $el.offsetWidth - (tagOffsets.right - $nearEl.offsetWidth);
                    }
                    else {
                        distanceRight =
                            tagOffsets.right - $nearEl.offsetWidth - (elOffset.right - $el.offsetWidth);
                    }
                    if (elOffset.top >= tagOffsets.top) {
                        if (elOffset.top - tagOffsets.top <= $nearEl.offsetHeight ||
                            elOffset.top - tagOffsets.top <= $el.offsetHeight)
                            isLevel = true;
                    }
                    else {
                        if (tagOffsets.top - elOffset.top <= $el.offsetHeight ||
                            tagOffsets.top - elOffset.top <= $nearEl.offsetHeight)
                            isLevel = true;
                    }
                    if (isLevel) {
                        if (elOffset.top >= tagOffsets.top) {
                            isAbove = true;
                            distanceY = elOffset.top - tagOffsets.top;
                        }
                        else {
                            isAbove = false;
                            distanceY = tagOffsets.top - elOffset.top;
                        }
                    }
                    else {
                        if (elOffset.top >= tagOffsets.top) {
                            isAbove = true;
                            distanceY = elOffset.top - (tagOffsets.top + $nearEl.offsetHeight);
                        }
                        else {
                            isAbove = false;
                            distanceY = tagOffsets.top - (elOffset.top + $el.offsetHeight);
                        }
                    }
                    const distanceX = distanceLeft <= distanceRight ? distanceLeft : distanceRight;
                    $els.push({
                        $el: $nearEl,
                        isLevel: isLevel,
                        isAbove: isAbove,
                        isLeft: isLeft,
                        distanceX: distanceX,
                        distanceY: distanceY,
                        distance: Math.round(Math.sqrt(distanceX * distanceX + distanceY * distanceY)),
                    });
                }
                return $els.sort((a, b) => a.distance - b.distance);
            },
            getText($el, type = "sr", trim = true, ignores = []) {
                if (!$el)
                    return "";
                let text = $el.textContent || "";
                const skipSelector = "script, style, img, option, noscript";
                if (type === "visible")
                    ignores.push('[data-aflw-hidden="true"]');
                if (type === "sr")
                    ignores.push("[data-aflw-sr-hidden=true]");
                for (const $element of $el.querySelectorAll(skipSelector))
                    text = text.replace($element.textContent || "", "");
                if (ignores.length > 0) {
                    if ($el.matches(ignores.join(",")))
                        return "";
                    for (const $innerEl of $el.querySelectorAll(ignores.join(","))) {
                        let innerText = $innerEl.textContent || "";
                        for (const $element of $innerEl.querySelectorAll(skipSelector)) {
                            innerText = innerText.replace($element.textContent || "", "");
                        }
                        text = text.replace(innerText, "");
                    }
                }
                return trim ? text.replace(/\s+/g, " ").trim() : text;
            },
            getFocused() {
                return document.hasFocus() ? document.activeElement : null;
            },
            getHTML($el) {
                if (!$el)
                    return "";
                const noChildrenEl = $el.cloneNode(false);
                let html = noChildrenEl.outerHTML;
                if ($el.tagName === "HTML") {
                    html = html.replace('data-js-focus-visible=""', "").replace("js-focus-visible", "");
                    html = html.replace('class=""', "").replace(/  +/g, "");
                }
                for (const obj of $el.attributes) {
                    const attr = obj.nodeName.substring(0, 9);
                    if (attr !== "data-aflw" && attr !== "data-acsb")
                        continue;
                    html = html.replace(`${obj.nodeName}="${obj.nodeValue}"`, "");
                }
                html = html.replace(/  +/g, " ").replace('" >', '">').replace(/=""/g, "").trim();
                if (html.length > 1000)
                    html = html.substring(0, 1000);
                return html;
            },
            scroll($el, position) {
                return new Promise((resolve) => {
                    const targetPosition = position;
                    const direction = targetPosition > $el.scrollTop ? "down" : "up";
                    $el.scrollTo({ left: 0, top: targetPosition, behavior: "smooth" });
                    const interval = setInterval(() => {
                        let done = false;
                        const scrollHeight = Math.ceil(document.body.scrollHeight);
                        if (direction === "down" && document.body.scrollHeight > position) {
                            position = scrollHeight;
                            return $el.scrollTo({ left: 0, top: position, behavior: "smooth" });
                        }
                        if (direction === "down") {
                            const scrollTop = Math.ceil($el.scrollTop + window.innerHeight + 50);
                            if (scrollTop >= position || scrollTop >= scrollHeight)
                                done = true;
                        }
                        else {
                            if ($el.scrollTop <= position)
                                done = true;
                        }
                        if (!done)
                            return;
                        clearInterval(interval);
                        resolve();
                    }, 10);
                });
            },
        },
    };

    var Keyword;
    (function (Keyword) {
        Keyword["Next"] = "next";
        Keyword["Previous"] = "previous";
        Keyword["Account"] = "account";
        Keyword["Profile"] = "profile";
        Keyword["User"] = "user";
        Keyword["Signup"] = "signup";
        Keyword["Login"] = "login";
        Keyword["Register"] = "register";
        Keyword["Feed"] = "feed";
        Keyword["Rss"] = "rss";
        Keyword["Search"] = "search";
        Keyword["Find"] = "find";
        Keyword["Favorites"] = "favorites";
        Keyword["Whishlist"] = "whishlist";
        Keyword["Saves"] = "saves";
        Keyword["Contact"] = "contact";
        Keyword["Quote"] = "quote";
        Keyword["Offer"] = "offer";
        Keyword["Proposal"] = "proposal";
        Keyword["Cart"] = "cart";
        Keyword["Basket"] = "basket";
        Keyword["Bag"] = "bag";
        Keyword["Checkout"] = "checkout";
        Keyword["Locations"] = "locations";
        Keyword["Stores"] = "stores";
        Keyword["Locator"] = "locator";
        Keyword["Locate"] = "locate";
        Keyword["Shops"] = "shops";
        Keyword["Facebook"] = "facebook";
        Keyword["Yahoo"] = "yahoo";
        Keyword["Yandex"] = "yandex";
        Keyword["Xing"] = "xing";
        Keyword["Medium"] = "medium";
        Keyword["Linkedin"] = "linkedin";
        Keyword["Dribble"] = "dribble";
        Keyword["Waze"] = "waze";
        Keyword["Github"] = "github";
        Keyword["Snapchat"] = "snapchat";
        Keyword["Instagram"] = "instagram";
        Keyword["Twitter"] = "twitter";
        Keyword["Tripadvisor"] = "trip advisor";
        Keyword["Yelp"] = "yelp";
        Keyword["Tiktok"] = "tiktok";
        Keyword["Whatsapp"] = "whatsapp";
        Keyword["Youtube"] = "youtube";
        Keyword["Reddit"] = "reddit";
        Keyword["Tumblr"] = "tumblr";
        Keyword["Flickr"] = "flickr";
        Keyword["Pinterest"] = "pinterest";
        Keyword["GoogleMaps"] = "google maps";
        Keyword["Email"] = "email";
        Keyword["Phone"] = "phone";
        Keyword["Image"] = "image";
        Keyword["Pdf"] = "pdf";
        Keyword["Home"] = "home";
    })(Keyword || (Keyword = {}));

    const translations = {
        ["carousel" /* LangContext.carousel */]: {
            [Keyword.Next]: {
                ["English" /* Lang.English */]: ["Next", "Continue", "Proceed", "Forward", "Right"],
                ["Spanish" /* Lang.Spanish */]: ["Siguiente", "Continuar", "Proceder", "Adelante"],
                ["German" /* Lang.German */]: ["Nächster", "Fortsetzen", "Vorgehen", "Vorwärts"],
                ["Portuguese" /* Lang.Portuguese */]: ["Próximo", "Continuar", "Prosseguir", "Avançar"],
                ["French" /* Lang.French */]: ["Suivant", "Continuer", "Procéder", "Avancer"],
                ["Italian" /* Lang.Italian */]: ["Successivo", "Continua", "Procedere", "Avanti"],
                ["Hebrew" /* Lang.Hebrew */]: ["הבא", "המשך", "קדימה"],
                ["Russian" /* Lang.Russian */]: ["Следующий", "Продолжить", "Вперед"],
                ["Arabic" /* Lang.Arabic */]: ["التالي", "استمر", "تقدم", "إلى الأمام"],
                ["Chinese Simplified" /* Lang.Chinese_Simplified */]: ["下一个", "继续", "进行", "向前"],
                ["Chinese Traditional" /* Lang.Chinese_Traditional */]: ["下一個", "繼續", "進行", "向前"],
                ["Dutch" /* Lang.Dutch */]: ["Volgende", "Doorgaan", "Verdergaan", "Vooruit"],
                ["Japanese" /* Lang.Japanese */]: ["次", "続ける", "進む", "前進"],
                ["Turkish" /* Lang.Turkish */]: ["Sonraki", "Devam et", "İlerle", "İleri"],
                ["Polish" /* Lang.Polish */]: ["Następny", "Kontynuuj", "Przejdź dalej", "Naprzód"],
            },
            [Keyword.Previous]: {
                ["English" /* Lang.English */]: ["Previous", "Back", "Before", "Prior", "Left", "Prev"],
                ["Spanish" /* Lang.Spanish */]: ["Anterior", "Atrás", "Antes", "Previo"],
                ["German" /* Lang.German */]: ["Vorheriger", "Zurück", "Bevor", "Früher"],
                ["Portuguese" /* Lang.Portuguese */]: ["Anterior", "Atrás", "Antes", "Prévio"],
                ["French" /* Lang.French */]: ["Précédent", "Retour", "Avant", "Précédent"],
                ["Italian" /* Lang.Italian */]: ["Precedente", "Indietro", "Prima", "Precedente"],
                ["Hebrew" /* Lang.Hebrew */]: ["חזור", "לפני", "קודם"],
                ["Russian" /* Lang.Russian */]: ["Предыдущий", "Назад", "До", "Ранее"],
                ["Arabic" /* Lang.Arabic */]: ["السابق", "الى الخلف", "قبل", "سابق"],
                ["Chinese Simplified" /* Lang.Chinese_Simplified */]: ["前一个", "回", "之前", "先前"],
                ["Chinese Traditional" /* Lang.Chinese_Traditional */]: ["前一個", "回", "之前", "先前"],
                ["Dutch" /* Lang.Dutch */]: ["Vorige", "Terug", "Voor", "Eerder"],
                ["Japanese" /* Lang.Japanese */]: ["前", "戻る", "前", "前の"],
                ["Turkish" /* Lang.Turkish */]: ["Önceki", "Geri", "Önce", "Önceki"],
                ["Polish" /* Lang.Polish */]: ["Poprzedni", "Wróć", "Przed", "Wcześniejszy"],
            },
        },
        ["general" /* LangContext.general */]: {
            [Keyword.Next]: {
                ["English" /* Lang.English */]: ["Next", "Continue", "Proceed", "Forward"],
                ["Spanish" /* Lang.Spanish */]: ["Siguiente", "Continuar", "Proceder", "Adelante"],
                ["German" /* Lang.German */]: ["Nächster", "Fortsetzen", "Vorgehen", "Vorwärts"],
                ["Portuguese" /* Lang.Portuguese */]: ["Próximo", "Continuar", "Prosseguir", "Avançar"],
                ["French" /* Lang.French */]: ["Suivant", "Continuer", "Procéder", "Avancer"],
                ["Italian" /* Lang.Italian */]: ["Successivo", "Continua", "Procedere", "Avanti"],
                ["Hebrew" /* Lang.Hebrew */]: ["הבא", "המשך", "קדימה"],
                ["Russian" /* Lang.Russian */]: ["Следующий", "Продолжить", "Вперед"],
                ["Arabic" /* Lang.Arabic */]: ["التالي", "استمر", "تقدم", "إلى الأمام"],
                ["Chinese Simplified" /* Lang.Chinese_Simplified */]: ["下一个", "继续", "进行", "向前"],
                ["Chinese Traditional" /* Lang.Chinese_Traditional */]: ["下一個", "繼續", "進行", "向前"],
                ["Dutch" /* Lang.Dutch */]: ["Volgende", "Doorgaan", "Verdergaan", "Vooruit"],
                ["Japanese" /* Lang.Japanese */]: ["次", "続ける", "進む", "前進"],
                ["Turkish" /* Lang.Turkish */]: ["Sonraki", "Devam et", "İlerle", "İleri"],
                ["Polish" /* Lang.Polish */]: ["Następny", "Kontynuuj", "Przejdź dalej", "Naprzód"],
            },
            [Keyword.Previous]: {
                ["English" /* Lang.English */]: ["Previous", "Back", "Before", "Prior"],
                ["Spanish" /* Lang.Spanish */]: ["Anterior", "Atrás", "Antes", "Previo"],
                ["German" /* Lang.German */]: ["Vorheriger", "Zurück", "Bevor", "Früher"],
                ["Portuguese" /* Lang.Portuguese */]: ["Anterior", "Atrás", "Antes", "Prévio"],
                ["French" /* Lang.French */]: ["Précédent", "Retour", "Avant", "Précédent"],
                ["Italian" /* Lang.Italian */]: ["Precedente", "Indietro", "Prima", "Precedente"],
                ["Hebrew" /* Lang.Hebrew */]: ["חזור", "לפני", "קודם"],
                ["Russian" /* Lang.Russian */]: ["Предыдущий", "Назад", "До", "Ранее"],
                ["Arabic" /* Lang.Arabic */]: ["السابق", "الى الخلف", "قبل", "سابق"],
                ["Chinese Simplified" /* Lang.Chinese_Simplified */]: ["前一个", "回", "之前", "先前"],
                ["Chinese Traditional" /* Lang.Chinese_Traditional */]: ["前一個", "回", "之前", "先前"],
                ["Dutch" /* Lang.Dutch */]: ["Vorige", "Terug", "Voor", "Eerder"],
                ["Japanese" /* Lang.Japanese */]: ["前", "戻る", "前", "前の"],
                ["Turkish" /* Lang.Turkish */]: ["Önceki", "Geri", "Önce", "Önceki"],
                ["Polish" /* Lang.Polish */]: ["Poprzedni", "Wróć", "Przed", "Wcześniejszy"],
            },
        },
        ["clickables" /* LangContext.clickables */]: {
            [Keyword.Login]: {
                ["English" /* Lang.English */]: ["login", "log-in", "sign in"],
                ["Spanish" /* Lang.Spanish */]: ["Iniciar sesión"],
                ["German" /* Lang.German */]: ["Anmelden"],
                ["Portuguese" /* Lang.Portuguese */]: ["Entrar"],
                ["French" /* Lang.French */]: ["Connexion"],
                ["Italian" /* Lang.Italian */]: ["Accesso", "Accedi"],
                ["Hebrew" /* Lang.Hebrew */]: ["כניסה", "התחברות"],
                ["Russian" /* Lang.Russian */]: ["Вход", "Войти"],
                ["Arabic" /* Lang.Arabic */]: ["تسجيل الدخول"],
                ["Chinese Simplified" /* Lang.Chinese_Simplified */]: ["登录"],
                ["Chinese Traditional" /* Lang.Chinese_Traditional */]: ["登入"],
                ["Dutch" /* Lang.Dutch */]: ["Inloggen"],
                ["Japanese" /* Lang.Japanese */]: ["ログイン"],
                ["Turkish" /* Lang.Turkish */]: ["Giriş yap"],
                ["Polish" /* Lang.Polish */]: ["Zaloguj się"],
            },
            [Keyword.Profile]: {
                ["English" /* Lang.English */]: ["Profile", "Personal Information"],
                ["Spanish" /* Lang.Spanish */]: ["Perfil", "Información Personal"],
                ["German" /* Lang.German */]: ["Benutzerprofil", "Persönliche Informationen"],
                ["Portuguese" /* Lang.Portuguese */]: ["Informações Pessoais"],
                ["French" /* Lang.French */]: ["Profil", "Informations Personnelles"],
                ["Italian" /* Lang.Italian */]: ["Profilo", "Informazioni Personali"],
                ["Hebrew" /* Lang.Hebrew */]: ["פרופיל", "מידע אישי"],
                ["Russian" /* Lang.Russian */]: ["Профиль", "Личная Информация"],
                ["Arabic" /* Lang.Arabic */]: ["الملف الشخصي", "ملف المستخدم", "معلومات شخصية"],
                ["Chinese Simplified" /* Lang.Chinese_Simplified */]: ["简介", "用户简介", "个人信息"],
                ["Chinese Traditional" /* Lang.Chinese_Traditional */]: ["簡介", "用戶簡介", "個人資訊"],
                ["Dutch" /* Lang.Dutch */]: ["Profiel", "Gebruikersprofiel", "Persoonlijke Informatie"],
                ["Japanese" /* Lang.Japanese */]: ["プロフィール", "ユーザープロフィール", "個人情報"],
                ["Turkish" /* Lang.Turkish */]: ["Kullanıcı Profili", "Kişisel Bilgiler"],
                ["Polish" /* Lang.Polish */]: ["Informacje Osobiste"],
            },
            [Keyword.User]: {
                ["English" /* Lang.English */]: ["User"],
                ["Spanish" /* Lang.Spanish */]: ["Usuario"],
                ["German" /* Lang.German */]: ["Benutzer"],
                ["Portuguese" /* Lang.Portuguese */]: ["Usuário"],
                ["French" /* Lang.French */]: ["Utilisateur"],
                ["Italian" /* Lang.Italian */]: ["Utente"],
                ["Hebrew" /* Lang.Hebrew */]: ["משתמש"],
                ["Russian" /* Lang.Russian */]: ["Пользователь"],
                ["Arabic" /* Lang.Arabic */]: ["مستخدم"],
                ["Chinese Simplified" /* Lang.Chinese_Simplified */]: ["用户"],
                ["Chinese Traditional" /* Lang.Chinese_Traditional */]: ["用戶"],
                ["Dutch" /* Lang.Dutch */]: ["Gebruiker"],
                ["Japanese" /* Lang.Japanese */]: ["ユーザー"],
                ["Turkish" /* Lang.Turkish */]: ["Kullanıcı"],
                ["Polish" /* Lang.Polish */]: ["Użytkownik"],
            },
            [Keyword.Signup]: {
                ["English" /* Lang.English */]: [
                    /Sign.?up/i,
                    "Register",
                    "Join",
                    /Create .*?account/i,
                    /Try .*?for free/i,
                    "get started",
                ],
                ["Spanish" /* Lang.Spanish */]: ["Registrarse", "Crear cuenta", "Inscribirse"],
                ["German" /* Lang.German */]: ["Anmelden", "Registrieren", "Konto erstellen"],
                ["Portuguese" /* Lang.Portuguese */]: ["Inscrever-se", "Registrar-se", "Criar conta"],
                ["French" /* Lang.French */]: ["S'inscrire", "Créer un compte", "Inscription"],
                ["Italian" /* Lang.Italian */]: ["Iscriviti", "Registrati", "Creare un account"],
                ["Hebrew" /* Lang.Hebrew */]: ["הרשם", "הירשם", "הירשמו"],
                ["Russian" /* Lang.Russian */]: ["Зарегистрироваться", "Регистрация", "Создать аккаунт"],
                ["Arabic" /* Lang.Arabic */]: ["سجل", "سجّل", "إنشاء حساب"],
                ["Chinese Simplified" /* Lang.Chinese_Simplified */]: ["注册", "注册账号", "创建账户"],
                ["Chinese Traditional" /* Lang.Chinese_Traditional */]: ["註冊", "註冊帳號", "創建帳戶"],
                ["Dutch" /* Lang.Dutch */]: ["Inschrijven", "Registreren", "Account aanmaken"],
                ["Japanese" /* Lang.Japanese */]: ["サインアップ", "登録", "アカウント作成"],
                ["Turkish" /* Lang.Turkish */]: ["Kaydol", "Üye ol", "Hesap oluştur"],
                ["Polish" /* Lang.Polish */]: ["Zarejestruj się", "Utwórz konto", "Zapisz się"],
            },
            [Keyword.Account]: {
                ["English" /* Lang.English */]: ["Account"],
                ["Spanish" /* Lang.Spanish */]: ["Cuenta", "Mi cuenta"],
                ["German" /* Lang.German */]: ["Konto", "Benutzerkonto"],
                ["Portuguese" /* Lang.Portuguese */]: ["Conta"],
                ["French" /* Lang.French */]: ["Compte"],
                ["Italian" /* Lang.Italian */]: ["Account"],
                ["Hebrew" /* Lang.Hebrew */]: ["חשבון"],
                ["Russian" /* Lang.Russian */]: ["Аккаунт", "Учетная запись", "Мой аккаунт"],
                ["Arabic" /* Lang.Arabic */]: ["الحساب", "حساب المستخدم", "حسابي"],
                ["Chinese Simplified" /* Lang.Chinese_Simplified */]: ["账户", "用户账户", "我的账户"],
                ["Chinese Traditional" /* Lang.Chinese_Traditional */]: ["帳戶", "用戶帳戶", "我的帳戶"],
                ["Dutch" /* Lang.Dutch */]: ["Account", "Gebruikersaccount"],
                ["Japanese" /* Lang.Japanese */]: ["アカウント", "ユーザーアカウント", "マイアカウント"],
                ["Turkish" /* Lang.Turkish */]: ["Hesap", "Kullanıcı hesabı", "Hesabım"],
                ["Polish" /* Lang.Polish */]: ["Konto"],
            },
            [Keyword.Register]: {
                ["English" /* Lang.English */]: ["Register"],
                ["Spanish" /* Lang.Spanish */]: ["Registrar"],
                ["German" /* Lang.German */]: ["Registrieren"],
                ["Portuguese" /* Lang.Portuguese */]: ["Registrar"],
                ["French" /* Lang.French */]: ["S'inscrire"],
                ["Italian" /* Lang.Italian */]: ["Registrare"],
                ["Hebrew" /* Lang.Hebrew */]: ["הירשם", "הרשמה"],
                ["Russian" /* Lang.Russian */]: ["Зарегистрироваться"],
                ["Arabic" /* Lang.Arabic */]: ["تسجيل"],
                ["Chinese Simplified" /* Lang.Chinese_Simplified */]: ["注册"],
                ["Chinese Traditional" /* Lang.Chinese_Traditional */]: ["註冊"],
                ["Dutch" /* Lang.Dutch */]: ["Registreren"],
                ["Japanese" /* Lang.Japanese */]: ["登録する"],
                ["Turkish" /* Lang.Turkish */]: ["Kayıt ol"],
                ["Polish" /* Lang.Polish */]: ["Zarejestruj"],
            },
            [Keyword.Shops]: {
                ["English" /* Lang.English */]: ["Shops", "Stores", "Retailers", "Branches", "Retailers", "Branches"],
                ["Spanish" /* Lang.Spanish */]: ["Tiendas", "Comercios", "Sucursales"],
                ["German" /* Lang.German */]: ["Geschäfte", "Läden", "Filialen"],
                ["Portuguese" /* Lang.Portuguese */]: ["Lojas", "Comércios", "Filiais"],
                ["French" /* Lang.French */]: ["Magasins", "Boutiques", "Sucursales"],
                ["Italian" /* Lang.Italian */]: ["Negozi", "Botteghe", "Filiali"],
                ["Hebrew" /* Lang.Hebrew */]: ["חנויות", "סניפים"],
                ["Russian" /* Lang.Russian */]: ["Магазины", "Филиалы"],
                ["Arabic" /* Lang.Arabic */]: ["محلات", "فروع"],
                ["Chinese Simplified" /* Lang.Chinese_Simplified */]: ["商店", "店铺", "分店"],
                ["Chinese Traditional" /* Lang.Chinese_Traditional */]: ["商店", "店舖", "分店"],
                ["Dutch" /* Lang.Dutch */]: ["Winkels", "Vestigingen"],
                ["Japanese" /* Lang.Japanese */]: ["ショップ", "店舗", "支店"],
                ["Turkish" /* Lang.Turkish */]: ["Dükkanlar", "Mağazalar", "Şubeler"],
                ["Polish" /* Lang.Polish */]: ["Sklepy", "Oddziały"],
            },
            [Keyword.Locate]: {
                ["English" /* Lang.English */]: ["Locate", "Find", "Nearby"],
                ["Spanish" /* Lang.Spanish */]: ["Localizar", "Encontrar", "Ubicar"],
                ["German" /* Lang.German */]: ["Lokalisieren", "Finden"],
                ["Portuguese" /* Lang.Portuguese */]: ["Localizar", "Encontrar"],
                ["French" /* Lang.French */]: ["Localiser", "Trouver"],
                ["Italian" /* Lang.Italian */]: ["Localizzare", "Trovare", "Individuare"],
                ["Hebrew" /* Lang.Hebrew */]: ["אתר", "מצא"],
                ["Russian" /* Lang.Russian */]: ["Локализовать", "Найти", "Найти поблизости"],
                ["Arabic" /* Lang.Arabic */]: ["حدد", "ابحث", "حدد المكان"],
                ["Chinese Simplified" /* Lang.Chinese_Simplified */]: ["定位", "查找", "找到附近"],
                ["Chinese Traditional" /* Lang.Chinese_Traditional */]: ["定位", "查找", "找到附近"],
                ["Dutch" /* Lang.Dutch */]: ["Lokaliseren", "Vinden", "Vind in de buurt"],
                ["Japanese" /* Lang.Japanese */]: ["特定する", "見つける", "近くを特定する"],
                ["Turkish" /* Lang.Turkish */]: ["Bul", "Bulma"],
                ["Polish" /* Lang.Polish */]: ["Zlokalizować", "Znaleźć", "Znajdź w pobliżu"],
            },
            [Keyword.Locator]: {
                ["English" /* Lang.English */]: ["Locator", "Finder", "Locating Tool"],
                ["Spanish" /* Lang.Spanish */]: ["Localizador", "Buscador", "Herramienta de localización"],
                ["German" /* Lang.German */]: ["Ortungsgerät", "Finder", "Standortbestimmer"],
                ["Portuguese" /* Lang.Portuguese */]: ["Localizador", "Buscador", "Ferramenta de localização"],
                ["French" /* Lang.French */]: ["Localisateur", "Recherche", "Outil de localisation"],
                ["Italian" /* Lang.Italian */]: ["Localizzatore", "Finder", "Strumento di localizzazione"],
                ["Hebrew" /* Lang.Hebrew */]: ["מאתר", "מוצא", "כלי איתור"],
                ["Russian" /* Lang.Russian */]: ["Локатор", "Поиск", "Инструмент для локализации"],
                ["Arabic" /* Lang.Arabic */]: ["محدد", "الباحث", "أداة تحديد المواقع"],
                ["Chinese Simplified" /* Lang.Chinese_Simplified */]: ["定位器", "查找器", "定位工具"],
                ["Chinese Traditional" /* Lang.Chinese_Traditional */]: ["定位器", "查找器", "定位工具"],
                ["Dutch" /* Lang.Dutch */]: ["Locator", "Vinder", "Locatiezoeker"],
                ["Japanese" /* Lang.Japanese */]: ["ロケータ", "検索ツール", "位置検出器"],
                ["Turkish" /* Lang.Turkish */]: ["Bulucu", "Bulma Aracı", "Konum Belirleyici"],
                ["Polish" /* Lang.Polish */]: ["Lokalizator", "Wyszukiwarka", "Narzędzie do lokalizacji"],
            },
            [Keyword.Stores]: {
                ["English" /* Lang.English */]: ["Stores"],
                ["Spanish" /* Lang.Spanish */]: ["Tiendas"],
                ["German" /* Lang.German */]: ["Läden"],
                ["Portuguese" /* Lang.Portuguese */]: ["Lojas"],
                ["French" /* Lang.French */]: ["Magasins"],
                ["Italian" /* Lang.Italian */]: ["Negozi"],
                ["Hebrew" /* Lang.Hebrew */]: ["חנויות"],
                ["Russian" /* Lang.Russian */]: ["Магазины"],
                ["Arabic" /* Lang.Arabic */]: ["متاجر"],
                ["Chinese Simplified" /* Lang.Chinese_Simplified */]: ["商店"],
                ["Chinese Traditional" /* Lang.Chinese_Traditional */]: ["商店"],
                ["Dutch" /* Lang.Dutch */]: ["Winkels"],
                ["Japanese" /* Lang.Japanese */]: ["店舗"],
                ["Turkish" /* Lang.Turkish */]: ["Mağazalar"],
                ["Polish" /* Lang.Polish */]: ["Sklepy"],
            },
            [Keyword.Locations]: {
                ["English" /* Lang.English */]: ["Locations", "Spots", "Places"],
                ["Spanish" /* Lang.Spanish */]: ["Ubicaciones", "Sitios", "Lugares"],
                ["German" /* Lang.German */]: ["Standorte", "Orte", "Plätze"],
                ["Portuguese" /* Lang.Portuguese */]: ["Localizações", "Pontos", "Lugares"],
                ["French" /* Lang.French */]: ["Emplacements", "Endroits", "Lieux"],
                ["Italian" /* Lang.Italian */]: ["Posizioni", "Luoghi", "Località"],
                ["Hebrew" /* Lang.Hebrew */]: ["מיקומים", "מקומות", "נקודות"],
                ["Russian" /* Lang.Russian */]: ["Места", "Точки", "Локации"],
                ["Arabic" /* Lang.Arabic */]: ["المواقع", "نقاط", "أماكن"],
                ["Chinese Simplified" /* Lang.Chinese_Simplified */]: ["位置", "地点", "景点"],
                ["Chinese Traditional" /* Lang.Chinese_Traditional */]: ["位置", "地點", "景點"],
                ["Dutch" /* Lang.Dutch */]: ["Locaties", "Plaatsen"],
                ["Japanese" /* Lang.Japanese */]: ["場所", "スポット", "地点"],
                ["Turkish" /* Lang.Turkish */]: ["Konumlar", "Yerler", "Mekanlar"],
                ["Polish" /* Lang.Polish */]: ["Lokalizacje", "Miejsca", "Miejsca na mapie"],
            },
            [Keyword.Checkout]: {
                ["English" /* Lang.English */]: ["Checkout", "Pay", "Payment", "Order"],
                ["Spanish" /* Lang.Spanish */]: ["Finalizar compra", "Pagar", "Pago", "Orden"],
                ["German" /* Lang.German */]: ["Kasse", "Bezahlen", "Zahlung", "Bestellung"],
                ["Portuguese" /* Lang.Portuguese */]: ["Finalizar compra", "Pagar", "Pagamento", "Pedido"],
                ["French" /* Lang.French */]: ["Caisse", "Payer", "Paiement", "Commande"],
                ["Italian" /* Lang.Italian */]: ["Cassa", "Paga", "Pagamento", "Ordine"],
                ["Hebrew" /* Lang.Hebrew */]: ["תשלום", "שלם", "הזמנה"],
                ["Russian" /* Lang.Russian */]: ["Оформление заказа", "Оплатить", "Оплата", "Заказ"],
                ["Arabic" /* Lang.Arabic */]: ["إتمام الشراء", "ادفع", "الدفع", "طلب"],
                ["Chinese Simplified" /* Lang.Chinese_Simplified */]: ["结帐", "支付", "付款", "订单"],
                ["Chinese Traditional" /* Lang.Chinese_Traditional */]: ["結帳", "支付", "付款", "訂單"],
                ["Dutch" /* Lang.Dutch */]: ["Afrekenen", "Betalen", "Betaling", "Bestelling"],
                ["Japanese" /* Lang.Japanese */]: ["レジに進む", "支払う", "支払い", "注文"],
                ["Turkish" /* Lang.Turkish */]: ["Ödeme yapma", "Öde", "Ödeme", "Sipariş"],
                ["Polish" /* Lang.Polish */]: ["Zamknięcie zamówienia", "Zapłać", "Płatność", "Zamówienie"],
            },
            [Keyword.Bag]: {
                ["English" /* Lang.English */]: ["Bag"],
                ["Spanish" /* Lang.Spanish */]: ["Bolsa"],
                ["German" /* Lang.German */]: ["Tasche"],
                ["Portuguese" /* Lang.Portuguese */]: ["Saco"],
                ["French" /* Lang.French */]: ["Sac"],
                ["Italian" /* Lang.Italian */]: ["Borsa"],
                ["Hebrew" /* Lang.Hebrew */]: ["תיק"],
                ["Russian" /* Lang.Russian */]: ["Сумка"],
                ["Arabic" /* Lang.Arabic */]: ["حقيبة"],
                ["Chinese Simplified" /* Lang.Chinese_Simplified */]: ["袋子"],
                ["Chinese Traditional" /* Lang.Chinese_Traditional */]: ["袋子"],
                ["Dutch" /* Lang.Dutch */]: ["Tas"],
                ["Japanese" /* Lang.Japanese */]: ["バッグ"],
                ["Turkish" /* Lang.Turkish */]: ["Çanta"],
                ["Polish" /* Lang.Polish */]: ["Torba"],
            },
            [Keyword.Basket]: {
                ["English" /* Lang.English */]: ["Basket"],
                ["Spanish" /* Lang.Spanish */]: ["Cesta"],
                ["German" /* Lang.German */]: ["Korb"],
                ["Portuguese" /* Lang.Portuguese */]: ["Cesta"],
                ["French" /* Lang.French */]: ["Panier"],
                ["Italian" /* Lang.Italian */]: ["Cestino"],
                ["Hebrew" /* Lang.Hebrew */]: ["סל"],
                ["Russian" /* Lang.Russian */]: ["Корзина"],
                ["Arabic" /* Lang.Arabic */]: ["سلة"],
                ["Chinese Simplified" /* Lang.Chinese_Simplified */]: ["篮子"],
                ["Chinese Traditional" /* Lang.Chinese_Traditional */]: ["籃子"],
                ["Dutch" /* Lang.Dutch */]: ["Mand"],
                ["Japanese" /* Lang.Japanese */]: ["バスケット"],
                ["Turkish" /* Lang.Turkish */]: ["Sepet"],
                ["Polish" /* Lang.Polish */]: ["Koszyk"],
            },
            [Keyword.Cart]: {
                ["English" /* Lang.English */]: ["Cart"],
                ["Spanish" /* Lang.Spanish */]: ["Carrito", "Carro de compras"],
                ["German" /* Lang.German */]: ["Wagen", "Einkaufswagen"],
                ["Portuguese" /* Lang.Portuguese */]: ["Carrinho"],
                ["French" /* Lang.French */]: ["Chariot", "Panier d'achat"],
                ["Italian" /* Lang.Italian */]: ["Carrello"],
                ["Hebrew" /* Lang.Hebrew */]: ["עגלה", "עגלת קניות"],
                ["Russian" /* Lang.Russian */]: ["Корзина", "Корзина для покупок"],
                ["Arabic" /* Lang.Arabic */]: ["عربة", "عربة التسوق"],
                ["Chinese Simplified" /* Lang.Chinese_Simplified */]: ["购物车"],
                ["Chinese Traditional" /* Lang.Chinese_Traditional */]: ["購物車"],
                ["Dutch" /* Lang.Dutch */]: ["Winkelwagen", "Boodschappenkar"],
                ["Japanese" /* Lang.Japanese */]: ["カート", "ショッピングカート"],
                ["Turkish" /* Lang.Turkish */]: ["Sepet", "Alışveriş sepeti"],
                ["Polish" /* Lang.Polish */]: ["Wózek", "Koszyk zakupowy"],
            },
            [Keyword.Proposal]: {
                ["English" /* Lang.English */]: ["Proposal"],
                ["Spanish" /* Lang.Spanish */]: ["Propuesta"],
                ["German" /* Lang.German */]: ["Vorschlag"],
                ["Portuguese" /* Lang.Portuguese */]: ["Proposta"],
                ["French" /* Lang.French */]: ["Proposition"],
                ["Italian" /* Lang.Italian */]: ["Proposta"],
                ["Hebrew" /* Lang.Hebrew */]: ["הצעה"],
                ["Russian" /* Lang.Russian */]: ["Предложение"],
                ["Arabic" /* Lang.Arabic */]: ["اقتراح"],
                ["Chinese Simplified" /* Lang.Chinese_Simplified */]: ["提案"],
                ["Chinese Traditional" /* Lang.Chinese_Traditional */]: ["提案"],
                ["Dutch" /* Lang.Dutch */]: ["Voorstel"],
                ["Japanese" /* Lang.Japanese */]: ["提案"],
                ["Turkish" /* Lang.Turkish */]: ["Teklif"],
                ["Polish" /* Lang.Polish */]: ["Propozycja"],
            },
            [Keyword.Offer]: {
                ["English" /* Lang.English */]: ["Offer", "Deal", "Promotion", "Sale", "Discount"],
                ["Spanish" /* Lang.Spanish */]: ["Oferta", "Trato", "Promoción"],
                ["German" /* Lang.German */]: ["Angebot", "Aktion"],
                ["Portuguese" /* Lang.Portuguese */]: ["Oferta", "Negócio", "Promoção"],
                ["French" /* Lang.French */]: ["Offre", "Accord"],
                ["Italian" /* Lang.Italian */]: ["Offerta", "Affare", "Promozione"],
                ["Hebrew" /* Lang.Hebrew */]: ["הצעה"],
                ["Russian" /* Lang.Russian */]: ["Предложение", "Сделка", "Акция"],
                ["Arabic" /* Lang.Arabic */]: ["عرض", "صفقة", "ترويج"],
                ["Chinese Simplified" /* Lang.Chinese_Simplified */]: ["报价", "交易", "促销"],
                ["Chinese Traditional" /* Lang.Chinese_Traditional */]: ["報價", "交易", "促銷"],
                ["Dutch" /* Lang.Dutch */]: ["Aanbieding", "Promotie"],
                ["Japanese" /* Lang.Japanese */]: ["オファー", "取引", "プロモーション"],
                ["Turkish" /* Lang.Turkish */]: ["Teklif", "Anlaşma", "Promosyon"],
                ["Polish" /* Lang.Polish */]: ["Oferta", "Umowa", "Promocja"],
            },
            [Keyword.Quote]: {
                ["English" /* Lang.English */]: ["Quote"],
                ["Spanish" /* Lang.Spanish */]: ["Cotización"],
                ["German" /* Lang.German */]: ["Zitat"],
                ["Portuguese" /* Lang.Portuguese */]: ["Cotação"],
                ["French" /* Lang.French */]: ["Citation"],
                ["Italian" /* Lang.Italian */]: ["Quotazione"],
                ["Hebrew" /* Lang.Hebrew */]: ["ציטוט"],
                ["Russian" /* Lang.Russian */]: ["Цитата"],
                ["Arabic" /* Lang.Arabic */]: ["اقتباس"],
                ["Chinese Simplified" /* Lang.Chinese_Simplified */]: ["报价"],
                ["Chinese Traditional" /* Lang.Chinese_Traditional */]: ["報價"],
                ["Dutch" /* Lang.Dutch */]: ["Citaat"],
                ["Japanese" /* Lang.Japanese */]: ["見積もり"],
                ["Turkish" /* Lang.Turkish */]: ["Alıntı"],
                ["Polish" /* Lang.Polish */]: ["Cytat"],
            },
            [Keyword.Contact]: {
                ["English" /* Lang.English */]: ["Contact", "Get in touch", "Reach us"],
                ["Spanish" /* Lang.Spanish */]: ["Contacto", "Ponte en contacto", "Comunícate con nosotros"],
                ["German" /* Lang.German */]: ["Kontakt", "Erreichen Sie uns", "Kontaktieren Sie uns"],
                ["Portuguese" /* Lang.Portuguese */]: ["Contato", "Entre em contato", "Fale conosco"],
                ["French" /* Lang.French */]: ["Nous contacter", "Prenez contact"],
                ["Italian" /* Lang.Italian */]: ["Contatto", "Contattaci", "Entrare in contatto"],
                ["Hebrew" /* Lang.Hebrew */]: ["איש קשר", "צור קשר", "להתקשר אלינו"],
                ["Russian" /* Lang.Russian */]: ["Контакт", "Свяжитесь с нами", "Обратитесь к нам"],
                ["Arabic" /* Lang.Arabic */]: ["اتصال", "تواصل معنا", "تواصل معنا"],
                ["Chinese Simplified" /* Lang.Chinese_Simplified */]: ["联系", "与我们联系", "联络我们"],
                ["Chinese Traditional" /* Lang.Chinese_Traditional */]: ["聯繫", "與我們聯繫", "聯絡我們"],
                ["Dutch" /* Lang.Dutch */]: ["Neem contact op", "Bereik ons"],
                ["Japanese" /* Lang.Japanese */]: ["連絡先", "お問い合わせ", "お知らせ"],
                ["Turkish" /* Lang.Turkish */]: ["İletişim", "Bizimle iletişime geçin", "Bize ulaşın"],
                ["Polish" /* Lang.Polish */]: ["Kontakt", "Skontaktuj się", "Zadzwoń do nas"],
            },
            [Keyword.Whishlist]: {
                ["English" /* Lang.English */]: ["Wishlist"],
                ["Spanish" /* Lang.Spanish */]: ["Lista de deseos"],
                ["German" /* Lang.German */]: ["Wunschliste"],
                ["Portuguese" /* Lang.Portuguese */]: ["Lista de desejos"],
                ["French" /* Lang.French */]: ["Liste de souhaits"],
                ["Italian" /* Lang.Italian */]: ["Lista dei desideri"],
                ["Hebrew" /* Lang.Hebrew */]: ["רשימת משאלות"],
                ["Russian" /* Lang.Russian */]: ["Список желаний"],
                ["Arabic" /* Lang.Arabic */]: ["قائمة الأمنيات"],
                ["Chinese Simplified" /* Lang.Chinese_Simplified */]: ["愿望清单"],
                ["Chinese Traditional" /* Lang.Chinese_Traditional */]: ["願望清單"],
                ["Dutch" /* Lang.Dutch */]: ["Verlanglijst"],
                ["Japanese" /* Lang.Japanese */]: ["ウィッシュリスト"],
                ["Turkish" /* Lang.Turkish */]: ["İstek listesi"],
                ["Polish" /* Lang.Polish */]: ["Lista życzeń"],
            },
            [Keyword.Favorites]: {
                ["English" /* Lang.English */]: ["Favorites", "Bookmarks", "Saved", "Liked"],
                ["Spanish" /* Lang.Spanish */]: ["Favoritos", "Marcadores", "Guardados", "Gustados"],
                ["German" /* Lang.German */]: ["Favoriten", "Lesezeichen", "Gespeichert", "Gemocht"],
                ["Portuguese" /* Lang.Portuguese */]: ["Favoritos", "Marcadores", "Salvos", "Curtidos"],
                ["French" /* Lang.French */]: ["Favoris", "Signets", "Sauvegardés", "Aimés"],
                ["Italian" /* Lang.Italian */]: ["Preferiti", "Segnalibri", "Salvati", "Piaciuti"],
                ["Hebrew" /* Lang.Hebrew */]: ["מועדפים", "סימניות", "שמורים", "אהובים"],
                ["Russian" /* Lang.Russian */]: ["Избранное", "Закладки", "Сохраненные", "Понравившиеся"],
                ["Arabic" /* Lang.Arabic */]: ["المفضلة", "المرجعية", "المحفوظة", "أعجبت"],
                ["Chinese Simplified" /* Lang.Chinese_Simplified */]: ["收藏夹", "书签", "已保存", "喜欢"],
                ["Chinese Traditional" /* Lang.Chinese_Traditional */]: ["收藏夾", "書籤", "已保存", "喜歡"],
                ["Dutch" /* Lang.Dutch */]: ["Favorieten", "Bladwijzers", "Opgeslagen", "Leuk"],
                ["Japanese" /* Lang.Japanese */]: ["お気に入り", "ブックマーク", "保存済み", "好き"],
                ["Turkish" /* Lang.Turkish */]: ["Favoriler", "Yer işaretleri", "Kaydedilenler", "Beğenilenler"],
                ["Polish" /* Lang.Polish */]: ["Ulubione", "Zakładki", "Zapisane", "Polubione"],
            },
            [Keyword.Find]: {
                ["English" /* Lang.English */]: ["Find"],
                ["Spanish" /* Lang.Spanish */]: ["Encontrar"],
                ["German" /* Lang.German */]: ["Finden"],
                ["Portuguese" /* Lang.Portuguese */]: ["Encontrar"],
                ["French" /* Lang.French */]: ["Trouver"],
                ["Italian" /* Lang.Italian */]: ["Trovare"],
                ["Hebrew" /* Lang.Hebrew */]: ["למצוא"],
                ["Russian" /* Lang.Russian */]: ["Найти"],
                ["Arabic" /* Lang.Arabic */]: ["العثور"],
                ["Chinese Simplified" /* Lang.Chinese_Simplified */]: ["找到"],
                ["Chinese Traditional" /* Lang.Chinese_Traditional */]: ["找到"],
                ["Dutch" /* Lang.Dutch */]: ["Vinden"],
                ["Japanese" /* Lang.Japanese */]: ["見つける"],
                ["Turkish" /* Lang.Turkish */]: ["Bulmak"],
                ["Polish" /* Lang.Polish */]: ["Znaleźć"],
            },
            [Keyword.Search]: {
                ["English" /* Lang.English */]: ["Search", "Find", "Explore", "Look up"],
                ["Spanish" /* Lang.Spanish */]: ["Buscar", "Encontrar", "Explorar", "Búsqueda"],
                ["German" /* Lang.German */]: ["Suchen", "Finden", "Erkunden", "Durchsuchen"],
                ["Portuguese" /* Lang.Portuguese */]: ["Procurar", "Encontrar", "Explorar", "Pesquisar"],
                ["French" /* Lang.French */]: ["Rechercher", "Trouver", "Explorer", "Chercher"],
                ["Italian" /* Lang.Italian */]: ["Ricerca", "Trova", "Esplora", "Cerca"],
                ["Hebrew" /* Lang.Hebrew */]: ["חיפוש", "חפש"],
                ["Russian" /* Lang.Russian */]: ["Поиск", "Найти", "Искать", "Поиск информации"],
                ["Arabic" /* Lang.Arabic */]: ["بحث", "العثور على", "استكشاف", "البحث"],
                ["Chinese Simplified" /* Lang.Chinese_Simplified */]: ["搜索", "查找", "探索", "查找信息"],
                ["Chinese Traditional" /* Lang.Chinese_Traditional */]: ["搜尋", "查找", "探索", "尋找資訊"],
                ["Dutch" /* Lang.Dutch */]: ["Zoeken", "Vinden", "Ontdekken", "Zoek op"],
                ["Japanese" /* Lang.Japanese */]: ["検索", "見つける", "探索する", "調べる"],
                ["Turkish" /* Lang.Turkish */]: ["Arama", "Bul", "Keşfet", "Ara"],
                ["Polish" /* Lang.Polish */]: ["Szukaj", "Znajdź", "Eksploruj", "Wyszukaj"],
            },
            [Keyword.Rss]: {
                ["English" /* Lang.English */]: ["RSS"],
                ["Spanish" /* Lang.Spanish */]: [],
                ["German" /* Lang.German */]: [],
                ["Portuguese" /* Lang.Portuguese */]: [],
                ["French" /* Lang.French */]: [],
                ["Italian" /* Lang.Italian */]: [],
                ["Hebrew" /* Lang.Hebrew */]: ["אֶרֶאֶסֶס"],
                ["Russian" /* Lang.Russian */]: ["РСС"],
                ["Arabic" /* Lang.Arabic */]: ["آر إس إس"],
                ["Chinese Simplified" /* Lang.Chinese_Simplified */]: ["简易信息聚合"],
                ["Chinese Traditional" /* Lang.Chinese_Traditional */]: ["簡易信息聚合"],
                ["Dutch" /* Lang.Dutch */]: [],
                ["Japanese" /* Lang.Japanese */]: ["アールエスエス"],
                ["Turkish" /* Lang.Turkish */]: [],
                ["Polish" /* Lang.Polish */]: [],
            },
            [Keyword.Feed]: {
                ["English" /* Lang.English */]: ["Feed"],
                ["Spanish" /* Lang.Spanish */]: ["Alimentación"],
                ["German" /* Lang.German */]: [],
                ["Portuguese" /* Lang.Portuguese */]: [],
                ["French" /* Lang.French */]: ["Flux"],
                ["Italian" /* Lang.Italian */]: [],
                ["Hebrew" /* Lang.Hebrew */]: ["זרם"],
                ["Russian" /* Lang.Russian */]: ["Лента"],
                ["Arabic" /* Lang.Arabic */]: ["تغذية"],
                ["Chinese Simplified" /* Lang.Chinese_Simplified */]: ["订阅源"],
                ["Chinese Traditional" /* Lang.Chinese_Traditional */]: ["訂閱源"],
                ["Dutch" /* Lang.Dutch */]: [],
                ["Japanese" /* Lang.Japanese */]: ["フィード"],
                ["Turkish" /* Lang.Turkish */]: ["Besleme"],
                ["Polish" /* Lang.Polish */]: ["Kanał"],
            },
            [Keyword.Home]: {
                ["English" /* Lang.English */]: ["Home", "Main", "Start", "Front page"],
                ["Spanish" /* Lang.Spanish */]: ["Inicio", "Principal", "Página de inicio"],
                ["German" /* Lang.German */]: ["Hauptseite", "Hauptmenü"],
                ["Portuguese" /* Lang.Portuguese */]: ["Início", "Principal", "Página principal"],
                ["French" /* Lang.French */]: ["Accueil", "Principal", "Page principale"],
                ["Italian" /* Lang.Italian */]: ["Principale", "Pagina iniziale"],
                ["Hebrew" /* Lang.Hebrew */]: ["בית", "ראשי", "דף הבית"],
                ["Russian" /* Lang.Russian */]: ["Главная", "Основной", "Начало"],
                ["Arabic" /* Lang.Arabic */]: ["الصفحة الرئيسية", "الرئيسي", "البداية"],
                ["Chinese Simplified" /* Lang.Chinese_Simplified */]: ["主页", "主要", "开始"],
                ["Chinese Traditional" /* Lang.Chinese_Traditional */]: ["首頁", "主要", "開始"],
                ["Dutch" /* Lang.Dutch */]: ["Hoofd"],
                ["Japanese" /* Lang.Japanese */]: ["ホーム", "メイン", "スタート"],
                ["Turkish" /* Lang.Turkish */]: ["Ana Sayfa", "Ana", "Başlangıç"],
                ["Polish" /* Lang.Polish */]: ["Strona główna", "Główny"],
            },
            [Keyword.GoogleMaps]: {
                ["English" /* Lang.English */]: ["Google Maps", "google-maps"],
                ["Spanish" /* Lang.Spanish */]: [],
                ["German" /* Lang.German */]: [],
                ["Portuguese" /* Lang.Portuguese */]: [],
                ["French" /* Lang.French */]: [],
                ["Italian" /* Lang.Italian */]: [],
                ["Hebrew" /* Lang.Hebrew */]: ["גוגל מפות"],
                ["Russian" /* Lang.Russian */]: ["Google Карты"],
                ["Arabic" /* Lang.Arabic */]: ["خرائط Google"],
                ["Chinese Simplified" /* Lang.Chinese_Simplified */]: ["谷歌地图"],
                ["Chinese Traditional" /* Lang.Chinese_Traditional */]: ["谷歌地圖"],
                ["Dutch" /* Lang.Dutch */]: [],
                ["Japanese" /* Lang.Japanese */]: ["Google マップ"],
                ["Turkish" /* Lang.Turkish */]: ["Google Haritalar"],
                ["Polish" /* Lang.Polish */]: [],
            },
            [Keyword.Pinterest]: {
                ["English" /* Lang.English */]: ["Pinterest"],
                ["Spanish" /* Lang.Spanish */]: [],
                ["German" /* Lang.German */]: [],
                ["Portuguese" /* Lang.Portuguese */]: [],
                ["French" /* Lang.French */]: [],
                ["Italian" /* Lang.Italian */]: [],
                ["Hebrew" /* Lang.Hebrew */]: ["פינטרסט"],
                ["Russian" /* Lang.Russian */]: [],
                ["Arabic" /* Lang.Arabic */]: ["بينتيرست"],
                ["Chinese Simplified" /* Lang.Chinese_Simplified */]: [],
                ["Chinese Traditional" /* Lang.Chinese_Traditional */]: [],
                ["Dutch" /* Lang.Dutch */]: [],
                ["Japanese" /* Lang.Japanese */]: [],
                ["Turkish" /* Lang.Turkish */]: [],
                ["Polish" /* Lang.Polish */]: [],
            },
            [Keyword.Flickr]: {
                ["English" /* Lang.English */]: ["Flickr"],
                ["Spanish" /* Lang.Spanish */]: [],
                ["German" /* Lang.German */]: [],
                ["Portuguese" /* Lang.Portuguese */]: [],
                ["French" /* Lang.French */]: [],
                ["Italian" /* Lang.Italian */]: [],
                ["Hebrew" /* Lang.Hebrew */]: ["פליקר"],
                ["Russian" /* Lang.Russian */]: ["Фликр"],
                ["Arabic" /* Lang.Arabic */]: ["فليكر"],
                ["Chinese Simplified" /* Lang.Chinese_Simplified */]: [],
                ["Chinese Traditional" /* Lang.Chinese_Traditional */]: [],
                ["Dutch" /* Lang.Dutch */]: [],
                ["Japanese" /* Lang.Japanese */]: [],
                ["Turkish" /* Lang.Turkish */]: [],
                ["Polish" /* Lang.Polish */]: [],
            },
            [Keyword.Tumblr]: {
                ["English" /* Lang.English */]: ["Tumblr"],
                ["Spanish" /* Lang.Spanish */]: [],
                ["German" /* Lang.German */]: [],
                ["Portuguese" /* Lang.Portuguese */]: [],
                ["French" /* Lang.French */]: [],
                ["Italian" /* Lang.Italian */]: [],
                ["Hebrew" /* Lang.Hebrew */]: ["טאמבלר"],
                ["Russian" /* Lang.Russian */]: ["Тумблер"],
                ["Arabic" /* Lang.Arabic */]: ["تمبلر"],
                ["Chinese Simplified" /* Lang.Chinese_Simplified */]: [],
                ["Chinese Traditional" /* Lang.Chinese_Traditional */]: [],
                ["Dutch" /* Lang.Dutch */]: [],
                ["Japanese" /* Lang.Japanese */]: [],
                ["Turkish" /* Lang.Turkish */]: [],
                ["Polish" /* Lang.Polish */]: [],
            },
            [Keyword.Reddit]: {
                ["English" /* Lang.English */]: ["Reddit"],
                ["Spanish" /* Lang.Spanish */]: [],
                ["German" /* Lang.German */]: [],
                ["Portuguese" /* Lang.Portuguese */]: [],
                ["French" /* Lang.French */]: [],
                ["Italian" /* Lang.Italian */]: [],
                ["Hebrew" /* Lang.Hebrew */]: ["רדיט"],
                ["Russian" /* Lang.Russian */]: [],
                ["Arabic" /* Lang.Arabic */]: ["ريديت"],
                ["Chinese Simplified" /* Lang.Chinese_Simplified */]: [],
                ["Chinese Traditional" /* Lang.Chinese_Traditional */]: [],
                ["Dutch" /* Lang.Dutch */]: [],
                ["Japanese" /* Lang.Japanese */]: [],
                ["Turkish" /* Lang.Turkish */]: [],
                ["Polish" /* Lang.Polish */]: [],
            },
            [Keyword.Youtube]: {
                ["English" /* Lang.English */]: ["YouTube"],
                ["Spanish" /* Lang.Spanish */]: [],
                ["German" /* Lang.German */]: [],
                ["Portuguese" /* Lang.Portuguese */]: [],
                ["French" /* Lang.French */]: [],
                ["Italian" /* Lang.Italian */]: [],
                ["Hebrew" /* Lang.Hebrew */]: ["יוטיוב"],
                ["Russian" /* Lang.Russian */]: [],
                ["Arabic" /* Lang.Arabic */]: ["يوتيوب"],
                ["Chinese Simplified" /* Lang.Chinese_Simplified */]: [],
                ["Chinese Traditional" /* Lang.Chinese_Traditional */]: [],
                ["Dutch" /* Lang.Dutch */]: [],
                ["Japanese" /* Lang.Japanese */]: [],
                ["Turkish" /* Lang.Turkish */]: [],
                ["Polish" /* Lang.Polish */]: [],
            },
            [Keyword.Whatsapp]: {
                ["English" /* Lang.English */]: ["WhatsApp"],
                ["Spanish" /* Lang.Spanish */]: [],
                ["German" /* Lang.German */]: [],
                ["Portuguese" /* Lang.Portuguese */]: [],
                ["French" /* Lang.French */]: [],
                ["Italian" /* Lang.Italian */]: [],
                ["Hebrew" /* Lang.Hebrew */]: ["וואטסאפ"],
                ["Russian" /* Lang.Russian */]: [],
                ["Arabic" /* Lang.Arabic */]: ["واتساب"],
                ["Chinese Simplified" /* Lang.Chinese_Simplified */]: [],
                ["Chinese Traditional" /* Lang.Chinese_Traditional */]: [],
                ["Dutch" /* Lang.Dutch */]: [],
                ["Japanese" /* Lang.Japanese */]: [],
                ["Turkish" /* Lang.Turkish */]: [],
                ["Polish" /* Lang.Polish */]: [],
            },
            [Keyword.Tiktok]: {
                ["English" /* Lang.English */]: ["TikTok", "Tik-Tok"],
                ["Spanish" /* Lang.Spanish */]: [],
                ["German" /* Lang.German */]: [],
                ["Portuguese" /* Lang.Portuguese */]: [],
                ["French" /* Lang.French */]: [],
                ["Italian" /* Lang.Italian */]: [],
                ["Hebrew" /* Lang.Hebrew */]: ["טיקטוק"],
                ["Russian" /* Lang.Russian */]: ["ТикТок"],
                ["Arabic" /* Lang.Arabic */]: ["تيك توك"],
                ["Chinese Simplified" /* Lang.Chinese_Simplified */]: ["抖音"],
                ["Chinese Traditional" /* Lang.Chinese_Traditional */]: ["抖音"],
                ["Dutch" /* Lang.Dutch */]: [],
                ["Japanese" /* Lang.Japanese */]: [],
                ["Turkish" /* Lang.Turkish */]: [],
                ["Polish" /* Lang.Polish */]: [],
            },
            [Keyword.Yelp]: {
                ["English" /* Lang.English */]: ["Yelp"],
                ["Spanish" /* Lang.Spanish */]: [],
                ["German" /* Lang.German */]: [],
                ["Portuguese" /* Lang.Portuguese */]: [],
                ["French" /* Lang.French */]: [],
                ["Italian" /* Lang.Italian */]: [],
                ["Hebrew" /* Lang.Hebrew */]: ["יֶלפּ"],
                ["Russian" /* Lang.Russian */]: ["Йелп"],
                ["Arabic" /* Lang.Arabic */]: ["يلب"],
                ["Chinese Simplified" /* Lang.Chinese_Simplified */]: [],
                ["Chinese Traditional" /* Lang.Chinese_Traditional */]: [],
                ["Dutch" /* Lang.Dutch */]: [],
                ["Japanese" /* Lang.Japanese */]: [],
                ["Turkish" /* Lang.Turkish */]: [],
                ["Polish" /* Lang.Polish */]: [],
            },
            [Keyword.Tripadvisor]: {
                ["English" /* Lang.English */]: ["Tripadvisor", "Trip Advisor"],
                ["Spanish" /* Lang.Spanish */]: [],
                ["German" /* Lang.German */]: [],
                ["Portuguese" /* Lang.Portuguese */]: [],
                ["French" /* Lang.French */]: [],
                ["Italian" /* Lang.Italian */]: [],
                ["Hebrew" /* Lang.Hebrew */]: ["טריפאדבייזר", "טריפ אדבייזר"],
                ["Russian" /* Lang.Russian */]: ["Трипадвайзер", "Трип Адвайзер"],
                ["Arabic" /* Lang.Arabic */]: ["تريب أدفايزر", "تريب أدفيزر"],
                ["Chinese Simplified" /* Lang.Chinese_Simplified */]: [],
                ["Chinese Traditional" /* Lang.Chinese_Traditional */]: [],
                ["Dutch" /* Lang.Dutch */]: [],
                ["Japanese" /* Lang.Japanese */]: [],
                ["Turkish" /* Lang.Turkish */]: [],
                ["Polish" /* Lang.Polish */]: [],
            },
            [Keyword.Twitter]: {
                ["English" /* Lang.English */]: ["Twitter"],
                ["Spanish" /* Lang.Spanish */]: [],
                ["German" /* Lang.German */]: [],
                ["Portuguese" /* Lang.Portuguese */]: [],
                ["French" /* Lang.French */]: [],
                ["Italian" /* Lang.Italian */]: [],
                ["Hebrew" /* Lang.Hebrew */]: ["טוויטר"],
                ["Russian" /* Lang.Russian */]: ["Твиттер"],
                ["Arabic" /* Lang.Arabic */]: ["تويتر"],
                ["Chinese Simplified" /* Lang.Chinese_Simplified */]: [],
                ["Chinese Traditional" /* Lang.Chinese_Traditional */]: [],
                ["Dutch" /* Lang.Dutch */]: [],
                ["Japanese" /* Lang.Japanese */]: [],
                ["Turkish" /* Lang.Turkish */]: [],
                ["Polish" /* Lang.Polish */]: [],
            },
            [Keyword.Instagram]: {
                ["English" /* Lang.English */]: ["Instagram"],
                ["Spanish" /* Lang.Spanish */]: [],
                ["German" /* Lang.German */]: [],
                ["Portuguese" /* Lang.Portuguese */]: [],
                ["French" /* Lang.French */]: [],
                ["Italian" /* Lang.Italian */]: [],
                ["Hebrew" /* Lang.Hebrew */]: ["אינסטגרם"],
                ["Russian" /* Lang.Russian */]: ["Инстаграм"],
                ["Arabic" /* Lang.Arabic */]: ["إنستغرام"],
                ["Chinese Simplified" /* Lang.Chinese_Simplified */]: [],
                ["Chinese Traditional" /* Lang.Chinese_Traditional */]: [],
                ["Dutch" /* Lang.Dutch */]: [],
                ["Japanese" /* Lang.Japanese */]: [],
                ["Turkish" /* Lang.Turkish */]: [],
                ["Polish" /* Lang.Polish */]: [],
            },
            [Keyword.Snapchat]: {
                ["English" /* Lang.English */]: ["Snapchat"],
                ["Spanish" /* Lang.Spanish */]: [],
                ["German" /* Lang.German */]: [],
                ["Portuguese" /* Lang.Portuguese */]: [],
                ["French" /* Lang.French */]: [],
                ["Italian" /* Lang.Italian */]: [],
                ["Hebrew" /* Lang.Hebrew */]: ["סנאפצ'ט"],
                ["Russian" /* Lang.Russian */]: ["Снапчат"],
                ["Arabic" /* Lang.Arabic */]: ["سناب شات"],
                ["Chinese Simplified" /* Lang.Chinese_Simplified */]: [],
                ["Chinese Traditional" /* Lang.Chinese_Traditional */]: [],
                ["Dutch" /* Lang.Dutch */]: [],
                ["Japanese" /* Lang.Japanese */]: [],
                ["Turkish" /* Lang.Turkish */]: [],
                ["Polish" /* Lang.Polish */]: [],
            },
            [Keyword.Github]: {
                ["English" /* Lang.English */]: ["GitHub", "Discussion", "Community", "Fork"],
                ["Spanish" /* Lang.Spanish */]: [],
                ["German" /* Lang.German */]: [],
                ["Portuguese" /* Lang.Portuguese */]: [],
                ["French" /* Lang.French */]: [],
                ["Italian" /* Lang.Italian */]: [],
                ["Hebrew" /* Lang.Hebrew */]: ["גיטהאב"],
                ["Russian" /* Lang.Russian */]: ["ГитХаб"],
                ["Arabic" /* Lang.Arabic */]: ["جيت هاب"],
                ["Chinese Simplified" /* Lang.Chinese_Simplified */]: [],
                ["Chinese Traditional" /* Lang.Chinese_Traditional */]: [],
                ["Dutch" /* Lang.Dutch */]: [],
                ["Japanese" /* Lang.Japanese */]: [],
                ["Turkish" /* Lang.Turkish */]: [],
                ["Polish" /* Lang.Polish */]: [],
            },
            [Keyword.Waze]: {
                ["English" /* Lang.English */]: ["Waze"],
                ["Spanish" /* Lang.Spanish */]: [],
                ["German" /* Lang.German */]: [],
                ["Portuguese" /* Lang.Portuguese */]: [],
                ["French" /* Lang.French */]: [],
                ["Italian" /* Lang.Italian */]: [],
                ["Hebrew" /* Lang.Hebrew */]: ["ווייז"],
                ["Russian" /* Lang.Russian */]: ["Вейз"],
                ["Arabic" /* Lang.Arabic */]: ["ويز"],
                ["Chinese Simplified" /* Lang.Chinese_Simplified */]: [],
                ["Chinese Traditional" /* Lang.Chinese_Traditional */]: [],
                ["Dutch" /* Lang.Dutch */]: [],
                ["Japanese" /* Lang.Japanese */]: [],
                ["Turkish" /* Lang.Turkish */]: [],
                ["Polish" /* Lang.Polish */]: [],
            },
            [Keyword.Dribble]: {
                ["English" /* Lang.English */]: ["Dribbble"],
                ["Spanish" /* Lang.Spanish */]: [],
                ["German" /* Lang.German */]: [],
                ["Portuguese" /* Lang.Portuguese */]: [],
                ["French" /* Lang.French */]: [],
                ["Italian" /* Lang.Italian */]: [],
                ["Hebrew" /* Lang.Hebrew */]: ["דריבל"],
                ["Russian" /* Lang.Russian */]: ["Дриббл"],
                ["Arabic" /* Lang.Arabic */]: ["دريبل"],
                ["Chinese Simplified" /* Lang.Chinese_Simplified */]: [],
                ["Chinese Traditional" /* Lang.Chinese_Traditional */]: [],
                ["Dutch" /* Lang.Dutch */]: [],
                ["Japanese" /* Lang.Japanese */]: [],
                ["Turkish" /* Lang.Turkish */]: [],
                ["Polish" /* Lang.Polish */]: [],
            },
            [Keyword.Linkedin]: {
                ["English" /* Lang.English */]: ["LinkedIn"],
                ["Spanish" /* Lang.Spanish */]: [],
                ["German" /* Lang.German */]: [],
                ["Portuguese" /* Lang.Portuguese */]: [],
                ["French" /* Lang.French */]: [],
                ["Italian" /* Lang.Italian */]: [],
                ["Hebrew" /* Lang.Hebrew */]: ["לינקדאין"],
                ["Russian" /* Lang.Russian */]: ["ЛинкедИн"],
                ["Arabic" /* Lang.Arabic */]: ["لينكد إن"],
                ["Chinese Simplified" /* Lang.Chinese_Simplified */]: [],
                ["Chinese Traditional" /* Lang.Chinese_Traditional */]: [],
                ["Dutch" /* Lang.Dutch */]: [],
                ["Japanese" /* Lang.Japanese */]: [],
                ["Turkish" /* Lang.Turkish */]: [],
                ["Polish" /* Lang.Polish */]: [],
            },
            [Keyword.Medium]: {
                ["English" /* Lang.English */]: ["Medium"],
                ["Spanish" /* Lang.Spanish */]: [],
                ["German" /* Lang.German */]: [],
                ["Portuguese" /* Lang.Portuguese */]: [],
                ["French" /* Lang.French */]: [],
                ["Italian" /* Lang.Italian */]: [],
                ["Hebrew" /* Lang.Hebrew */]: ["מדיום"],
                ["Russian" /* Lang.Russian */]: ["Медиум"],
                ["Arabic" /* Lang.Arabic */]: ["ميديوم"],
                ["Chinese Simplified" /* Lang.Chinese_Simplified */]: [],
                ["Chinese Traditional" /* Lang.Chinese_Traditional */]: [],
                ["Dutch" /* Lang.Dutch */]: [],
                ["Japanese" /* Lang.Japanese */]: [],
                ["Turkish" /* Lang.Turkish */]: [],
                ["Polish" /* Lang.Polish */]: [],
            },
            [Keyword.Xing]: {
                ["English" /* Lang.English */]: ["Xing"],
                ["Spanish" /* Lang.Spanish */]: [],
                ["German" /* Lang.German */]: [],
                ["Portuguese" /* Lang.Portuguese */]: [],
                ["French" /* Lang.French */]: [],
                ["Italian" /* Lang.Italian */]: [],
                ["Hebrew" /* Lang.Hebrew */]: ["קסינג"],
                ["Russian" /* Lang.Russian */]: ["Ксинг"],
                ["Arabic" /* Lang.Arabic */]: ["إكسينج"],
                ["Chinese Simplified" /* Lang.Chinese_Simplified */]: [],
                ["Chinese Traditional" /* Lang.Chinese_Traditional */]: [],
                ["Dutch" /* Lang.Dutch */]: [],
                ["Japanese" /* Lang.Japanese */]: [],
                ["Turkish" /* Lang.Turkish */]: [],
                ["Polish" /* Lang.Polish */]: [],
            },
            [Keyword.Yandex]: {
                ["English" /* Lang.English */]: ["Yandex"],
                ["Spanish" /* Lang.Spanish */]: [],
                ["German" /* Lang.German */]: [],
                ["Portuguese" /* Lang.Portuguese */]: [],
                ["French" /* Lang.French */]: [],
                ["Italian" /* Lang.Italian */]: [],
                ["Hebrew" /* Lang.Hebrew */]: ["יאנדקס"],
                ["Russian" /* Lang.Russian */]: ["Яндекс"],
                ["Arabic" /* Lang.Arabic */]: ["ياندكس"],
                ["Chinese Simplified" /* Lang.Chinese_Simplified */]: [],
                ["Chinese Traditional" /* Lang.Chinese_Traditional */]: [],
                ["Dutch" /* Lang.Dutch */]: [],
                ["Japanese" /* Lang.Japanese */]: [],
                ["Turkish" /* Lang.Turkish */]: [],
                ["Polish" /* Lang.Polish */]: [],
            },
            [Keyword.Yahoo]: {
                ["English" /* Lang.English */]: ["Yahoo"],
                ["Spanish" /* Lang.Spanish */]: [],
                ["German" /* Lang.German */]: [],
                ["Portuguese" /* Lang.Portuguese */]: [],
                ["French" /* Lang.French */]: [],
                ["Italian" /* Lang.Italian */]: [],
                ["Hebrew" /* Lang.Hebrew */]: ["יאהו"],
                ["Russian" /* Lang.Russian */]: ["Яху"],
                ["Arabic" /* Lang.Arabic */]: ["ياهو"],
                ["Chinese Simplified" /* Lang.Chinese_Simplified */]: [],
                ["Chinese Traditional" /* Lang.Chinese_Traditional */]: [],
                ["Dutch" /* Lang.Dutch */]: [],
                ["Japanese" /* Lang.Japanese */]: [],
                ["Turkish" /* Lang.Turkish */]: [],
                ["Polish" /* Lang.Polish */]: [],
            },
            [Keyword.Facebook]: {
                ["English" /* Lang.English */]: ["Facebook"],
                ["Spanish" /* Lang.Spanish */]: [],
                ["German" /* Lang.German */]: [],
                ["Portuguese" /* Lang.Portuguese */]: [],
                ["French" /* Lang.French */]: [],
                ["Italian" /* Lang.Italian */]: [],
                ["Hebrew" /* Lang.Hebrew */]: ["פייסבוק"],
                ["Russian" /* Lang.Russian */]: ["Фейсбук"],
                ["Arabic" /* Lang.Arabic */]: ["فيسبوك"],
                ["Chinese Simplified" /* Lang.Chinese_Simplified */]: [],
                ["Chinese Traditional" /* Lang.Chinese_Traditional */]: [],
                ["Dutch" /* Lang.Dutch */]: [],
                ["Japanese" /* Lang.Japanese */]: [],
                ["Turkish" /* Lang.Turkish */]: [],
                ["Polish" /* Lang.Polish */]: [],
            },
            [Keyword.Email]: {
                ["English" /* Lang.English */]: ["Email", "E-mail", "Electronic mail", /.*@.+/],
                ["Spanish" /* Lang.Spanish */]: ["Correo electrónico"],
                ["German" /* Lang.German */]: ["Elektronische Post"],
                ["Portuguese" /* Lang.Portuguese */]: ["Correio eletrônico"],
                ["French" /* Lang.French */]: ["Courrier électronique"],
                ["Italian" /* Lang.Italian */]: ["Posta elettronica"],
                ["Hebrew" /* Lang.Hebrew */]: ["מייל", "דואר אלקטרוני", "אימייל"],
                ["Russian" /* Lang.Russian */]: ["Электронная почта"],
                ["Arabic" /* Lang.Arabic */]: ["البريد الإلكتروني", "البريد الإلكترونيّ"],
                ["Chinese Simplified" /* Lang.Chinese_Simplified */]: ["电子邮件", "电邮"],
                ["Chinese Traditional" /* Lang.Chinese_Traditional */]: ["電子郵件", "電郵"],
                ["Dutch" /* Lang.Dutch */]: ["Elektronische post"],
                ["Japanese" /* Lang.Japanese */]: ["電子メール", "メール"],
                ["Turkish" /* Lang.Turkish */]: ["E-posta", "Elektronik posta"],
                ["Polish" /* Lang.Polish */]: ["Poczta elektroniczna"],
            },
            [Keyword.Phone]: {
                ["English" /* Lang.English */]: ["Phone", "Telephone", "Tel"],
                ["Spanish" /* Lang.Spanish */]: ["Teléfono"],
                ["German" /* Lang.German */]: ["Telefon"],
                ["Portuguese" /* Lang.Portuguese */]: ["Telefone"],
                ["French" /* Lang.French */]: ["Téléphone"],
                ["Italian" /* Lang.Italian */]: ["Telefono"],
                ["Hebrew" /* Lang.Hebrew */]: ["טלפון", "טל"],
                ["Russian" /* Lang.Russian */]: ["Телефон"],
                ["Arabic" /* Lang.Arabic */]: ["هاتف", "تليفون"],
                ["Chinese Simplified" /* Lang.Chinese_Simplified */]: ["电话", "打电话", "打电话给"],
                ["Chinese Traditional" /* Lang.Chinese_Traditional */]: ["電話", "撥打電話"],
                ["Dutch" /* Lang.Dutch */]: ["Telefoon"],
                ["Japanese" /* Lang.Japanese */]: ["電話", "電話する"],
                ["Turkish" /* Lang.Turkish */]: [],
                ["Polish" /* Lang.Polish */]: [],
            },
            [Keyword.Image]: {
                ["English" /* Lang.English */]: ["Image", "Picture", "Photo"],
                ["Spanish" /* Lang.Spanish */]: ["Imagen", "Foto"],
                ["German" /* Lang.German */]: ["Bild", "Foto"],
                ["Portuguese" /* Lang.Portuguese */]: ["Imagem", "Foto"],
                ["French" /* Lang.French */]: ["Image", "Photo"],
                ["Italian" /* Lang.Italian */]: ["Immagine", "Foto"],
                ["Hebrew" /* Lang.Hebrew */]: ["תמונה"],
                ["Russian" /* Lang.Russian */]: ["Изображение", "Фото"],
                ["Arabic" /* Lang.Arabic */]: ["صورة", "صورة فوتوغرافية"],
                ["Chinese Simplified" /* Lang.Chinese_Simplified */]: ["图片", "照片"],
                ["Chinese Traditional" /* Lang.Chinese_Traditional */]: ["圖片", "照片"],
                ["Dutch" /* Lang.Dutch */]: ["Afbeelding", "Foto"],
                ["Japanese" /* Lang.Japanese */]: ["画像", "写真"],
                ["Turkish" /* Lang.Turkish */]: ["Resim", "Fotoğraf"],
                ["Polish" /* Lang.Polish */]: ["Obraz", "Zdjęcie"],
            },
            [Keyword.Pdf]: {
                ["English" /* Lang.English */]: ["PDF"],
                ["Spanish" /* Lang.Spanish */]: [],
                ["German" /* Lang.German */]: [],
                ["Portuguese" /* Lang.Portuguese */]: [],
                ["French" /* Lang.French */]: [],
                ["Italian" /* Lang.Italian */]: [],
                ["Hebrew" /* Lang.Hebrew */]: [],
                ["Russian" /* Lang.Russian */]: [],
                ["Arabic" /* Lang.Arabic */]: [],
                ["Chinese Simplified" /* Lang.Chinese_Simplified */]: [],
                ["Chinese Traditional" /* Lang.Chinese_Traditional */]: [],
                ["Dutch" /* Lang.Dutch */]: [],
                ["Japanese" /* Lang.Japanese */]: [],
                ["Turkish" /* Lang.Turkish */]: [],
                ["Polish" /* Lang.Polish */]: [],
            },
        },
    };

    class LangService {
        matchers;
        constructor(matchers) {
            this.matchers = matchers;
        }
        getKeyword(extractedText, keyword, context = "general" /* LangContext.general */) {
            if (!extractedText)
                return null;
            if (!keyword)
                throw new Error(`No keyword provided for ${context}`);
            keyword = keyword.toLowerCase();
            const lowerCaseText = extractedText.toLowerCase();
            const translationEntry = this.matchers[context];
            const translations = translationEntry[keyword];
            if (!translations) {
                console.warn(`No translations for keyword: ${keyword} in context: ${context}`);
                return null;
            }
            const entries = Object.values(translations);
            if (entries.some((words) => words.some((w) => w instanceof RegExp ? w.test(lowerCaseText) : lowerCaseText.includes(w.toLowerCase())))) {
                return keyword;
            }
            return null;
        }
    }
    const langService = new LangService(translations);

    class CAROUSELS extends Criteria {
        static async audit(dynamic, $els) {
            return helper.runAuditMethods(new this(), dynamic, $els);
        }
        liveCarousels() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            for (const $el of helper.elements.filterHiddens(document.querySelectorAll("[data-aflw-carousel]"))) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                const report = helper.reportObject($el, 100);
                if (!$el.querySelector("[aria-live]") && !$el.closest("[aria-live]"))
                    report.success = true;
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
        carouselArrows() {
            const reports = {};
            const nextSelectors = [
                ".owl-next",
                ".bx-next",
                ".next",
                ".nivo-prevNext",
                ".flex-next",
                ".slick-next",
                ".slick-arrow",
                ".slick-next",
                ".et-pb-arrow-next",
                ".tp-rightarrow",
                ".acsb-carousel-next",
                ".flickity-prev-next-button.next",
                ".fusion-nav-next",
                ".ls-nav-next",
                ".swiper-button-next",
                '[data-slide="next"]',
                ".nextend-arrow-next",
                ".uk-slidenav-next",
                ".jcarousel-control-next",
                ".acsb-carousel-next",
            ];
            const prevSelectors = [
                ".owl-prev",
                ".bx-prev",
                ".flex-prev",
                ".slick-prev",
                ".nivo-prevNav",
                ".prev",
                ".previous",
                ".acsb-carousel-prev",
                ".et-pb-arrow-prev",
                ".tp-leftarrow",
                ".flickity-prev-next-button.previous",
                ".fusion-nav-prev",
                ".ls-nav-prev",
                ".swiper-button-prev",
                ".nextend-arrow-previous",
                ".uk-slidenav-previous",
                ".jcarousel-control-prev",
                ".cycle-prev",
                '[data-slide="prev"]',
            ];
            for (const $el of helper.elements.filterHiddens(document.querySelectorAll("[data-aflw-clickable]"))) {
                if (helper.checkElementAudited($el, "aflwCarouselArrowAudited"))
                    continue;
                let process = $el.matches("[data-aflw-button]");
                const inCarousel = $el.closest("[data-aflw-carousel]");
                if (!process && $el.tagName === "A" && $el.href?.includes("#") && inCarousel) {
                    try {
                        const $destination = document.querySelector($el.getAttribute("href") || "");
                        if ($destination && $destination.closest("[data-aflw-carousel]"))
                            process = true;
                    }
                    catch (err) { }
                }
                if (!process)
                    continue;
                let isNext = false;
                let isPrev = false;
                if (inCarousel && $el.matches('[class*="next"], [class*="right"]')) {
                    isNext = true;
                }
                else {
                    for (const selector of nextSelectors) {
                        if (!$el.closest(selector))
                            continue;
                        isNext = true;
                        break;
                    }
                }
                if (!isNext) {
                    if (inCarousel && $el.matches('[class*="prev"], [class*="left"]')) {
                        isPrev = true;
                    }
                    else {
                        for (const selector of prevSelectors) {
                            if (!$el.closest(selector))
                                continue;
                            isPrev = true;
                            break;
                        }
                    }
                }
                if (!isNext && !isPrev)
                    continue;
                const text = $el.getAttribute("aria-label") || helper.elements.getText($el);
                const report = helper.reportObject($el, 91, isNext ? "next" : "previous", "button");
                const keyWordFound = langService.getKeyword(text, Keyword.Next, "carousel" /* LangContext.carousel */) ||
                    langService.getKeyword(text, Keyword.Previous, "carousel" /* LangContext.carousel */);
                if (keyWordFound)
                    report.success = true;
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
        carouselLabeling() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            for (const $el of helper.elements.filterHiddens(document.querySelectorAll("[data-aflw-carousel]"))) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                const report = helper.reportObject($el, 93, "carousel");
                if ($el.getAttribute("role") === "region" &&
                    ($el.getAttribute("aria-label") ||
                        $el.getAttribute("aria-labelledby") ||
                        $el.getAttribute("aria-roledescription")))
                    report.success = true;
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
        carouselPagination() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            const selectors = [
                ".n2-ow",
                ".n2-bullet",
                ".owl-dot",
                ".owl-page",
                ".tp-bullet",
                ".uk-dotnav",
                ".tp-thumb",
                ".swiper-pagination-bullet",
                ".nivo-control",
                ".acsb-carousel-dot",
                ".bx-pager-item",
                "[uk-slideshow-item]",
                "[uk-slider-item]",
                "[data-slide-to]",
                ".swiper-pagination-bullet",
                ".nextend-bullet-bar",
                ".tp-thumbs",
                ".slick-dots",
                ".rslides_tabs",
                ".ls-bottom-slidebuttons",
                ".et-pb-controllers",
                ".flex-control-nav",
                ".flex-control-paging",
                ".jcarousel-pagination",
                "[data-jcarouselpagination]",
                ".uk-dotnav",
                ".carousel-indicators",
                ".flex-control-nav",
                ".flex-control-paging",
                ".flickity-page-dots",
                ".cycle-pager",
            ];
            for (const $carousel of helper.elements.filterHiddens(document.querySelectorAll("[data-aflw-carousel]"))) {
                if (helper.checkElementAudited($carousel, auditedVar))
                    continue;
                for (const $el of $carousel.querySelectorAll("[data-aflw-clickable]")) {
                    let process = $el.matches("[data-aflw-button]");
                    if (!process && $el.tagName === "A" && $el.href?.includes("#")) {
                        try {
                            const $destination = document.querySelector($el.getAttribute("href") || "");
                            if ($destination && $carousel.contains($destination))
                                process = true;
                        }
                        catch (err) { }
                    }
                    if (!process)
                        continue;
                    let isPagination = false;
                    for (const selector of selectors) {
                        if (!$el.closest(selector))
                            continue;
                        isPagination = true;
                        break;
                    }
                    if (!isPagination)
                        continue;
                    const report = helper.reportObject($el, 92, "pagination", "button");
                    if ($el.getAttribute("aria-label") || helper.elements.getText($el))
                        report.success = true;
                    helper.aggregateReports(reports, report);
                }
            }
            return reports;
        }
    }

    class CLICKABLES extends Criteria {
        static async audit(dynamic, $els) {
            return helper.runAuditMethods(new this(), dynamic, $els);
        }
        emptyLinks() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            for (const $el of helper.elements.filterHiddens(document.querySelectorAll("[data-aflw-role=link]"))) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                if ($el.closest("[data-aflw-link-preset]"))
                    continue;
                const report = helper.reportObject($el, 96);
                if ($el.getAttribute("aria-label") ||
                    helper.elements.getText($el) ||
                    $el.querySelector("[data-aflw-group-img]")?.getAttribute("alt") // @TODO need alt alternative to [role=img]
                ) {
                    report.success = true;
                }
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
        linkContext() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            for (const $el of helper.elements.filterHiddens(document.querySelectorAll("[data-aflw-link-preset]"))) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                const report = helper.reportObject($el, 88);
                let text = helper.elements.getText($el, "visible").toLowerCase();
                for (const $img of $el.querySelectorAll('img[alt]:not([role]):not([data-aflw-hidden="true"])')) {
                    text = `${text} ${$img.alt.toLowerCase()}`;
                    // @TODO why would the alt texts be "image"? (data-aflw-link-preset="image" in this case)
                }
                if ($el.ariaLabel) {
                    text = $el.ariaLabel;
                }
                if (!text) {
                    for (const $child of $el.querySelectorAll('[aria-label]:not([data-aflw-hidden="true"])')) {
                        if (!$child.ariaLabel)
                            continue;
                        text = text ? `${text} ${$child.ariaLabel}` : $child.ariaLabel;
                    }
                }
                const srOnlys = $el.querySelectorAll('[data-aflw-sr-only="true"]');
                srOnlys.forEach((srOnly) => {
                    const txt = helper.elements.getText(srOnly)?.toLowerCase();
                    if (srOnly && txt && !srOnly.parentElement?.closest('[data-aflw-hidden="true"]')) {
                        text = text ? `${text} ${txt}` : txt;
                    }
                });
                if (helper.strings.isNumber(text) ||
                    (text &&
                        !text.match(/[a-zA-Z]/) &&
                        text.match(/[0-9]/) &&
                        helper.strings.isNumber(text.replace(/[$% [\]().₪€]/g, "")))) {
                    text = "";
                }
                report.suggestionType = "link";
                const keyword = $el.getAttribute("data-aflw-link-preset");
                report.suggestionLabel = keyword || "";
                if (report.suggestionLabel) {
                    const translated = langService.getKeyword(text, keyword, "clickables" /* LangContext.clickables */);
                    if (translated)
                        report.success = true;
                    if (!translated && keyword === Keyword.Home) {
                        let textualContent = text;
                        const normalizeDomain = (domain) => {
                            return domain
                                .trim()
                                .toLowerCase()
                                .replace(/^(www|m|mobile)\./, "");
                        };
                        if (!/^https?:\/\//i.test(textualContent)) {
                            textualContent = `http://${textualContent}`;
                        }
                        try {
                            const urlByTextualContent = new URL(textualContent);
                            const urlByOrigin = new URL(window.location.origin);
                            const domainByTextualContent = normalizeDomain(urlByTextualContent.hostname);
                            const domainByOrigin = normalizeDomain(urlByOrigin.hostname);
                            if (domainByTextualContent === domainByOrigin && urlByTextualContent.pathname === "/") {
                                report.success = true;
                            }
                        }
                        catch (_) { }
                    }
                }
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
        buttonRoles() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            for (const $el of helper.elements.filterHiddens(document.querySelectorAll("[data-aflw-button]:not(label *)"))) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                if ($el.querySelector('[data-aflw-role="button"], [role="button"], [data-aflw-role="link"]') // child element which is link or button
                )
                    continue;
                const report = helper.reportObject($el, 91, "button");
                if (helper.elements.isButton($el) || $el.getAttribute("role") === "button") {
                    report.success = true;
                }
                if (!$el.getAttribute("aria-label") && !helper.elements.getText($el)) {
                    const type = $el.getAttribute("data-aflw-textual-context");
                    if (type) {
                        report.suggestionLabel = type;
                        report.suggestionType = "button";
                    }
                }
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
        buttonLabels() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            for (const $el of helper.elements.filterHiddens(document.querySelectorAll("[data-aflw-button]"))) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                const report = helper.reportObject($el, 84);
                if ($el.getAttribute("aria-label") || helper.elements.getText($el))
                    report.success = true;
                if (!report.success) {
                    report.suggestionType = "button";
                    report.suggestionLabel = $el.getAttribute("data-aflw-textual-context") || "";
                }
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
        newWindowLinks() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            for (const $el of helper.elements.filterHiddens(document.querySelectorAll("[data-aflw-role=link]"))) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                if ($el.getAttribute("target") !== "_blank")
                    continue;
                const report = helper.reportObject($el, 93);
                const ariaLabel = $el.getAttribute("aria-label")?.toLowerCase() || "";
                const text = helper.elements.getText($el).toLowerCase();
                // @TODO what about texts like "Go to website X" or "Open new page"?
                for (const k of ["window", "tab"]) {
                    if (!text.includes(k) && !ariaLabel.includes(k))
                        continue;
                    report.success = true;
                    break;
                }
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
        ambiguousLinks() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            const words = {
                en: ["more", "here", "show", "learn", "read", "view"],
                he: ["קראו", "קרא", "צפה", "כאן", "לקריאה", "עכשיו"],
                es: ["más", "aquí", "show", "aprender", "leer", "ahora"],
                it: ["di più", "qui", "vedere", "spettacolo", "imparare", "leggere", "adesso"],
                de: ["mehr", "hier", "sehen", "show", "lernen", "lesen", "jetzt"],
                nl: ["meer", "hier", "zien", "tonen", "leren", "lezen", "nu"],
                ru: ["более", "здесь", "видеть", "шоу", "учиться", "читать", "сейчас"],
                pt: ["mais", "aqui", "vejo", "mostrar", "aprender", "leitura", "agora"],
                ja: ["もっと", "ここに", "見る", "公演", "学ぶ", "読んだ", "今"],
                tw: ["更多的", "這裡", "看", "展示", "學", "讀", "現在"],
                za: ["更多的", "這裡", "看", "展示", "學", "讀", "現在"],
                ua: ["أكثر", "هنا", "نرى", "تبين", "يتعلم", "اقرأ", "الآن"],
                ar: ["أكثر", "هنا", "نرى", "تبين", "يتعلم", "اقرأ", "الآن"],
            };
            const nouns = {
                en: ["event", "dpa", "precaution"],
                de: ["ereignis", "vorsorge"],
            };
            for (const $el of helper.elements.filterHiddens(document.querySelectorAll("[data-aflw-role=link]"))) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                const text = helper.elements.getText($el, "visible").toLowerCase();
                if (!text)
                    continue;
                const textWords = text.split(" ").map((word) => helper.strings.removeWhiteSpaces(word));
                let matches = false;
                for (const k in words) {
                    for (const word of words[k]) {
                        if (!textWords.includes(word))
                            continue;
                        matches = true;
                        break;
                    }
                }
                let isIncludesNoun = false;
                for (const k in nouns) {
                    for (const noun of nouns[k]) {
                        if (text.includes(noun)) {
                            isIncludesNoun = true;
                            break;
                        }
                    }
                }
                if (!matches || text.split(" ").length > 3 || isIncludesNoun)
                    continue;
                const report = helper.reportObject($el, 89);
                const ariaLabel = $el.getAttribute("aria-label") || "";
                const srOnlyText = helper.elements.getText($el.querySelector("[data-aflw-sr-only]"));
                if (srOnlyText.length > text.length || ariaLabel.length > text.length)
                    report.success = true;
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
    }

    class CONTEXT extends Criteria {
        static async audit(dynamic, $els) {
            return helper.runAuditMethods(new this(), dynamic, $els);
        }
        salePrices() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            for (const $el of helper.elements.filterHiddens(document.querySelectorAll("[data-aflw-role=generic], [data-aflw-group-formatting], [data-aflw-role=paragraph]"))) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                const text = helper.elements.getText($el);
                if (!text ||
                    !helper.strings.isNumber(text.replace(/\W/g, "")) ||
                    (!$el.matches("[data-aflw-role=deletion], strike") &&
                        !helper.elements.getStyle($el, "text-decoration").includes("line-through"))) {
                    continue;
                }
                const report = helper.reportObject($el, 92, "salePrice");
                if ($el.querySelector("[data-aflw-sr-only]"))
                    report.success = true;
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
        userRating() {
            const reports = {};
            const selector = 'img[src*="star" i], [class*="star" i], [class*="rating" i], [class*="rate" i], [data-aflw-possible-star="true" i]';
            const auditedVar = helper.generateAflwAuditedVar();
            let emptyStarsClasses;
            let fullStarsClasses;
            for (const $el of document.querySelectorAll('[itemprop="ratingValue"]')) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                const report = helper.reportObject($el, 85);
                const $srOnly = $el.querySelector("[data-aflw-sr-only]");
                if ($srOnly && helper.elements.getText($srOnly).match(/\d/))
                    report.success = true;
                helper.aggregateReports(reports, report);
            }
            for (const $el of document.querySelectorAll(selector)) {
                if (helper.checkElementAudited($el, "aflwPossibleStarBound"))
                    continue;
                if ($el.parentElement && $el.parentElement.querySelectorAll(selector).length === 1) {
                    const $stars = $el.parentElement.querySelectorAll("svg, [data-aflw-group-img], i");
                    if ($stars.length !== 5) {
                        for (const $star of $stars)
                            $star.classList.add("aflw-star");
                    }
                    else {
                        $el.parentElement.setAttribute("data-aflw-possible-star", "true");
                    }
                }
            }
            for (const $el of document.querySelectorAll(selector)) {
                if (!$el.parentElement || helper.checkElementAudited($el.parentElement, "aflwStarsProcessed"))
                    continue;
                if ($el.getAttribute("class")?.toLowerCase().includes("start"))
                    continue;
                let hasDesc = $el.parentElement.getAttribute("aria-label");
                const $all = [$el].concat(helper.elements.getNext($el, selector, true));
                let prevClasses = null;
                let verdict = 5;
                if ($all.length !== 5)
                    continue;
                let i = 0;
                for (const $innerEl of $all) {
                    const classes = $innerEl.getAttribute("class");
                    if (prevClasses && classes !== prevClasses) {
                        verdict = i;
                        emptyStarsClasses = classes;
                        fullStarsClasses = prevClasses;
                        break;
                    }
                    prevClasses = classes;
                    i++;
                }
                for (const $innerEl of $el.parentElement.querySelectorAll(allSelector)) {
                    if ($innerEl === $el || $all.includes($innerEl))
                        continue;
                    if ($innerEl.closest("[data-aflw-sr-only]"))
                        hasDesc = true;
                }
                const report = helper.reportObject($el, 87, `${verdict}/5`, "rating");
                if (hasDesc) {
                    report.success = true;
                }
                else {
                    if (verdict === 5) {
                        const $nextStar = helper.elements.getNext($el, '[class*="star"], [class*="rating"]')[0];
                        if (!$nextStar)
                            continue;
                        const nextStarClasses = $nextStar.getAttribute("class");
                        // @TODO dead code - emptyStarsClasses & fullStarsClasses will always be undefined if verdict === 5
                        /* istanbul ignore next */
                        if (nextStarClasses === emptyStarsClasses) {
                            report.suggestionLabel = "0/5";
                        }
                        else if (nextStarClasses === fullStarsClasses) {
                            report.suggestionLabel = "5/5";
                        }
                    }
                }
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
        mainLandmark() {
            if (this.dynamic)
                return {};
            const $el = document.querySelector("[data-aflw-main]");
            const report = helper.reportObject($el, 84, "main", "landmark");
            if ($el) {
                if ($el.matches('main, [role="main"]'))
                    report.success = true;
            }
            else {
                report.HTML = "<main></main>";
                report.selector = "body > main";
            }
            return { [report.selector]: report };
        }
        articleSetup() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            for (const $el of helper.elements.filterHiddens(document.querySelectorAll("[data-aflw-role=article]"))) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                const report = helper.reportObject($el, 90);
                if (helper.elements.getText($el, "any").length >= 500 ||
                    $el.getAttribute("role") === "presentation") {
                    report.success = true;
                }
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
        iframeLabeling() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            for (const $el of helper.elements.filterHiddens(document.querySelectorAll("iframe"))) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                const report = helper.reportObject($el, 92);
                if ($el.getAttribute("aria-label"))
                    report.success = true;
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
        footerLandmark() {
            if (this.dynamic)
                return {};
            const $el = document.querySelector("[data-aflw-footer]");
            const report = helper.reportObject($el, 84, "footer", "landmark");
            if ($el) {
                if ($el.matches('footer, [role="contentinfo"]'))
                    report.success = true;
            }
            else {
                report.HTML = "<footer></footer>";
                report.selector = "body > footer";
            }
            return { [report.selector]: report };
        }
        incorrectMainLandmark() {
            if (this.dynamic)
                return {};
            const $el = document.querySelector("main");
            const report = helper.reportObject($el, 84);
            if ($el) {
                if ($el.matches('[data-aflw-main], [role="presentation"], [role="none"]'))
                    report.success = true;
            }
            else {
                report.HTML = "<main></main>";
                report.selector = "body > main";
            }
            return { [report.selector]: report };
        }
        multiMainLandmarks() {
            if (this.dynamic)
                return {};
            const $els = helper.elements.filterHiddens(document.querySelectorAll("[data-aflw-role=main]"), "sr-or-visible");
            const reports = {};
            if ($els.length < 2)
                return reports;
            let first = true;
            for (const $el of $els) {
                if (first) {
                    first = false;
                    continue;
                }
                const report = helper.reportObject($el, 84);
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
        popupTagging() {
            const reports = {};
            for (const $el of helper.elements.filterHiddens(document.querySelectorAll("[data-aflw-popup]"))) {
                const report = helper.reportObject($el, 92);
                if ($el.matches('[aria-modal="true"][role="dialog"], dialog[open]'))
                    report.success = true;
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
        // @TODO tabs implementation
        tabPanelTagging() { }
        tabsTagging() { }
        activeTab() {
            // todo: just find the tabs and see if ANY is set as active, doesn't matter which
        }
    }

    class DOCUMENT extends Criteria {
        static async audit(dynamic, $els) {
            return helper.runAuditMethods(new this(), dynamic, $els);
        }
        pageTitle() {
            if (this.dynamic)
                return {};
            const $title = document.head.querySelector("title");
            const report = helper.reportObject($title, 100);
            report.selector = "head > title";
            report.HTML = $title ? report.HTML : "<title></title>";
            if (!$title)
                report.isDummySelector = true;
            if ($title && helper.elements.getText($title).length >= 2)
                report.success = true;
            return { [report.selector]: report };
        }
        languageReport() {
            if (this.dynamic)
                return {};
            const lang = document.documentElement.getAttribute("lang");
            const report = helper.reportObject(document.documentElement, 100);
            if (lang && lang.length >= 2 && lang.length < 5)
                report.success = true;
            return { [report.selector]: report };
        }
        viewportScalability() {
            if (this.dynamic)
                return {};
            const $viewport = document.querySelector('meta[name="viewport"]');
            const report = helper.reportObject($viewport, 100);
            report.success = true;
            report.selector = 'head > meta[name="viewport"]';
            report.HTML = $viewport ? report.HTML : '<meta name="viewport">';
            for (const str of $viewport?.content.toLowerCase().split(",") || []) {
                const parts = str.replace(/ /g, "").trim().split("=");
                if (parts[0] === "user-scalable" && parts[1]?.includes("no"))
                    report.success = false;
                if (parts[0] === "maximum-scale" && parts[1] && Number(parts[1]) < 2)
                    report.success = false;
                if (!report.success)
                    break;
            }
            return { [report.selector]: report };
        }
    }

    class ERRORS extends Criteria {
        static async audit(dynamic, $els) {
            return helper.runAuditMethods(new this(), dynamic, $els);
        }
        titleMisuse() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            for (const $el of helper.elements.filterHiddens(document.querySelectorAll("[title]"))) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                if (!$el.getAttribute("title"))
                    continue;
                const report = helper.reportObject($el, 90);
                if ($el.getAttribute("aria-label") ||
                    $el.getAttribute("aria-labelledby") ||
                    $el.getAttribute("alt") ||
                    helper.elements.getText($el, "sr", true)) {
                    report.success = true;
                }
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
        ariaLabelMisuse() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            for (const $el of helper.elements.filterHiddens(document.querySelectorAll("[aria-label]"))) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                const report = helper.reportObject($el, 91);
                report.success = true;
                if (helper.elements.getText($el) &&
                    !$el.getAttribute("role") &&
                    $el.matches("[data-aflw-role=generic], [data-aflw-group-formatting], [data-aflw-group-section]")) {
                    report.success = false;
                }
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
        brokenAriaLabels() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            const sanitize = (str) => str.replace(/\s+/g, " ").trim().replace(/[^\w]/g, "").toLowerCase();
            const attributeSelectors = "[aria-label], [aria-labelledby]";
            const els = helper.elements.filterHiddens(document.querySelectorAll(attributeSelectors));
            for (const $el of els) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                const ariaLabel = sanitize($el.getAttribute("aria-label") || "");
                let ariaLabelledBy = $el.getAttribute("aria-labelledby") || "";
                if (ariaLabelledBy) {
                    ariaLabelledBy = sanitize(ariaLabelledBy
                        .replace(/\s+/g, " ")
                        .trim()
                        .split(" ")
                        .map((id) => {
                        try {
                            return document.getElementById(id);
                        }
                        catch (err) {
                            return null;
                        }
                    })
                        .filter((el) => el)
                        .map((el) => el.innerText)
                        .join(" "));
                }
                const text = sanitize(helper.elements.getText($el, "visible"));
                if (!text || (!ariaLabel && !ariaLabelledBy))
                    continue;
                const report = helper.reportObject($el, 87);
                if ($el.matches("[data-aflw-group-landmark]") ||
                    (ariaLabelledBy ? ariaLabelledBy.includes(text) : false) ||
                    ariaLabel.includes(text)) {
                    report.success = true;
                }
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
        fakeHiddenContent() {
            if (this.dynamic)
                return {};
            const reports = {};
            for (const $el of document.querySelectorAll('[data-aflw-hidden="true"]')) {
                if ($el.tagName === "svg")
                    continue;
                if (!helper.elements.getText($el) || $el.closest('[data-aflw-sr-only="true"]'))
                    continue;
                const report = helper.reportObject($el, 84);
                if (($el.offsetWidth <= 1 && $el.offsetHeight <= 1) ||
                    $el.matches('[data-aflw-sr-hidden="true"]'))
                    report.success = true;
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
        brokenAriaReference() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            for (const attr of ["aria-describedby", "aria-labelledby"]) {
                for (const $el of helper.elements.filterHiddens(document.querySelectorAll(`[${attr}]`))) {
                    if (helper.checkElementAudited($el, auditedVar))
                        continue;
                    const id = $el.getAttribute(attr);
                    if (!id)
                        continue;
                    const report = helper.reportObject($el, 87);
                    try {
                        const $destination = document.querySelector(`#${id}`);
                        if ($destination)
                            report.success = true;
                    }
                    catch (err) { }
                    helper.aggregateReports(reports, report);
                }
            }
            return reports;
        }
        roleApplications() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            for (const $el of helper.elements.filterHiddens(document.querySelectorAll('[data-aflw-role="application"]'))) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                helper.aggregateReports(reports, helper.reportObject($el, 100));
            }
            return reports;
        }
        loadAutofocus() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            for (const $el of helper.elements.filterHiddens(document.querySelectorAll('[data-aflw-role="autofocus"]'))) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                helper.aggregateReports(reports, helper.reportObject($el, 100));
            }
            return reports;
        }
        brokenList() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            for (const $el of helper.elements.filterHiddens(document.querySelectorAll("[data-aflw-role=listitem]"))) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                const report = helper.reportObject($el, 100);
                if ($el.closest("[data-aflw-role=list]"))
                    report.success = true;
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
        emptyList() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            for (const $el of helper.elements.filterHiddens(document.querySelectorAll("[data-aflw-role=list]"))) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                const report = helper.reportObject($el, 100);
                const liCount = $el.querySelectorAll("[data-aflw-role=listitem]").length;
                if (liCount > 1)
                    report.success = true;
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
        marquee() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            for (const $el of helper.elements.filterHiddens(document.querySelectorAll("marquee"))) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                helper.aggregateReports(reports, helper.reportObject($el, 100));
            }
            return reports;
        }
        hiddenVisibleContent() {
            const reports = {};
            for (const $el of helper.elements.filterHiddens(document.querySelectorAll("[aria-hidden='true']"))) {
                const report = helper.reportObject($el, 86);
                const text = helper.elements.getText($el, "visible", true, ["svg"]).replace(/[^\w]/g, "");
                const interactiveElements = helper.elements.filterHiddens($el.querySelectorAll(tabbableSelector));
                if (!text && !interactiveElements.length) {
                    report.success = true;
                }
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
    }

    class FORMS extends Criteria {
        static async audit(dynamic, $els) {
            return helper.runAuditMethods(new this(), dynamic, $els);
        }
        captcha() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            for (const $el of helper.elements.filterHiddens(document.querySelectorAll('[data-aflw-textual-type="captcha"]'))) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                const report = helper.reportObject($el, 100, "captcha", "field");
                if ($el.closest(".g-recaptcha-response "))
                    report.success = true;
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
        fieldLabel() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            for (const $el of helper.elements.filterHiddens(document.querySelectorAll("[data-aflw-group-input]"))) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                if ($el.closest('[data-aflw-textual-type="captcha"]'))
                    continue;
                const type = $el.getAttribute("data-aflw-textual-type");
                const report = helper.reportObject($el, 91);
                if (type) {
                    report.suggestionLabel = type;
                    report.suggestionType = "field";
                }
                try {
                    if ($el.getAttribute("aria-label") ||
                        ($el.id &&
                            document.querySelector(`label[for="${$el.id.replace(/([^\w-\s])/g, "\\$1")}"]`))) {
                        report.success = true;
                    }
                }
                catch (err) { }
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
        fieldRequired() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            for (const $el of helper.elements.filterHiddens(document.querySelectorAll("[data-aflw-group-input]"))) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                const report = helper.reportObject($el, 100, "required", "field");
                const $label = helper.elements.getFieldLabel($el);
                let required = false;
                if ($el.required ||
                    $el.getAttribute("data-aflw-textual-type") === "captcha" ||
                    $el.getAttribute("aria-required") === "true" ||
                    $el.hasAttribute("required")) {
                    required = true;
                }
                if (!required) {
                    let fullHTML = "";
                    let parentHTML = "";
                    let fieldHTML = helper.elements.getHTML($el).toLowerCase();
                    const labelHTML = $label ? $label.outerHTML.toLowerCase() : "";
                    if ($el.tagName === "SELECT") {
                        const $options = $el.querySelectorAll("[data-aflw-role=option]");
                        if ($options.length > 0)
                            fieldHTML = `${fieldHTML}${helper.elements.getText($options[0])}`;
                    }
                    if ($el.closest("[data-aflw-role=form]")) {
                        let $current;
                        let $parent = $el.parentElement;
                        while ($parent) {
                            if ($parent.querySelectorAll("[data-aflw-group-input]").length > 1 ||
                                $parent.matches("[data-aflw-role=form]"))
                                break;
                            $current = $parent;
                            $parent = $parent.parentElement;
                        }
                        if ($current)
                            parentHTML = $current.outerHTML;
                    }
                    fullHTML = `${fieldHTML}${labelHTML}${parentHTML}`.toLowerCase();
                    if (fullHTML.includes("*") ||
                        (/\b(req|required?)\b/i.test(fullHTML) && $el.getAttribute("aria-required") !== "false"))
                        required = true;
                }
                if (!required)
                    continue;
                if ($el.hasAttribute("required") || $el.getAttribute("aria-required") === "true")
                    report.success = true;
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
        missingFormButton() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            for (const $el of helper.elements.filterHiddens(document.querySelectorAll("[data-aflw-role=form]"))) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                const report = helper.reportObject($el, 100);
                if ($el.querySelector('[data-aflw-button][type="submit"]'))
                    report.success = true;
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
        customSelectField() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            // @TODO select element should be visually hidden for a custom select implementation
            for (const $el of helper.elements.filterHiddens(document.querySelectorAll("select"))) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                const selectors = [
                    ".chosen-container",
                    ".chzn-container",
                    ".select2-container",
                    ".selectize-control",
                    ".jcf-select",
                    ".jcf-list-box",
                ];
                let $customSelect;
                if (this._isCustomSelect($el.nextElementSibling, $el, selectors)) {
                    $customSelect = $el.nextElementSibling;
                }
                else if (this._isCustomSelect($el.previousElementSibling, $el, selectors)) {
                    $customSelect = $el.previousElementSibling;
                }
                if (!$customSelect || $customSelect.closest('[data-aflw-hidden="true"]'))
                    continue;
                const report = helper.reportObject($el, 100, "customSelect", "field");
                // @TODO this doesn't make sense, it should be the opposite - only visually hidden
                // maybe meant to check $customSelect ?
                if ($customSelect.closest("[data-aflw-sr-hidden=true]") &&
                    !$el.closest('[data-aflw-hidden="true"]'))
                    report.success = true;
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
        customControlField() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            // @TODO element should be visually hidden for a custom control implementation
            for (const $el of helper.elements.filterHiddens(document.querySelectorAll('input[type="radio"], input[type="checkbox"], input[type="file"]'))) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                if ($el.parentElement?.closest('[data-aflw-hidden="true"]') || !this._isCustomControl($el))
                    continue;
                const offsets = helper.elements.getOffsets($el);
                const report = helper.reportObject($el, 89, "customControl", "field");
                if ($el.offsetWidth > 0 && document.elementFromPoint(offsets.left, offsets.top) === $el) {
                    report.success = true;
                }
                try {
                    if (!report.success && $el.id) {
                        let $label = $el.closest(`label[for="${$el.id.replace(/([^\w-\s])/g, "\\$1")}"][tabindex="0"]`);
                        if (!$label)
                            $label = document.querySelector(`label[for="${$el.id.replace(/([^\w-\s])/g, "\\$1")}"][tabindex="0"]`);
                        if ($label)
                            report.success = true;
                    }
                }
                catch (err) { }
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
        searchFormTagging() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            for (const $el of helper.elements.filterHiddens(document.querySelectorAll("[data-aflw-role=form]"))) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                if ($el.querySelector("[data-aflw-role=combobox], [data-aflw-role=listbox], [data-aflw-textarea], [data-aflw-role=checkbox], [data-aflw-role=radio]"))
                    continue;
                const $fields = [];
                for (const $input of $el.querySelectorAll("[data-aflw-group-input]")) {
                    if ($input.matches("[data-aflw-role=checkbox], [data-aflw-role=radio]"))
                        continue;
                    $fields.push($input);
                }
                if ($fields.length > 1)
                    continue;
                let isSearch = helper.elements.getHTML($el).toLowerCase().includes("search");
                if (!isSearch) {
                    for (const $field of $fields) {
                        if ($field.getAttribute("data-aflw-textual-type") !== "search")
                            continue;
                        isSearch = true;
                        break;
                    }
                }
                if (!isSearch)
                    continue;
                const report = helper.reportObject($el, 89, "searchForm");
                if ($el.closest('[role="search"]'))
                    report.success = true;
                helper.aggregateReports(reports, report);
            }
            for (const $el of helper.elements.filterHiddens(document.querySelectorAll('[data-aflw-textual-type="search"]'))) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                // @TODO Dead code - when [data-aflw-textual-type] is set it necessarily means it's a child of form element
                if ($el.closest("[data-aflw-role=form]"))
                    continue;
                /* istanbul ignore next */
                {
                    const text = helper.elements.getTextNodesText($el.parentElement);
                    const $images = $el.parentElement?.querySelectorAll("[data-aflw-group-img]");
                    let $parent = $el.parentElement;
                    let $orgParent = $el.parentElement;
                    let matched = false;
                    while (!matched) {
                        if ($parent?.tagName === "BODY")
                            break;
                        if (text === helper.elements.getText($parent) &&
                            $images?.length === $parent?.querySelectorAll("[data-aflw-group-img]").length) {
                            $orgParent = $parent;
                            $parent = $parent?.parentElement || null;
                        }
                        else {
                            matched = true;
                            break;
                        }
                    }
                    if ($orgParent?.querySelector("[data-aflw-role=combobox], [data-aflw-role=listbox], [data-aflw-textarea], [data-aflw-role=checkbox], [data-aflw-role=radio]"))
                        continue;
                    const $fields = [];
                    for (const $input of $el.querySelectorAll("[data-aflw-group-input]")) {
                        if ($input.matches("[data-aflw-role=checkbox], [data-aflw-role=radio]"))
                            continue;
                        $fields.push($input);
                    }
                    if ($fields.length > 1)
                        continue;
                    const report = helper.reportObject($orgParent, 89, "search", "form");
                    if ($orgParent?.closest('[role="search"]'))
                        report.success = true;
                    helper.aggregateReports(reports, report);
                }
            }
            return reports;
        }
        /* SOON */
        formSubmissionStatus() {
            // todo: NEW role=alert or one that was hidden and now shown after a form submission
        }
        /* SOON */
        fieldValidations() { }
        /* SOON */
        fieldValidationFocus() { }
        _isCustomSelect($el, $select, selectors) {
            if (!$el ||
                !$el.matches("[data-aflw-role=generic]") ||
                (!$select.closest('[data-aflw-hidden="true"]') &&
                    !$select.matches(".select2-hidden-accessible"))) {
                return false;
            }
            let match = false;
            for (const selector of selectors) {
                if (!$el.matches(selector))
                    continue;
                match = true;
                break;
            }
            return match;
        }
        _isCustomControl($field) {
            if (!["checkbox", "radio", "file"].includes($field.type) ||
                (!$field.closest('[data-aflw-hidden="true"]') &&
                    helper.elements.getStyle($field, "opacity") !== "0")) {
                return false;
            }
            let $el;
            if ($field.previousElementSibling &&
                ["SPAN", "LABEL"].includes($field.previousElementSibling.tagName)) {
                $el = $field.previousElementSibling;
            }
            if ($field.nextElementSibling &&
                ["SPAN", "LABEL"].includes($field.nextElementSibling.tagName)) {
                $el = $field.nextElementSibling;
            }
            if ($el)
                return true;
            if ($field.type === "file" &&
                $field.offsetWidth > 0 &&
                $field.offsetHeight > 0 &&
                helper.elements.getStyle($field, "opacity") === "0") {
                return true;
            }
            return false;
        }
    }

    class GRAPHICS extends Criteria {
        static async audit(dynamic, $els) {
            return helper.runAuditMethods(new this(), dynamic, $els);
        }
        altText() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            for (const $el of helper.elements.filterHiddens(document.body.querySelectorAll("img"))) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                if ($el.closest("[data-acsb]"))
                    continue;
                const report = helper.reportObject($el, 100);
                report.src = $el.src.includes("data:") ? $el.src.substr(0, 20) : helper.uris.format($el.src);
                if ($el.getAttribute("role") === "presentation" || !this._isAltOverridable($el))
                    report.success = true;
                helper.aggregateReports(reports, report, "src");
            }
            return reports;
        }
        decorativeContent() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            for (const $el of helper.elements.filterHiddens(document.querySelectorAll("i, span, svg"))) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                if (helper.elements.getText($el, "visible").length > 0 ||
                    ($el.offsetWidth > 60 && $el.offsetHeight > 60) ||
                    ($el.tagName === "SPAN" && $el.querySelectorAll(allSelector).length > 1) ||
                    $el.querySelector("[data-aflw-role=link], [data-aflw-group-input], [data-aflw-group-img]") ||
                    $el.closest('[data-acsb], [data-aflw-sr-only], [data-aflw-hidden="true"], [data-aflw-clickable]')) {
                    continue;
                }
                const report = helper.reportObject($el, 96);
                report.suggestionLabel = "decorativeContent";
                if ($el.getAttribute("role") === "presentation" ||
                    $el.getAttribute("aria-label") ||
                    $el.querySelector("[data-aflw-sr-only]")) {
                    report.success = true;
                }
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
        figureSetup() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            for (const $el of helper.elements.filterHiddens(document.querySelectorAll("[data-aflw-role=figure]"))) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                if ($el.closest("[data-acsb]"))
                    continue;
                const $caption = $el.querySelector("figcaption");
                const report = helper.reportObject($el, 100);
                if (($caption &&
                    helper.elements.getText($caption) &&
                    $el.querySelector("[data-aflw-group-img]")) ||
                    $el.getAttribute("role") == "presentation")
                    report.success = true;
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
        backgroundImages() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            for (const $el of document.querySelectorAll("div, [data-aflw-role=listitem], a, [data-aflw-group-section], span, [data-aflw-role=complementary]")) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                if ($el.closest("[data-acsb]"))
                    continue;
                const bgImage = helper.elements.getStyle($el, "background-image");
                if (!bgImage ||
                    bgImage === "none" ||
                    bgImage.length < 5 ||
                    $el.offsetHeight < 50 ||
                    $el.offsetWidth < 50 ||
                    bgImage.includes("-gradient")) {
                    continue;
                }
                const report = helper.reportObject($el, 91);
                if (($el.tagName !== "A" && $el.getAttribute("role") === "presentation") ||
                    ($el.children[0]?.getAttribute("data-aflw-sr-only") &&
                        $el.children[0]?.getAttribute("role") === "img")) {
                    report.success = true;
                }
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
        svgContent() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            for (const $el of document.querySelectorAll("svg")) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                if ($el.parentElement?.closest("[data-aflw-hidden]"))
                    continue;
                const report = helper.reportObject($el, 84);
                const svgDescEl = $el.querySelector("title");
                const description = helper.elements.getText(svgDescEl);
                if ((!!svgDescEl && description.length) || $el.closest('[data-aflw-sr-hidden="true"]'))
                    report.success = true;
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
        _isAltOverridable($img) {
            if (!$img.alt)
                return true;
            const alt = $img.alt.toLowerCase().trim();
            const sentences = alt.split(" ");
            let overrideable = false;
            if (sentences.length === 1 && sentences[0].length > 20)
                return true;
            if (sentences.length <= 3) {
                for (const sentence of sentences) {
                    if (helper.strings.isNumber(sentence))
                        continue;
                    if (sentence.length > 20 ||
                        ["img", "image", "picture", "pic", "banner", "alt"].includes(sentence)) {
                        overrideable = true;
                        break;
                    }
                    const numbers = sentence.replace(/[^0-9]/g, "");
                    if (numbers.length > sentence.replace(numbers, "").length) {
                        overrideable = true;
                        break;
                    }
                }
            }
            if (overrideable)
                return true;
            if ($img.src.length >= 5 &&
                alt.toLowerCase().includes(`.${helper.uris.getExtension($img.src)}`))
                return true;
            for (const sentence of sentences) {
                const x = sentence.split("x");
                if (x.length === 2 && helper.strings.isNumber(x[0]) && helper.strings.isNumber(x[1])) {
                    overrideable = true;
                    break;
                }
            }
            return overrideable;
        }
    }

    class HEADINGS extends Criteria {
        static async audit(dynamic, $els) {
            return helper.runAuditMethods(new this(), dynamic, $els);
        }
        mainHeading() {
            if (this.dynamic)
                return {};
            const report = helper.reportObject(document.createElement("h1"), 100);
            const $visibleH1 = this._getAllVisibleH1();
            if ($visibleH1.length > 0 &&
                ($visibleH1[0].getAttribute("aria-label") || helper.elements.getText($visibleH1[0]))) {
                // Assumption: the first visible H1 is the main heading
                report.success = true;
            }
            return { [report.selector]: report };
        }
        multipleMainHeadings() {
            if (this.dynamic)
                return {};
            const reports = {};
            const $visibleH1 = this._getAllVisibleH1();
            if ($visibleH1.length > 1) {
                const report = helper.reportObject($visibleH1[0], 100);
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
        longHeadings() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            for (const $el of helper.elements.filterHiddens(document.querySelectorAll("[data-aflw-role=heading]"))) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                const role = $el.getAttribute("role");
                if (role && role !== "heading")
                    continue;
                const report = helper.reportObject($el, 100);
                if (helper.elements.getText($el, "any").length <= 160)
                    report.success = true;
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
        emptyHeadings() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            for (const $el of helper.elements.filterHiddens(document.querySelectorAll("[data-aflw-role=heading]"))) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                const report = helper.reportObject($el, 100);
                if ($el.getAttribute("aria-label") || helper.elements.getText($el))
                    report.success = true;
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
        untaggedHeadings() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            for (const $el of helper.elements.filterHiddens(document.querySelectorAll("[data-aflw-untagged-heading]"))) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                const report = helper.reportObject($el, 87);
                report.suggestionLabel = "heading";
                if ($el.getAttribute("role") === "heading" && $el.getAttribute("aria-level"))
                    report.success = true;
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
        _getAllVisibleH1() {
            const $visibleH1 = [];
            for (const $el of document.querySelectorAll('h1, [role="heading"][aria-level="1"]')) {
                if (!$el.closest('[data-aflw-hidden="true"]'))
                    $visibleH1.push($el);
            }
            return $visibleH1;
        }
    }

    class KEYBOARD extends Criteria {
        static async audit(dynamic, $els, data) {
            return helper.runAuditMethods(new this(), dynamic, $els, data);
        }
        enterClickability() { }
        noticeableFocus() {
            if (this.dynamic)
                return {};
            const $originalFocus = document.activeElement;
            let $target = document.activeElement?.tagName === "BODY" ? null : document.activeElement;
            if (!$target ||
                !$target.matches('a[href], button, [tabindex="0"]') ||
                $target.closest('[data-aflw-hidden="true"]')) {
                for (const $el of helper.elements.filterHiddens(document.querySelectorAll('a[href], button, [tabindex="0"]'))) {
                    if ($el.closest("[data-aflw-skip-link]"))
                        continue;
                    $target = $el;
                    break;
                }
            }
            if (!$target)
                return {};
            $target.focus();
            const report = helper.reportObject($target, 100);
            report.selector = "a[href], button, [tabindex]";
            if (!helper.elements.getStyle($target, "outline").includes("none"))
                report.success = true;
            if ($originalFocus) {
                if ($originalFocus.tagName === "BODY") {
                    $originalFocus.setAttribute("tabIndex", "-1");
                    $originalFocus.focus();
                    $originalFocus.removeAttribute("tabIndex");
                }
                else
                    $originalFocus.focus();
            }
            return { [report.selector]: report };
        }
        keyboardHoverables() { }
        scrollFocus() { }
        popupFocus() {
            const reports = {};
            for (const $el of helper.elements.filterHiddens(document.querySelectorAll("[data-aflw-popup]"))) {
                const report = helper.reportObject($el, 92);
                if (document.activeElement &&
                    ($el.contains(document.activeElement) || $el === document.activeElement)) {
                    report.success = true;
                }
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
        skipLinks() {
            if (this.dynamic)
                return {};
            let connected = false;
            const $skipLink = document.querySelector("[data-aflw-skip-link]");
            if ($skipLink) {
                try {
                    const href = $skipLink.getAttribute("href");
                    connected = href ? !!document.querySelector(href) : false;
                }
                catch { }
            }
            const report = helper.reportObject($skipLink, 92);
            report.suggestionLabel = "skipLink";
            if ($skipLink?.hasAttribute("data-aflw-navigable") && connected)
                report.success = true;
            if (!$skipLink) {
                report.selector = "body > a.skip-link";
                report.HTML = '<a href="#content">Skip to content</a>';
            }
            return { [report.selector]: report };
        }
        inlinePopupFocus() { }
        brokenTabindex() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            for (const $el of helper.elements.filterHiddens(document.querySelectorAll("[tabindex]"))) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                const value = $el.getAttribute("tabindex");
                if (!value)
                    continue;
                const report = helper.reportObject($el, 90);
                if (+value <= 0)
                    report.success = true;
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
        keyboardNavigation() {
            if (this.dynamic)
                return {};
            const reports = {};
            for (const $el of helper.elements.filterHiddens(document.querySelectorAll("[data-aflw-navigable]"))) {
                const tabindex = $el.getAttribute("tabindex");
                const report = helper.reportObject($el, 94);
                report.suggestionLabel = "navigableElement";
                const isTabbable = $el.matches(tabbableSelector) || $el.querySelector(tabbableSelector) || tabindex === "0";
                //if parent is a label, check if it has a radio input
                const parentLabel = $el.closest("label");
                if ((parentLabel && parentLabel.querySelector("input[data-aflw-role=radio]")) || isTabbable) {
                    report.success = true;
                }
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
        noninteractiveTabindex() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            for (const $el of helper.elements.filterHiddens(document.querySelectorAll('[tabindex="0"]'))) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                const report = helper.reportObject($el, 92);
                if ($el.matches("[data-aflw-navigable]"))
                    report.success = true;
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
        fakeHiddenInteractive() {
            if (this.dynamic)
                return {};
            const reports = {};
            // @TODO dead code, [data-aflw-navigable] by definition apply only to visible elements
            for (const $el of helper.elements.filterOutVisible(document.querySelectorAll("[data-aflw-navigable]"))) {
                const report = helper.reportObject($el, 87);
                const tabindex = $el.getAttribute("tabindex") || -1;
                if (+tabindex < 0 ||
                    ($el.offsetWidth < 1 && $el.offsetHeight < 1) ||
                    (!$el.matches(tabbableSelector) && !tabindex)) {
                    report.success = true;
                }
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
    }

    class NAVIGATION extends Criteria {
        static async audit(dynamic, $els) {
            return helper.runAuditMethods(new this(), dynamic, $els);
        }
        breadcrumbs() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            for (const $el of helper.elements.filterHiddens(document.querySelectorAll('[data-aflw-nav-type="breadcrumbs"]'))) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                const report = helper.reportObject($el, 87, "breadcrumbs", "navigation");
                if ($el.matches('nav, [role="navigation"]') && $el.getAttribute("aria-label"))
                    report.success = true;
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
        submenuState() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            for (const $el of helper.elements.filterHiddens(document.querySelectorAll("[data-aflw-nav-dd-trigger]"))) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                const report = helper.reportObject($el, 90);
                if ($el.getAttribute("aria-expanded") === "false")
                    report.success = true;
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
        brokenNavItems() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            for (const $el of helper.elements.filterHiddens(document.querySelectorAll("[data-aflw-role=menuitem]"))) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                helper.aggregateReports(reports, helper.reportObject($el, 100));
            }
            return reports;
        }
        submenuTagging() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            for (const $el of helper.elements.filterHiddens(document.querySelectorAll("[data-aflw-nav-dd]"))) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                const report = helper.reportObject($el, 90);
                report.suggestionLabel = "submenu";
                if ($el.getAttribute("role") === "region" && $el.getAttribute("aria-label"))
                    report.success = true;
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
        // @TODO is this related only to fakeNav? this currently can never fail
        missingNavItems() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            for (const $el of helper.elements.filterHiddens(document.querySelectorAll("[data-aflw-nav-li]"))) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                const report = helper.reportObject($el, 100);
                if ($el.querySelector("[data-aflw-nav-a]"))
                    report.success = true;
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
        nestedNavigation() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            for (const $el of helper.elements.filterHiddens(document.querySelectorAll("[data-aflw-role=navigation] [data-aflw-role=navigation]"))) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                helper.checkElementAudited($el, "aflwNestedNavigationAudited");
                helper.aggregateReports(reports, helper.reportObject($el, 100));
            }
            return reports;
        }
        brokenNavTagging() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            for (const $el of helper.elements.filterHiddens(document.querySelectorAll("[data-aflw-role=menu], [data-aflw-role=menubar]"))) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                helper.aggregateReports(reports, helper.reportObject($el, 100));
            }
            return reports;
        }
        navigationTagging() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            for (const $el of helper.elements.filterHiddens(document.querySelectorAll("[data-aflw-nav]"))) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                if ($el.closest('[data-aflw-nav-type="breadcrumbs"]'))
                    continue;
                const report = helper.reportObject($el, 91);
                const type = $el.getAttribute("data-aflw-nav-type");
                const nav = $el.closest('nav, [role="navigation"]');
                if (nav && ($el.getAttribute("aria-label") || nav.getAttribute("aria-label")))
                    report.success = true;
                if (type) {
                    report.suggestionLabel = type;
                    report.suggestionType = "navigation";
                }
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
        misusedNavTagging() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            for (const $el of helper.elements.filterHiddens(document.querySelectorAll("[data-aflw-role=navigation]"))) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                const report = helper.reportObject($el, 84);
                if ($el.closest("[data-aflw-nav]") || $el.querySelector("[data-aflw-nav]"))
                    report.success = true;
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
        brokenSubmenuIndication() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            for (const $el of helper.elements.filterHiddens(document.querySelectorAll(
            // @TODO [data-aflw-nav-ul] is set on fakeNav flow and currently is dead code
            "[data-aflw-nav-ul] [aria-expanded], [data-aflw-nav-ul] [aria-haspopup]"))) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                if ($el.closest("[data-aflw-nav-dd]"))
                    continue;
                const report = helper.reportObject($el, 84);
                if ($el.closest("[data-aflw-nav-dd-trigger]"))
                    report.success = true;
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
        submenuTriggerTagging() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            for (const $el of helper.elements.filterHiddens(document.querySelectorAll("[data-aflw-nav-dd-trigger]"))) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                const report = helper.reportObject($el, 90);
                report.suggestionLabel = "submenuTrigger";
                if ($el.getAttribute("aria-haspopup") === "true")
                    report.success = true;
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
        /* LATER */
        submenuOperability() { }
    }

    function loopElemsUnderneath(elem, cb) {
        // Helper function to clamp a value between a min and max
        function clamp(value, min, max) {
            return Math.max(min, Math.min(value, max));
        }
        // Get initial bounding box of the element
        let boundingBox = elem.getBoundingClientRect();
        // Define key points (4 corners + center)
        let keyPoints = [
            {
                x: (boundingBox.left + boundingBox.right) / 2,
                y: (boundingBox.top + boundingBox.bottom) / 2,
            },
            { x: boundingBox.left, y: boundingBox.top },
            { x: boundingBox.right, y: boundingBox.top },
            { x: boundingBox.left, y: boundingBox.bottom },
            { x: boundingBox.right, y: boundingBox.bottom },
        ];
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        // Determine how much we need to scroll to get all key points visible
        // If a key point is out of the viewport, we calculate the necessary scroll offset.
        let scrollX = 0;
        let scrollY = 0;
        for (const { x, y } of keyPoints) {
            if (x < 0) {
                // Need to scroll left to bring this point into view
                scrollX = Math.min(scrollX, x);
            }
            else if (x > viewportWidth) {
                // Need to scroll right
                scrollX = Math.max(scrollX, x - viewportWidth);
            }
            if (y < 0) {
                // Need to scroll up
                scrollY = Math.min(scrollY, y);
            }
            else if (y > viewportHeight) {
                // Need to scroll down
                scrollY = Math.max(scrollY, y - viewportHeight);
            }
        }
        // Current scroll position
        const currentScrollX = window.scrollX;
        const currentScrollY = window.scrollY;
        // Compute new scroll targets
        let newScrollX = currentScrollX + scrollX;
        let newScrollY = currentScrollY + scrollY;
        // Clamp the scroll to document boundaries
        const maxScrollX = document.documentElement.scrollWidth - window.innerWidth;
        const maxScrollY = document.documentElement.scrollHeight - window.innerHeight;
        newScrollX = clamp(newScrollX, 0, maxScrollX);
        newScrollY = clamp(newScrollY, 0, maxScrollY);
        // If we need to scroll, do it
        if (newScrollX !== currentScrollX || newScrollY !== currentScrollY) {
            window.scrollTo({
                top: newScrollY,
                left: newScrollX,
                behavior: "instant",
            });
        }
        // After scrolling, get updated bounding box and key points
        boundingBox = elem.getBoundingClientRect();
        keyPoints = [
            {
                x: (boundingBox.left + boundingBox.right) / 2,
                y: (boundingBox.top + boundingBox.bottom) / 2,
            },
            { x: boundingBox.left + 1, y: boundingBox.top + 1 },
            { x: boundingBox.right - 1, y: boundingBox.top + 1 },
            { x: boundingBox.left + 1, y: boundingBox.bottom - 1 },
            { x: boundingBox.right - 1, y: boundingBox.bottom - 1 },
        ];
        for (const { x, y } of keyPoints) {
            let currentFound = false;
            const elementsAtPoint = document.elementsFromPoint(x, y);
            for (const el of elementsAtPoint) {
                if (el === elem) {
                    currentFound = true;
                }
                if (!currentFound) {
                    continue;
                }
                if (cb(el) === true)
                    return true;
            }
        }
        return false;
    }
    class READABILITY extends Criteria {
        static async audit(dynamic, $els) {
            return helper.runAuditMethods(new this(), dynamic, $els);
        }
        fontSizes() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            const $els = this.$els || document.body.querySelectorAll(allSelector);
            for (const $el of $els) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                const text = helper.elements.getText($el, "visible");
                if (!text ||
                    helper.strings.isNumber(text) ||
                    ["/", "-", "@", "!", "_", "#", "$", "*", "%", "=", "?"].includes(text) ||
                    $el.closest('sup, [data-acsb], [data-aflw-sr-only], [data-aflw-hidden="true"]')) {
                    continue;
                }
                const fontSize = parseInt(helper.elements.getStyle($el, "font-size").replace("px", ""));
                const report = helper.reportObject($el, 100);
                if (fontSize > 11 || fontSize <= 1)
                    report.success = true;
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
        letterSpacing() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            const $els = this.$els || document.body.querySelectorAll(allSelector);
            for (const $el of $els) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                const text = helper.elements.getText($el, "visible");
                if (!text ||
                    helper.strings.isNumber(text) ||
                    ["/", "-", "@", "!", "_", "#", "$", "*", "%", "=", "?"].includes(text) ||
                    $el.closest('[data-acsb], [data-aflw-sr-only], [data-aflw-hidden="true"]')) {
                    continue;
                }
                const letterSpacing = helper.elements.getStyle($el, "letter-spacing").replace("px", "");
                const report = helper.reportObject($el, 100);
                if (letterSpacing === "normal" || parseInt(letterSpacing) > -2)
                    report.success = true;
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
        colorContrast() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            const $els = this.$els || document.body.querySelectorAll(allSelector);
            document.documentElement.scrollTop = 0;
            for (const $el of $els) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                const hasPseudoContent = (pseudo) => {
                    const content = helper.elements.getComputedStyle($el, pseudo)?.content;
                    return content && content !== "none";
                };
                if (hasPseudoContent("::before") || hasPseudoContent("::after")) {
                    continue;
                }
                if ($el.closest('[data-acsb], [data-aflw-sr-only], [data-aflw-hidden="true"]') ||
                    helper.skipTags.includes($el.tagName)) {
                    continue;
                }
                const text = (() => {
                    for (const node of $el.childNodes) {
                        if ((node.nodeType === Node.TEXT_NODE && node.nodeValue?.trim().length) || 0 > 0) {
                            return node.nodeValue?.trim() || "";
                        }
                    }
                    return null;
                })();
                if (!text)
                    continue;
                const color = helper.elements.getStyle($el, "color");
                let bgColor = helper.elements.getStyle($el, "background-color");
                const transRegex = /^rgba\(([\d.]+), ([\d.]+), ([\d.]+), ([\d.]+)\)$/;
                let ignore = false;
                let transFound = bgColor.match(transRegex);
                loopElemsUnderneath($el, (el) => {
                    const parentBgColor = helper.elements.getStyle(el, "background-color");
                    const bgImage = helper.elements.getStyle(el, "background-image");
                    if (el.tagName === "IMG" || el.tagName === "VIDEO") {
                        ignore = true;
                        return true;
                    }
                    if (bgImage && bgImage !== "none") {
                        ignore = true;
                        return true;
                    }
                    transFound = parentBgColor.match(transRegex);
                    if (!transFound || +transFound[4] > 0.3) {
                        bgColor = parentBgColor;
                        return true;
                    }
                });
                window.scrollTo({
                    top: 0,
                    left: 0,
                    behavior: "smooth",
                });
                if (ignore)
                    continue;
                transFound = bgColor.match(transRegex);
                if (transFound && +transFound[4] <= 0.3)
                    bgColor = "rgb(255, 255, 255)";
                const foregroundRGB = color
                    .replace(/\s/g, "")
                    .replace("rgba(", "")
                    .replace("rgb(", "")
                    .replace(")", "")
                    .split(",")
                    .map(Number);
                const backgroundRGB = bgColor
                    .replace(/\s/g, "")
                    .replace("rgba(", "")
                    .replace("rgb(", "")
                    .replace(")", "")
                    .split(",")
                    .map(Number);
                const report = helper.reportObject($el, 100);
                const fontSize = parseInt(helper.elements.getStyle($el, "font-size").replace("px", ""));
                if (fontSize > 24) {
                    if (this._getRatio(foregroundRGB, backgroundRGB) >= 3.1)
                        report.success = true;
                }
                else {
                    if (this._getRatio(foregroundRGB, backgroundRGB) >= 4.5)
                        report.success = true;
                }
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
        _getRatio(rgb1, rgb2) {
            const lum1 = this._getLuminance(rgb1[0], rgb1[1], rgb1[2]);
            const lum2 = this._getLuminance(rgb2[0], rgb2[1], rgb2[2]);
            const brightest = Math.max(lum1, lum2);
            const darkest = Math.min(lum1, lum2);
            return (brightest + 0.05) / (darkest + 0.05);
        }
        _getLuminance(r, g, b) {
            const a = [r, g, b].map((v) => {
                v /= 255;
                return v <= 0.03928 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
            });
            return a[0] * 0.2126 + a[1] * 0.7152 + a[2] * 0.0722;
        }
    }

    class TABLES extends Criteria {
        static async audit(dynamic, $els) {
            return helper.runAuditMethods(new this(), dynamic, $els);
        }
        tableLayouts() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            for (const $el of helper.elements.filterHiddens(document.querySelectorAll("[data-aflw-group-table]"))) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                if ($el.querySelectorAll("[data-aflw-role=row]").length > 1 ||
                    !$el.querySelector("[data-aflw-role=listitem], [data-aflw-role=form], section, [data-aflw-role=main], div, [data-aflw-role=heading]")) {
                    continue;
                }
                const report = helper.reportObject($el, 88);
                if ($el.getAttribute("role") === "presentation")
                    report.success = true;
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
        nestedTables() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            for (const $el of helper.elements.filterHiddens(document.querySelectorAll("[data-aflw-group-table] [data-aflw-group-table]"))) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                const report = helper.reportObject($el, 92);
                if ($el.getAttribute("role") === "presentation")
                    report.success = true;
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
        headlessTables() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            for (const $el of helper.elements.filterHiddens(document.querySelectorAll("[data-aflw-group-table]"))) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                const report = helper.reportObject($el, 91);
                if ($el.getAttribute("role") === "presentation" ||
                    $el.querySelector("[data-aflw-table-header]")) {
                    report.success = true;
                }
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
        // @TODO does not exist in db
        emptyTableHeaders() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            for (const $el of helper.elements.filterHiddens(document.querySelectorAll("[data-aflw-table-header]"))) {
                if (!$el.closest("[data-aflw-group-table]") && !$el.closest("thead, [role=rowgroup]"))
                    continue;
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                const report = helper.reportObject($el, 95);
                if (helper.elements.getText($el))
                    report.success = true;
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
        columnTableHeaders() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            for (const $el of helper.elements.filterHiddens(document.querySelectorAll("[data-aflw-group-table]"))) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                if ($el.getAttribute("role") === "presentation" || $el.querySelector("thead")) {
                    continue;
                }
                const $possibleHeaders = [
                    ...$el.querySelectorAll("[data-aflw-role=row]:first-child [data-aflw-role=cell]"),
                ];
                if ($possibleHeaders.length < 1 || !this._areFakeCellHeaders($el, $possibleHeaders))
                    continue;
                const report = helper.reportObject($el, 88, "columnHeader");
                if ($el.querySelector("[data-aflw-role=columnheader]"))
                    report.success = true;
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
        rowTableHeaders() {
            const reports = {};
            const auditedVar = helper.generateAflwAuditedVar();
            for (const $el of helper.elements.filterHiddens(document.querySelectorAll("[data-aflw-group-table]"))) {
                if (helper.checkElementAudited($el, auditedVar))
                    continue;
                if ($el.getAttribute("role") === "presentation" || $el.querySelector("thead")) {
                    continue;
                }
                const $possibleHeaders = [
                    ...$el.querySelectorAll("[data-aflw-role=row] [data-aflw-role=cell]:first-child"),
                ];
                const $possibleHeaders2 = [
                    ...$el.querySelectorAll("[data-aflw-role=row] [data-aflw-role=cell]:nth-child(2)"),
                ];
                if ($possibleHeaders.length < 1 ||
                    $possibleHeaders2.length < 1 ||
                    !this._areFakeCellHeaders($el, $possibleHeaders) ||
                    this._areFakeCellHeaders($el, $possibleHeaders2)) {
                    continue;
                }
                const report = helper.reportObject($el, 84, "rowHeader");
                if ($el.querySelector("[data-aflw-role=rowheader]"))
                    report.success = true;
                helper.aggregateReports(reports, report);
            }
            return reports;
        }
        _areFakeCellHeaders($table, $possibleHeaders) {
            let headerFontSize;
            let fakeHeaders = true;
            for (const $td of $possibleHeaders) {
                const $children = $td.querySelectorAll(allSelector);
                if ($children.length < 1 && helper.elements.getText($td)) {
                    const fontSize = Number(helper.elements.getStyle($td, "font-weight"));
                    if ((fontSize || !isNaN(fontSize)) && fontSize > 500) {
                        headerFontSize = fontSize;
                        helper.checkElementAudited($td, "aflwFakeCellHeader");
                        continue;
                    }
                }
                if (!helper.isElementAudited($td, "aflwFakeCellHeader")) {
                    for (const $child of $children) {
                        if (!$child.childNodes[0] ||
                            $child.childNodes[0].nodeType !== Node.TEXT_NODE ||
                            !$child.childNodes[0].nodeValue)
                            continue;
                        const fontSize = Number(helper.elements.getStyle($child, "font-weight"));
                        if (!fontSize || isNaN(fontSize))
                            continue;
                        if (fontSize < 500) {
                            helper.removeElementAudited($td, "aflwFakeCellHeader");
                            continue;
                        }
                        headerFontSize = fontSize;
                        helper.checkElementAudited($td, "aflwFakeCellHeader");
                        break;
                    }
                }
            }
            for (const $td of $possibleHeaders) {
                if (helper.isElementAudited($td, "aflwFakeCellHeader"))
                    continue;
                fakeHeaders = false;
                break;
            }
            if (headerFontSize && fakeHeaders) {
                for (const $child of $table.querySelectorAll("[data-aflw-role=row]:nth-child(2) [data-aflw-role=cell]:nth-child(2)")) {
                    if ($child.childNodes[0]?.nodeType !== Node.TEXT_NODE || !$child.childNodes[0]?.nodeValue)
                        continue;
                    const fontSize = Number(helper.elements.getStyle($child, "font-weight"));
                    if (!fontSize || isNaN(fontSize) || fontSize < headerFontSize)
                        continue;
                    fakeHeaders = false;
                    break;
                }
            }
            return fakeHeaders;
        }
    }

    /**
     * @class
     * @classdesc A basic, strictly-typed Event emitter  (both event types and their payload)
     * allows to add, remove and emit events
     */
    let EventEmitter$1 = class EventEmitter {
        /** a html `HTMLSpanElement` Used as event bus for handling events in the class **/
        eventBus = document.createElement("span");
        listeners = new Map();
        /** Triggers/Emits a custom event with given `type` on the `eventBus` element */
        emit(event, ...args) {
            this.eventBus.dispatchEvent(new CustomEvent(event.toString(), { detail: args }));
        }
        /** Removes an event listener for given `type` from the `eventBus` element **/
        off(event, listener, options) {
            const storedListener = this.listeners.get(listener);
            this.eventBus.removeEventListener(event.toString(), storedListener, options);
        }
        /** Adds an event listener for given `type` from the `eventBus` element **/
        on(event, listener, options) {
            const boundedListener = (event) => listener(...event.detail);
            this.listeners.set(listener, boundedListener);
            this.eventBus.addEventListener(event.toString(), boundedListener, options);
        }
    };

    /**
     * @classdesc
     */
    class Detector {
        /**
         * The unique ID of the detector
         * It will be used only by the modification service to identify the detector
         */
        static id;
        /**
         * The type of the detector
         */
        static type;
        /**
         * List of traits that this detector is a subset of
         */
        static subsetOf;
        /**
         * List of traits that this detector is a not-subset of
         */
        static notSubsetOf = [];
        /**
         * Checks if the given element is detected as positive
         * @param element the element to check
         *
         * TODO: the classifier parameter should be made required in the future
         */
        static detect;
        /**
         * Specifies the conditions under which the detector can skip checking the children of the element.
         * Accepts one of the following:
         * - "positive": Skip when a positive condition is met.
         * - "negative": Skip when a negative condition is met.
         * - "never": Never skip the children.
         * - A function: Custom logic that returns a boolean, determining whether to skip children based on the element and classifier.
         */
        static skipChildrenWhen;
        /**
         * List of detectors that should cause this detector to be rejected and it's children not checked
         */
        static notChildOf = [];
        /**
         * Indicates the maximum number of matches before the detector is rejected (performance optimization)
         */
        static maxMatches = Infinity;
        /**
         * List of detectors that this detector depends on, and should be run before this detector
         */
        static dependencies = [];
        /**
         * Indicates that the global update should be ignored
         */
        static ignoreUpdates;
        /**
         * The instance of the context for this detector
         */
        static contextType;
    }
    class Locator {
        /**
         * The unique ID of the locator
         * It will be used only by the modification service to identify the locator
         */
        static id;
        /**
         * A static cache of weak references to located `SvgOrHtmlElement` instances.
         * This helps retain references without preventing garbage collection.
         */
        static matches = [];
        /**
         * Indicates whether the locator's model has already executed.
         * Used to prevent redundant location operations
         */
        static modelExecuted = false;
        /**
         * Asynchronously locates `SvgOrHtmlElement` instances based on the provided classifier.
         * If cached matches exist, those are returned instead of performing a new location.
         *
         * @param classifier - Optional engine classifier used to refine the search logic.
         * @returns A promise resolving to an array of located `SvgOrHtmlElement` instances.
         */
        static async locate(classifier) {
            if (this.modelExecuted) {
                if (this.matches.length) {
                    return this.getCachedMatches();
                }
                return [];
            }
            const result = await this.doLocate(classifier);
            this.modelExecuted = true;
            if (result.length > 0) {
                this.matches = result.map((element) => new WeakRef(element));
            }
            return result;
        }
        /**
         * A protected method that defines the core logic for locating `SvgOrHtmlElement` instances.
         * This method should be implemented by subclasses or external logic.
         *
         * @param classifier - Optional engine classifier used to refine the search logic.
         * @returns A promise resolving to an array of located `SvgOrHtmlElement` instances.
         */
        static doLocate;
        /**
         * Clears the cache of weak references to previously located elements
         * and resets the model execution state.
         */
        static clearCache() {
            this.matches = [];
            this.modelExecuted = false;
        }
        /**
         * Retrieves the currently cached matches, filtering out any references that
         * have been garbage-collected.
         *
         * @returns An array of valid `SvgOrHtmlElement` instances from the cache.
         */
        static getCachedMatches() {
            return this.matches.map((match) => match.deref()).filter(Boolean);
        }
        /**
         * A list of detector classes that this locator depends on. These detectors provide
         * additional logic or tools required for locating elements.
         */
        static dependencies = [];
    }

    // TODO: Export the type DetectorOrLocator from the package
    class RuleValidateResponse {
        failedNodes;
        inapplicableNodes;
        cantTellNodes;
        passedNodes;
        passed;
        constructor({ failedNodes = [], inapplicableNodes = [], cantTellNodes = [], passedNodes = [] } = {}) {
            this.failedNodes = failedNodes;
            this.inapplicableNodes = inapplicableNodes;
            this.cantTellNodes = cantTellNodes;
            this.passedNodes = passedNodes;
            this.passed = null;
        }
    }
    var PassCondition;
    (function (PassCondition) {
        PassCondition["PassedNodesAndNoFailedNodes"] = "PassedNodesAndNoFailedNodes";
        PassCondition["NoFailedNodes"] = "NoFailedNodes";
        PassCondition["NoInapplicableNodes"] = "NoInapplicableNodes";
    })(PassCondition || (PassCondition = {}));

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function getDefaultExportFromCjs (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    /**
     * Convert a color from sRGB to linear RGB
     * @param {number} color - The sRGB color value (0 to 255)
     * @returns {number} The linear RGB value
     */
    const sRGBToLinear = (color) => {
        const sRGB = color / 255;
        return sRGB <= 0.03928 ? sRGB / 12.92 : Math.pow((sRGB + 0.055) / 1.055, 2.4);
    };
    /**
     * Calculate the relative luminance of a color
     * @param {number} r - The red component of the color
     * @param {number} g - The green component of the color
     * @param {number} b - The blue component of the color
     * @returns {number} The relative luminance of the color
     */
    const getRelativeLuminance = (r, g, b) => {
        const R = sRGBToLinear(r);
        const G = sRGBToLinear(g);
        const B = sRGBToLinear(b);
        return 0.2126 * R + 0.7152 * G + 0.0722 * B;
    };

    /**
     *  Parse a rgba color string into an array of color components
     *  @param {string} color - The color in rgba format
     *  @returns {number[]} An array of color components
     * */
    const parseColor = (color) => {
        const match = /^rgba?\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})(?:,\s*(0|1|0\.\d{1,3}|1\.00))?\)$/.exec(color);
        if (!match) {
            throw new Error(`Invalid color value: ${color}`);
        }
        // match[0] is the whole match, match[1] through match[4] are the capturing groups, filter out the undefined values
        const rgba = match
            .slice(1)
            .filter((m) => m)
            .map(Number);
        // If the color is in rgb format, add an alpha channel of 1
        if (rgba.length === 3)
            rgba.push(1);
        return rgba;
    };

    /**
     *  Check if a color is fully opaque, i.e., the alpha channel is 1
     *  @param {string} color - The color in rgba format
     *  @returns {boolean} True if the color is fully opaque, false otherwise
     * */
    const isFullyOpaque = (color) => {
        if (color === "transparent") {
            return false;
        }
        const rgba = parseColor(color);
        // If the color is in rgb format or the alpha channel is 1, the color is fully opaque
        return rgba.length === 3 || rgba[3] === 1;
    };
    /**
     *  Check if a color is transparent, i.e., the alpha channel is 0
     *  @param {string} color - The color in rgba format
     *  @returns {boolean} True if the color is transparent, false otherwise
     * */
    const isTransparent = (color) => {
        if (color === "transparent") {
            return true;
        }
        const rgba = parseColor(color);
        // If the color is in rgba format and the alpha channel is 0, the color is transparent
        return rgba.length === 4 && rgba[3] === 0;
    };
    /**
     * Calculate the contrast ratio between two colors
     * @param {string} color1 - The first color in rgb format
     * @param {string} color2 - The second color in rgb format
     * @returns {number} The contrast ratio between the two colors
     */
    const getContrastRatio = (color1, color2) => {
        const [r1, g1, b1] = parseColor(color1);
        const [r2, g2, b2] = parseColor(color2);
        const L1 = getRelativeLuminance(r1, g1, b1) + 0.05;
        const L2 = getRelativeLuminance(r2, g2, b2) + 0.05;
        return Number((L1 > L2 ? L1 / L2 : L2 / L1).toFixed(2));
    };
    /**
     *  Blend two colors together
     *  @param {string} color1 - The first color in rgba format
     *  @param {string} color2 - The second color in rgba format
     *  @returns {string} The blended color in rgba format
     * */
    const blendColors = (color1, color2) => {
        const [r1, g1, b1, a1] = parseColor(color1);
        const [r2, g2, b2, a2] = parseColor(color2);
        // If both alpha values are zero, return the original color
        if (a1 === 0 && a2 === 0) {
            return color1;
        }
        const a = a1 + a2 * (1 - a1);
        const r = Math.round((r1 * a1 + r2 * a2 * (1 - a1)) / a);
        const g = Math.round((g1 * a1 + g2 * a2 * (1 - a1)) / a);
        const b = Math.round((b1 * a1 + b2 * a2 * (1 - a1)) / a);
        const alpha = a === 1 ? "1" : a.toFixed(2);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    };

    /**
     * Checks if the provided value is an iterator-like object.
     * An iterator-like object is one that has a `next` method.
     *
     * @param obj - The value to check.
     * @returns True if the value is an iterator-like object, false otherwise.
     */
    function isIteratorLike(obj) {
        return obj !== null && typeof obj === "object" && typeof obj.next === "function";
    }

    class Operation {
        /**
         * The dependencies that are required for this operation's logic to work.
         * these are aggregated by the Operations class and are used to by the EngineClassifier to initialize the dependency graph.
         */
        static dependencies = [];
        __cache = Object.create(null);
        constructor() {
            const cache = this.__cache;
            return new Proxy(this, {
                get: (target, prop, receiver) => {
                    // Symbols, functions, and non-string props: just forward.
                    if (typeof prop !== "string") {
                        return Reflect.get(target, prop, receiver);
                    }
                    // Look up the property descriptor to know if it's a getter.
                    const proto = Object.getPrototypeOf(target);
                    const desc = Object.getOwnPropertyDescriptor(proto, prop);
                    // Not a getter? (method or data property) -> just forward, don't cache.
                    if (!desc || !desc.get) {
                        return Reflect.get(target, prop, receiver);
                    }
                    // If we've cached it (and it's cacheable), return it.
                    if (prop in cache) {
                        return cache[prop];
                    }
                    // Compute the value once
                    const value = target[prop];
                    // If it is a generator / iterator, DO NOT cache (so each access gets a fresh iterator).
                    if (isIteratorLike(value)) {
                        return value;
                    }
                    cache[prop] = value;
                    return value;
                },
            });
        }
    }

    /**
     * Returns the name of the closest CSS color to the given element's background color.
     * @param element
     * @param classifier
     */
    function getColorName(element, classifier) {
        const { backgroundColor: rgbString } = classifier.getOperations(element).colorInfo;
        const match = rgbString.match(/\d+/g).map(Number);
        const [r, g, b] = match;
        const lab1 = rgbToLab(r, g, b);
        let closestColor;
        let minDistance = Infinity;
        Object.entries(cssColors).forEach(([color, value]) => {
            const match = value.match(/\d+/g).map(Number);
            const lab2 = rgbToLab(match[0], match[1], match[2]);
            const distance = colorDistance(lab1, lab2);
            if (distance < minDistance) {
                minDistance = distance;
                closestColor = color;
            }
        });
        return closestColor;
    }
    /**
     * Converts an RGB color to the Lab color space, which is designed to reflect human perception.
     */
    function rgbToLab(r, g, b) {
        function pivot(x) {
            return x > 0.04045 ? Math.pow((x + 0.055) / 1.055, 2.4) : x / 12.92;
        }
        r = pivot(r / 255);
        g = pivot(g / 255);
        b = pivot(b / 255);
        const x = (r * 0.4124564 + g * 0.3575761 + b * 0.1804375) / 0.95047;
        const y = (r * 0.2126729 + g * 0.7151522 + b * 0.072175) / 1.0;
        const z = (r * 0.0193339 + g * 0.119192 + b * 0.9503041) / 1.08883;
        function f(t) {
            return t > 0.008856 ? Math.pow(t, 1 / 3) : 7.787 * t + 16 / 116;
        }
        const L = 116 * f(y) - 16;
        const A = 500 * (f(x) - f(y));
        const B = 200 * (f(y) - f(z));
        return [L, A, B];
    }
    /**
     * Computes the Euclidean distance between two colors in the Lab color space.
     * This helps determine how perceptually different two colors appear to humans.
     * A smaller distance indicates greater similarity.
     */
    function colorDistance(lab1, lab2) {
        return Math.sqrt(Math.pow(lab1[0] - lab2[0], 2) + Math.pow(lab1[1] - lab2[1], 2) + Math.pow(lab1[2] - lab2[2], 2));
    }
    const cssColors = {
        black: "rgb(0, 0, 0)",
        dimgray: "rgb(105, 105, 105)",
        gray: "rgb(128, 128, 128)",
        darkgray: "rgb(169, 169, 169)",
        silver: "rgb(192, 192, 192)",
        lightgray: "rgb(211, 211, 211)",
        gainsboro: "rgb(220, 220, 220)",
        whitesmoke: "rgb(245, 245, 245)",
        white: "rgb(255, 255, 255)",
        maroon: "rgb(128, 0, 0)",
        darkred: "rgb(139, 0, 0)",
        brown: "rgb(165, 42, 42)",
        firebrick: "rgb(178, 34, 34)",
        crimson: "rgb(220, 20, 60)",
        red: "rgb(255, 0, 0)",
        tomato: "rgb(255, 99, 71)",
        orangered: "rgb(255, 69, 0)",
        coral: "rgb(255, 127, 80)",
        indianred: "rgb(205, 92, 92)",
        lightcoral: "rgb(240, 128, 128)",
        darkorange: "rgb(255, 140, 0)",
        orange: "rgb(255, 165, 0)",
        gold: "rgb(255, 215, 0)",
        yellow: "rgb(255, 255, 0)",
        lightyellow: "rgb(255, 255, 224)",
        lemonchiffon: "rgb(255, 250, 205)",
        papayawhip: "rgb(255, 239, 184)",
        moccasin: "rgb(255, 228, 181)",
        peachpuff: "rgb(255, 218, 185)",
        darkgoldenrod: "rgb(184, 134, 11)",
        goldenrod: "rgb(218, 165, 32)",
        peru: "rgb(205, 133, 63)",
        chocolate: "rgb(210, 105, 30)",
        saddlebrown: "rgb(139, 69, 19)",
        sienna: "rgb(160, 82, 45)",
        rosybrown: "rgb(188, 143, 143)",
        darkolivegreen: "rgb(85, 107, 47)",
        olive: "rgb(128, 128, 0)",
        olivedrab: "rgb(107, 142, 35)",
        yellowgreen: "rgb(154, 205, 50)",
        limegreen: "rgb(50, 205, 50)",
        lime: "rgb(0, 255, 0)",
        lawngreen: "rgb(124, 252, 0)",
        chartreuse: "rgb(127, 255, 0)",
        mediumseagreen: "rgb(60, 179, 113)",
        seagreen: "rgb(46, 139, 87)",
        forestgreen: "rgb(34, 139, 34)",
        green: "rgb(0, 128, 0)",
        darkgreen: "rgb(0, 100, 0)",
        lightgreen: "rgb(144, 238, 144)",
        palegreen: "rgb(152, 251, 152)",
        honeydew: "rgb(240, 255, 240)",
        teal: "rgb(0, 128, 128)",
        darkcyan: "rgb(0, 139, 139)",
        cadetblue: "rgb(95, 158, 160)",
        steelblue: "rgb(70, 130, 180)",
        lightseagreen: "rgb(32, 178, 170)",
        mediumturquoise: "rgb(72, 209, 204)",
        turquoise: "rgb(64, 224, 208)",
        aqua: "rgb(0, 255, 255)",
        cyan: "rgb(0, 255, 255)",
        darkslategray: "rgb(47, 79, 79)",
        slategray: "rgb(112, 128, 144)",
        lightslategray: "rgb(119, 136, 153)",
        powderblue: "rgb(176, 224, 230)",
        lightblue: "rgb(173, 216, 230)",
        skyblue: "rgb(135, 206, 235)",
        lightskyblue: "rgb(135, 206, 250)",
        dodgerblue: "rgb(30, 144, 255)",
        deepskyblue: "rgb(0, 191, 255)",
        royalblue: "rgb(65, 105, 225)",
        blue: "rgb(0, 0, 255)",
        mediumblue: "rgb(0, 0, 205)",
        darkblue: "rgb(0, 0, 139)",
        navy: "rgb(0, 0, 128)",
        midnightblue: "rgb(25, 25, 112)",
        indigo: "rgb(75, 0, 130)",
        purple: "rgb(128, 0, 128)",
        darkmagenta: "rgb(139, 0, 139)",
        darkviolet: "rgb(148, 0, 211)",
        blueviolet: "rgb(138, 43, 226)",
        mediumslateblue: "rgb(123, 104, 238)",
        mediumpurple: "rgb(147, 112, 219)",
        slateblue: "rgb(106, 90, 205)",
        violet: "rgb(238, 130, 238)",
        orchid: "rgb(218, 112, 214)",
        plum: "rgb(221, 160, 221)",
        thistle: "rgb(216, 191, 216)",
        lavender: "rgb(230, 230, 250)",
        pink: "rgb(255, 192, 203)",
        lightpink: "rgb(255, 182, 193)",
        hotpink: "rgb(255, 105, 180)",
        deeppink: "rgb(255, 20, 147)",
        palevioletred: "rgb(219, 112, 147)",
        mediumvioletred: "rgb(199, 21, 133)",
    };

    /**
     * Calculate the color information of an element
     * It will return the color, backgroundColor, backgroundImage, borderColor, outlineColor, opacity of the element
     */
    class ColorInfo extends Operation {
        element;
        classifier;
        /**
         * @inheritdoc
         */
        static dependencies = [];
        /**
         * The color of the text in rgb or rgba format.
         * color: @see https://developer.mozilla.org/en-US/docs/Web/CSS/color_value
         */
        get color() {
            return ColorInfo.getEffectiveColor(this.computedStyle);
        }
        /**
         * The background color of the element in rgb or rgba format.
         * backgroundColor: @see https://developer.mozilla.org/en-US/docs/Web/CSS/background-color
         */
        get backgroundColor() {
            return this.computedStyle.backgroundColor;
        }
        /**
         * The background image of the element, gradient background will return a background-image value.
         * backgroundImage: @see https://developer.mozilla.org/en-US/docs/Web/CSS/background-image
         */
        get backgroundImage() {
            return this.computedStyle.backgroundImage;
        }
        /**
         * The background color of the element or the nearest parent with a non-transparent background color.
         */
        get aggregatedBackgroundColor() {
            return this.getAggregatedBackgroundColor(this.element);
        }
        /**
         * The background color of the element or the nearest parent with a non-transparent background color - in a numbers array format [r, g, b, a]
         */
        get aggregatedBackgroundColorParsed() {
            return parseColor(this.aggregatedBackgroundColor);
        }
        /**
         * The border color of the element in rgb or rgba format.
         * borderColor: @see https://developer.mozilla.org/en-US/docs/Web/CSS/border-color
         */
        get borderColor() {
            return this.computedStyle.borderColor;
        }
        /**
         * The opacity of the element (0 to 1).
         * opacity: @see https://developer.mozilla.org/en-US/docs/Web/CSS/opacity
         */
        get opacity() {
            return Number(this.computedStyle.opacity);
        }
        /**
         * The outline color of the element in rgb or rgba format.
         * outlineColor: @see https://developer.mozilla.org/en-US/docs/Web/CSS/outline-color
         */
        get outlineColor() {
            return this.computedStyle.outlineColor;
        }
        /**
         * The contrast ratio between the color and the background color.
         */
        get colorContrastRatio() {
            return getContrastRatio(this.color, this.aggregatedBackgroundColor);
        }
        /**
         * The name of the background color - e.g. "white", "black", "red"
         */
        get backgroundColorName() {
            if (this.backgroundColor === "rgba(0, 0, 0, 0)") {
                return null;
            }
            return getColorName(this.element, this.classifier);
        }
        /**
         * the computedStyle of the element as exposed by the `resources` param
         */
        computedStyle;
        constructor(element, { computedStyle }, classifier) {
            super();
            this.element = element;
            this.classifier = classifier;
            this.computedStyle = computedStyle;
        }
        /**
         * Get the aggregated background color of an element
         * The aggregated background color is the background color of the element or the nearest parent with a non-transparent background color
         * @param {HTMLElement} element - The element to get the aggregated background color from
         * @returns {string} The aggregated background color in rgba format
         * */
        getAggregatedBackgroundColor(element) {
            let currentElement = element;
            let aggregatedBackgroundColor = "rgba(0, 0, 0, 0)";
            while (currentElement && !isFullyOpaque(aggregatedBackgroundColor)) {
                const { colorInfo } = this.classifier.getOperations(currentElement);
                const currentBackgroundColor = colorInfo.backgroundColor;
                const currentOpacity = Number(colorInfo.opacity);
                if (currentBackgroundColor.startsWith("rgb") && currentBackgroundColor !== "transparent" && currentBackgroundColor !== "rgba(0, 0, 0, 0)") {
                    aggregatedBackgroundColor = blendColors(aggregatedBackgroundColor, currentBackgroundColor);
                    const rgba = parseColor(aggregatedBackgroundColor);
                    if (rgba.length === 4) {
                        rgba[3] *= currentOpacity; // Multiply the alpha channel by the opacity
                        aggregatedBackgroundColor = `rgba(${rgba.join(", ")})`;
                    }
                }
                currentElement = currentElement.parentElement;
            }
            if (!isFullyOpaque(aggregatedBackgroundColor)) {
                aggregatedBackgroundColor = blendColors(aggregatedBackgroundColor, "rgba(255, 255, 255, 1)");
            }
            return aggregatedBackgroundColor;
        }
        /**
         * Get the effective color of an element
         * The effective color is the background color of the element or the nearest parent with a non-transparent background color, taking into account the opacity of the element.
         * @param {CSSStyleDeclaration} computedStyle - The element to get the effective color from
         * @returns {string} The effective color in rgba format
         * */
        static getEffectiveColor(computedStyle) {
            let color = computedStyle.color;
            const opacity = Number(computedStyle.opacity);
            const rgba = parseColor(color);
            rgba[3] *= opacity;
            if (rgba[3] !== 1) {
                color = `rgba(${rgba.join(", ")})`;
            }
            else {
                rgba.pop();
                color = `rgb(${rgba.join(", ")})`;
            }
            return color;
        }
    }

    /**
     * Getting all the related elements to a provided element, that are associated with it via the "aria-labelledby" and "aria-describedby" attributes.
     *
     * @param element The element for which to get related aria elements
     * @returns Array of elements associated with the provided element
     */
    const getAriaElements = (element, attribute) => {
        const elements = [];
        const ariaAttributes = attribute ? [attribute] : ["aria-labelledby", "aria-describedby"];
        for (const attr of ariaAttributes) {
            const attrValue = element.getAttribute(attr);
            if (!attrValue) {
                continue;
            }
            const ids = attrValue
                .split(" ")
                .map((id) => id.trim())
                .filter(Boolean);
            ids.forEach((id) => {
                const ariaElement = document.getElementById(id);
                if (ariaElement) {
                    elements.push(ariaElement);
                }
            });
        }
        return elements;
    };

    /**
     * Type guard to check if a node is a Document element.
     */
    const isDocumentElement = (node) => {
        if (!node) {
            return false;
        }
        return node.nodeType === Node.DOCUMENT_NODE;
    };

    /**
     * Get the context of a node (window object)
     * NOTE: the null-checks are in places for cases such as:
     * - when the node is not attached to the DOM
     * - when accessing a cors iframe
     * - when param is null/undefined
     *
     * @param node - The node to get the context from
     *
     * TODO: might want to support a variety of instances that have a context, e.g: CSSStyleRule. also, might want to rename this to getInstanceContext.
     */
    const getOwnerWindow = (node) => {
        /**
         * If the node is a Document, we don't have ownerDocument, so we access defaultView directly.
         */
        if (isDocumentElement(node)) {
            return node.defaultView;
        }
        return node?.ownerDocument?.defaultView;
    };

    /**
     * Checks if a value is an iterable object.
     */
    function isIterable(value) {
        return typeof value?.[Symbol.iterator] === "function";
    }

    /**
     * Check if a value is an instance of a given constructor.
     * This extends the instanceof operator because it might require the correct context to work as expected.
     */
    const isInstanceOf = (value, constructor, context) => {
        const originalInstanceCheck = value instanceof constructor;
        if (originalInstanceCheck) {
            return true;
        }
        if (!value) {
            return false;
        }
        // if in main document, no need to resolve other contexts
        if (value?.ownerDocument === document) {
            return false;
        }
        /**
         * for the most part, this should exist but some webos overrides may cause it to be absent and cause runtime errors.
         * this behaviour should be prevented by webpack-api-sanitizer, but we should also account for it here.
         */
        if (!constructor.name) {
            return false;
        }
        /**
         * if the value is an iterable, we cannot retrive the context from the value itself but from one of its items
         */
        if (isIterable(value)) {
            context ??= getOwnerWindow(value[0]);
        }
        else {
            context ??= getOwnerWindow(value);
        }
        return Boolean(context) && value instanceof context[constructor.name];
    };

    /**
     * Check if a node is an SVG or HTML element.
     *
     * NOTE: instanceof checks require the element's context to provide a correct result, hence the call to getOwnerWindow.
     * since the context might be null, we fallback to the top window object.
     */
    const isSvgOrHtmlElement = (node) => {
        if (!node)
            return false;
        /**
         * we are forced to use 'as Node' here because EventTarget doesnt have access to ownerDocument, but most of the time it will be an instance of a Node.
         * we cant do instanceof check because we must have the correct context to do so (which getOwnerWindow provides)
         */
        return isInstanceOf(node, HTMLElement) || isInstanceOf(node, SVGElement);
    };

    /**
     * guard function that checks if the given value is a list of HTMLLabelElement
     */
    const isHTMLLabelElementList = (labels) => {
        return isInstanceOf(labels, NodeList) && [...labels].every((label) => isInstanceOf(label, HTMLLabelElement));
    };

    /**
     * Check if a node is an element that could have an `alt` attribute.
     */
    const isAltElement = (node) => {
        if (node.tagName === "IMG") {
            return true;
        }
        if (node.tagName === "INPUT" && node.getAttribute("type") === "image") {
            return true;
        }
        if (node.tagName === "AREA") {
            return true;
        }
        return false;
    };

    /**
     * Determines if the provided class is a Locator.
     *
     * This method checks whether the given `detectorOrLocator` inherits from the `Locator` class.
     * It is used to distinguish between `Locator` and `Detector` types in scenarios where
     * the type is ambiguous, enabling type-safe operations without explicit casting.
     *
     * @param detectorOrLocator - The class to evaluate, which can be either a `Detector` or a `Locator`.
     * @returns `true` if the given class is a `Locator`; otherwise, `false`.
     */
    function isLocator(detectorOrLocator) {
        return Locator.isPrototypeOf(detectorOrLocator);
    }

    /**
     * Determines if the provided class is a Detector.
     *
     * This method checks whether the given `detectorOrLocator` inherits from the `Detector` class.
     * It is used to distinguish between `Detector` and `Locator` types in scenarios where
     * the type is ambiguous, enabling type-safe operations without explicit casting.
     *
     * @param detectorOrLocator - The class to evaluate, which can be either a `Detector` or a `Locator`.
     * @returns `true` if the given class is a `Detector`; otherwise, `false`.
     */
    function isDetector(detectorOrLocator) {
        return Detector.isPrototypeOf(detectorOrLocator);
    }

    /**
     * Getting the associated label elements of a given element
     *
     * @param element The element for which to get the label element
     * @returns either the assoicated label elements in an array or an empty array
     */
    const getAssociatedLabels = (element) => {
        if ("labels" in element && isHTMLLabelElementList(element.labels)) {
            return [...element.labels];
        }
        return [];
    };

    // Attributes to ignore when extracting element context
    const IGNORED_ATTRIBUTES = new Set([
        // Style is irrelevant for classification
        "style",
        // Covered by specific handling of the id property
        "id",
        // Covered by specific handling of the className property
        "class",
        // Might cause false positives,. It doesn't indicate the context of the element (consider roles like "navigation", "presentation" etc.).
        "role",
        // Covered by the allText property in ContentInfo
        "aria-label",
        // Covered by specific handling of aria elements
        "aria-labelledby",
        // Covered by specific handling of aria elements
        "aria-describedby",
    ]);
    /**
     * Collect attributes as a long string of "attrName attrValue" from element
     * So for <div name="cool" title="awesome">...</div> the output will be "name cool title awesome"
     *
     * Note: some attributes are filtered out, like style and aria elements
     *
     * @param element From which to extract the attributes
     * @returns A sting representing all the attributes names and values
     */
    const extractAttributesAsStrings = (element) => {
        const attributesContents = [];
        for (const attribute of element.attributes) {
            if (IGNORED_ATTRIBUTES.has(attribute.name)) {
                continue;
            }
            const attributeContent = [attribute.name, attribute.value].join(" ").trim();
            attributesContents.push(attributeContent);
        }
        return attributesContents.join(" ").trim();
    };
    /**
     * Safely retrieves a property of an element and returns it as a trimmed string if possible.
     *
     * @param element The element from which to retrieve the property
     * @param property The property to retrieve
     * @returns a string representing the trimmed property value or an empty string if not applicable
     *
     * Motivation:
     * In some cases, certain properties of HTML elements, such as `id` and `tagName`, might not be strings.
     * For example, a form element with an input field named "id" might cause `element.id` to reference an HTML element instead of a string.
     * This can lead to errors when trying to manipulate these properties as strings, such as calling `trim()` on them.
     *
     * Cases:
     * Form elements with input fields named "id" or "tagName":
     * - `element.id` may reference the input element rather than being a string.
     * - `element.tagName` could be overridden by a property on the element or its prototype.
     */
    //Add the property getter return type
    const getSafeStringProperty = (element, property) => {
        // Get the property descriptor from the prototype
        const descriptor = Object.getOwnPropertyDescriptor(HTMLElement.prototype, property);
        if (descriptor && typeof descriptor.get === "function") {
            // Use the original getter in the context of the element
            const value = descriptor.get.call(element);
            if (typeof value === "string") {
                return value;
            }
        }
        else {
            // Directly access the property if it's not a getter
            const value = element[property];
            if (typeof value === "string") {
                return value;
            }
        }
        return "";
    };
    /**
     * Extracting all the non-textual info about an element. This includes the tag name, classes, and attributes.
     *
     * @param element The element from which to extract the context
     * @returns a string representing the context of the element
     */
    const extractElementContext = (element) => {
        const elementAttributes = extractAttributesAsStrings(element);
        const elementClassList = element.classList.value;
        const tagName = getSafeStringProperty(element, "tagName");
        const elementId = getSafeStringProperty(element, "id");
        const elementStrings = [tagName, elementId, elementClassList, elementAttributes].filter(Boolean).join(" ").trim().toLowerCase();
        return elementStrings;
    };
    /**
     * Getting a context part of the element, each part represents tagname, classes and attributes for:
     * 1. the provided element itself
     * 2. associated label element (if exists)
     * 3. associated aria elements (if there are any)
     *
     * @generator
     * @param element Element from which to extract context
     * @yields a string representing a part of the elements context
     */
    function* extractElementContexts(element) {
        // Getting element classes and attributes
        yield extractElementContext(element);
        // Getting label element classes and attributes
        const labels = getAssociatedLabels(element);
        if (labels) {
            for (const label of labels) {
                yield extractElementContext(label);
            }
        }
        // Getting aria elements classes and attributes
        const ariaElements = getAriaElements(element);
        for (const ariaElement of ariaElements) {
            yield extractElementContext(ariaElement);
        }
    }

    const COMPONENT_MATCHERS = {
        close: {
            exacts: ["x", "×"],
            words: ["close", "dismiss", "hide", "cancel", "exit", "times"],
        },
        remove: {
            exacts: [],
            words: ["remove", "trash", "bin", "delete", "cross"],
        },
        next: {
            exacts: ["❯"],
            words: ["next", "nxt", "forward", "right", "arrowright"],
        },
        previous: {
            exacts: ["❮"],
            words: ["previous", "prev", "prv", "back", "left", "arrowleft"],
        },
        carouselSlidePicker: {
            exacts: ["○", "●"],
            words: ["pagination", "dot", "indicator", "point", "circle", "spot", "pager", "page", "thumb"],
        },
        contact: {
            exacts: [],
            words: ["contact", "envelop", "mail", "phone", "email"],
        },
        search: {
            exacts: [],
            words: ["search", "srch", "magnifier"],
        },
        cart: {
            exacts: [],
            words: ["cart", "bag", "basket", "shop", "checkout", "coupon", "promo", "quantity", "qty"],
        },
        menu: {
            exacts: [],
            words: ["burger", "menu", "nav", "bars", "lines"],
        },
        download: {
            exacts: [],
            words: ["download"],
        },
        order: {
            exacts: [],
            words: ["order"],
        },
        share: {
            exacts: [],
            words: ["share"],
        },
        move: {
            exacts: [],
            words: ["slide", "range", "move"],
        },
        toggle: {
            exacts: [],
            words: ["toggle", "switch"],
        },
        accept: {
            exacts: [],
            words: ["check", "accept", "verify"],
        },
        recaptcha: {
            exacts: [],
            words: ["recaptcha"],
        },
        hCaptcha: {
            exacts: [],
            words: ["h-captcha"],
        },
        cfTurnstile: {
            exacts: [],
            words: ["cf-turnstile"],
        },
        friendlyCaptcha: {
            exacts: [],
            words: ["frc-captcha"],
        },
        account: {
            exacts: [],
            words: ["login", "log-in", "signup", "sign-up", "register", "user", "account", "profile"],
        },
        date: {
            exacts: [],
            words: ["date", "picker"],
        },
        address: {
            exacts: [],
            words: ["pin", "address", "map", "location"],
        },
        subscribe: {
            exacts: [],
            words: ["newsletter", "subscribe"],
        },
        favorites: {
            exacts: [],
            words: ["wishlist", "favorite", "heart"],
        },
        enlarge: {
            exacts: [],
            words: ["zoom", "large", "big"],
        },
        print: {
            exacts: [],
            words: ["print"],
        },
        plus: {
            exacts: ["+"],
            words: ["plus", "inc", "touchspin-up"],
        },
        minus: {
            exacts: ["-"],
            words: ["min", "dec", "decrease", "reduce", "touchspin-down"],
        },
        video: {
            exacts: [],
            words: ["video", "play", "youtube", "vimeo"],
        },
        color: {
            exacts: [],
            words: ["color", "colour", "swatch", "palette"],
        },
        pause: {
            exacts: [],
            words: ["pause", "stop", "halt", "hold"],
        },
        country: {
            exacts: [],
            words: ["flag", "lang", "country", "usa", "english"],
        },
        scroll: {
            exacts: [],
            words: ["scroll", "up", "top"],
        },
        submit: {
            exacts: ["continue"],
            words: ["submit", "send", "ok", "done", "enter", "confirm", "apply", "sign in"],
        },
        on: {
            exacts: [],
            words: ["on", "enable", "activate", "turn on", "switch on", "toggle on", "set on"],
        },
        off: {
            exacts: [],
            words: ["off", "disable", "deactivate", "turn off", "switch off", "toggle off", "set off"],
        },
        activate: {
            exacts: [],
            words: ["activate", "enable", "turn on", "switch on", "toggle on", "set on"],
        },
        deactivate: {
            exacts: [],
            words: ["deactivate", "disable", "turn off", "switch off", "toggle off", "set off"],
        },
        enable: {
            exacts: [],
            words: ["enable", "activate", "turn on", "switch on", "toggle on", "set on"],
        },
        disable: {
            exacts: [],
            words: ["disable", "deactivate", "turn off", "switch off", "toggle off", "set off"],
        },
        active: {
            exacts: [],
            words: ["active", "enabled", "on", "activated", "switched on", "toggled on", "set on"],
        },
    };
    // words to ignore
    const IGNORED_WORDS = ["menuitem", "shopping", "desktop", "tabindex", "backup", "holder", "group", "setup", "topic", "stop", "index", "closed", "bind", "binary", "binge", "left:", "right:", "popup", "upload", "prevent", "display", "player"];

    var dist = {exports: {}};

    var hasRequiredDist;

    function requireDist () {
    	if (hasRequiredDist) return dist.exports;
    	hasRequiredDist = 1;
    	(function (module, exports) {
    		!function(e,a){module.exports=a();}(commonjsGlobal,(()=>(()=>{var e={72:(e,a,r)=>{Object.defineProperty(a,"__esModule",{value:!0}),a.textContainsString=function(e,a,r=(0, i.getLocales)()){if(!e)return !1;const t=n.dictionary[a];if(!t)return console.error(`Key does not exist in the dictionary. [key: ${a}]`),!1;const s=e.toLowerCase();return r.some((e=>function(e,a,r){const n=a[r];return Array.isArray(n)&&n.some((a=>e.includes(a.toLowerCase())))}(s,t,e)))};const n=r(565),i=r(283);},86:(e,a,r)=>{Object.defineProperty(a,"__esModule",{value:!0}),a.textContainsWords=function(e,a){return a.some((a=>(0, n.textContainsWord)(e,a)))};const n=r(245);},156:function(e,a,r){var n=this&&this.__createBinding||(Object.create?function(e,a,r,n){void 0===n&&(n=r);var i=Object.getOwnPropertyDescriptor(a,r);i&&!("get"in i?!a.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return a[r]}}),Object.defineProperty(e,n,i);}:function(e,a,r,n){void 0===n&&(n=r),e[n]=a[r];}),i=this&&this.__exportStar||function(e,a){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(a,r)||n(a,e,r);};Object.defineProperty(a,"__esModule",{value:!0}),i(r(266),a),i(r(283),a),i(r(993),a),i(r(565),a),i(r(574),a);},183:(e,a,r)=>{Object.defineProperty(a,"__esModule",{value:!0}),a.preprocessText=function(e,a){if(n.linkingLetters[a]){const r=n.linkingLetters[a].reduce(((e,r,i)=>(e+=`(^${r}|${r}$)`,i<n.linkingLetters[a].length-1&&(e+="|"),e)),""),i=new RegExp(r,"gi");return e.split(/\s+/).map((e=>e.replace(i,""))).join(" ").toLowerCase()}return e.toLowerCase()};const n=r(993);},245:(e,a,r)=>{Object.defineProperty(a,"__esModule",{value:!0}),a.textContainsWord=function(e,a,r=(0, s.getLocales)()){if(!e)return !1;const o=n.dictionary[a];return o?r.some((a=>function(e,a,r){const n=a[r];if(!n||!Array.isArray(n))return !1;const s=(0, i.preprocessText)(e.toLowerCase(),r);return n.some((e=>{const a=(0, i.preprocessText)(e,r);return (0, t.findPattern)(s,a,r)}))}(e,o,a))):(console.error(`Key does not exist in the dictionary. [key: ${a}]`),!1)};const n=r(565),i=r(183),t=r(695),s=r(283);},266:(e,a,r)=>{Object.defineProperty(a,"__esModule",{value:!0}),a.wordHasTranslation=a.textContainsWords=a.textContainsWord=a.textContainsString=a.preprocessText=a.getTextToDictionaryEntry=a.findPattern=void 0;var n=r(695);Object.defineProperty(a,"findPattern",{enumerable:!0,get:function(){return n.findPattern}});var i=r(527);Object.defineProperty(a,"getTextToDictionaryEntry",{enumerable:!0,get:function(){return i.getTextToDictionaryEntry}});var t=r(183);Object.defineProperty(a,"preprocessText",{enumerable:!0,get:function(){return t.preprocessText}});var s=r(72);Object.defineProperty(a,"textContainsString",{enumerable:!0,get:function(){return s.textContainsString}});var o=r(245);Object.defineProperty(a,"textContainsWord",{enumerable:!0,get:function(){return o.textContainsWord}});var l=r(86);Object.defineProperty(a,"textContainsWords",{enumerable:!0,get:function(){return l.textContainsWords}});var u=r(312);Object.defineProperty(a,"wordHasTranslation",{enumerable:!0,get:function(){return u.wordHasTranslation}});},283:(e,a,r)=>{Object.defineProperty(a,"__esModule",{value:!0}),a.addLocale=function(e){n.LocaleEnum[e]?i.includes(e)||i.unshift(e):console.error(`Locale does not exist in the dictionary. [locale: ${e}]`);},a.getLocales=function(){return i.slice()};const n=r(574),i=["en"];},312:(e,a,r)=>{Object.defineProperty(a,"__esModule",{value:!0}),a.wordHasTranslation=function(e){return Boolean(n.dictionary[e])};const n=r(565);},527:(e,a,r)=>{Object.defineProperty(a,"__esModule",{value:!0}),a.getTextToDictionaryEntry=function(e,a,...r){if(!n.dictionary[a])throw new Error(`Key does not exist in the dictionary. [key: ${a}]`);const t=n.dictionary[a][e]?.[0];if(!t)throw new Error(`Missing translation for key '${a}' in locale '${e}'`);return i(t,...r)},a.replacePlaceHolders=i;const n=r(565);function i(e,...a){for(const[r,n]of a.entries())e=e.replaceAll(`$${r+1}`,n);return e}},565:(e,a)=>{Object.defineProperty(a,"__esModule",{value:!0}),a.dictionary=void 0,a.dictionary={breadcrumb:{en:["Breadcrumb"],"en-GB":["Breadcrumb"],"en-CA":["Breadcrumb"],he:["פירור לחם"],ar:["فتات الخبز"],de:["brotkrume"],fr:["fil d'ariane"],it:["percorso di navigazione"],es:["migaja de pan"],ja:["パンくずリスト"],nl:["broodkruimel"],pt:["migalha de pão"],pl:["okruszek"],ru:["навигационная крошка"],tw:["麵包屑"],tr:["kırıntı"],ua:["хлібна крихта"],zh:["面包屑"],sl:["drobna pot"],sk:["omrvinka"],hu:["kenyérmorzsa"],cs:["drobeček"],sv:["brödsmula"],no:["brødsmule"],fi:["leivänmuru"],uk:["хлібна крихта"],ro:["firimitură de pâine"],ga:["blúire aráin"],el:["ψίχουλο ψωμιού"],sr:["хлебна мрвица"],bs:["mrva hljeba"],hr:["mrva kruha"],lb:["Broutkrümmel"],sq:["thërrime buke"],da:["brødkrumme"]},breadcrumbs:{en:["Breadcrumbs"],"en-GB":["Breadcrumbs"],"en-CA":["Breadcrumbs"],he:["פירורי לחם"],ar:["فتات الخبز"],de:["brotkrumen"],fr:["fils d'ariane","fil d’Ariane"],it:["percorsi di navigazione","briciole di pane"],es:["Migas de pan","migajas de pan"],ja:["パン粉"],nl:["broodkruimels"],pt:["migalhas de pão"],pl:["okruszki","okruszki nawigacyjne"],ru:["хлебные крошки","навигационные крошки"],tw:["麵包屑"],tr:["Ekmek kırıntıları"],ua:["Хлібні крихти"],zh:["面包屑","面包屑导航"],sl:["drobtinice","drobtine"],sk:["drobčeková navigácia"],hu:["Morzsák"],cs:["drobečková navigace"],sv:["brödsmulor"],no:["brødsmuler"],fi:["leivänmurut"],uk:["хлібні крихти"],ro:["firimituri de pâine"],ga:["blúiríní aráin"],el:["ψίχουλα ψωμιού"],sr:["хлебне мрвице","Mrvice hleba"],bs:["mrvice hljeba"],hr:["mrvice kruha"],lb:["Broutkrummwee","Broutkrümmelen"],sq:["thërrime buke"],da:["brødkrummer"]},rating:{en:["rating"],"en-GB":["rating"],"en-CA":["rating"],he:["דירוג"],ar:["تقييم"],de:["Bewertung"],fr:["évaluation"],it:["valutazione"],es:["calificación"],ja:["評価"],nl:["beoordeling"],pt:["classificação"],pl:["ocena"],ru:["рейтинг"],tw:["評分"],tr:["derecelendirme"],ua:["рейтинг"],zh:["评分"],sl:["ocena"],sk:["hodnotenie"],hu:["értékelés"],cs:["hodnocení"],sv:["betyg"],no:["vurdering"],fi:["arvostelu"],uk:["рейтинг"],ro:["evaluare"],ga:["ráta"],el:["βαθμολογία"],sr:["оцена"],bs:["ocjena"],hr:["ocjena"],lb:["Bewäertung"],sq:["vlerësim"],da:["bedømmelse"]},rated:{en:["rated"],"en-GB":["rated"],"en-CA":["rated"],he:["דורג"],ar:["مصنف"],de:["bewertet"],fr:["noté"],it:["valutato"],es:["calificado"],ja:["評価された"],nl:["beoordeeld"],pt:["classificado"],pl:["oceniony"],ru:["оцененный"],tw:["評分"],tr:["derecelendirilmiş"],ua:["оцінений"],zh:["评分"],sl:["ocenjen"],sk:["hodnotený"],hu:["értékelt"],cs:["hodnocený"],sv:["betygsatt"],no:["vurdert"],fi:["arvioitu"],uk:["оцінений"],ro:["evaluat"],ga:["ráta"],el:["αξιολογημένο"],sr:["оцењен"],bs:["ocijenjen"],hr:["ocijenjen"],lb:["bewäert"],sq:["vlerësuar"],da:["bedømt"]},rate:{en:["rate"],"en-GB":["rate"],"en-CA":["rate"],he:["לדרג"],ar:["قيم"],de:["bewerten"],fr:["évaluer"],it:["valutare"],es:["calificar"],ja:["評価する"],nl:["beoordelen"],pt:["classificar"],pl:["oceniać"],ru:["оценивать"],tw:["評分"],tr:["derecelendirmek"],ua:["оцінювати"],zh:["评价"],sl:["oceniti"],sk:["hodnotiť"],hu:["értékelni"],cs:["hodnotit"],sv:["betygsätta"],no:["vurdere"],fi:["arvioida"],uk:["оцінювати"],ro:["evalua"],ga:["ráta a thabhairt"],el:["αξιολογώ"],sr:["оценити"],bs:["ocijeniti"],hr:["ocijeniti"],lb:["bewäerten"],sq:["vlerësoj"],da:["vurdere"]},close:{en:["Close"],"en-GB":["Close"],"en-CA":["Close"],he:["סגור"],ar:["إغلاق","اغلق"],de:["Schließen"],fr:["Fermer"],it:["Chiudi"],es:["Cerrar"],ja:["閉じる"],nl:["Sluiten","Dichtbij"],pt:["Fechar"],pl:["Zamknij","Blisko"],ru:["Закрыть"],tw:["關閉"],tr:["Kapat"],ua:["Закрити"],zh:["关闭"],sl:["Zapri"],sk:["Zavrieť"],hu:["Bezárás","Bezár"],cs:["Zavřít","Zavření"],sv:["Stänga","Stäng"],no:["Lukk","Lukke"],fi:["Sulje","Sulkeminen"],uk:["Закрити","Закриття"],ro:["Închideți","Închidere","Închide"],ga:["Dún","Dúnadh"],el:["Κλείσιμο","Κλείστε"],sr:["затворити","затварање","Zatvori"],bs:["zatvoriti","zatvaranje","Zatvori"],hr:["zatvoriti","zatvaranje","Zatvori"],lb:["Ofschléissen","Ofschléisse","Zoumaachen"],sq:["Mbyllni","Mbyllja","Mbyll"],da:["Luk","Lukke"]},"out of":{en:["out of"],"en-GB":["out of"],"en-CA":["out of"],he:["מתוך"],ar:["من أصل"],de:["von"],fr:["sur"],it:["su"],es:["de"],ja:["中の"],nl:["van"],pt:["de"],pl:["z"],ru:["из"],tw:["中"],tr:["den"],ua:["з"],zh:["出于"],sl:["od"],sk:["z"],hu:["ki"],cs:["z"],sv:["av"],no:["av"],fi:["ulos"],uk:["з"],ro:["din"],ga:["as"],el:["από"],sr:["од"],bs:["od"],hr:["od"],lb:["aus"],sq:["nga"],da:["ud af"]},score:{en:["Score"],"en-GB":["Score"],"en-CA":["Score"],he:["ציון"],ar:["درجة"],de:["Punktzahl"],fr:["score"],it:["punteggio"],es:["puntuación"],ja:["スコア"],nl:["score"],pt:["pontuação"],pl:["wynik"],ru:["счет"],tw:["得分"],tr:["puan"],ua:["рахунок"],zh:["得分"],sl:["rezultat"],sk:["skóre"],hu:["pontszám"],cs:["skóre"],sv:["poäng"],no:["poeng"],fi:["pisteet"],uk:["рахунок"],ro:["scor"],ga:["scór"],el:["βαθμολογία"],sr:["резултат"],bs:["rezultat"],hr:["rezultat"],lb:["Punktzuel"],sq:["rezultati"],da:["score"]},scored:{en:["scored"],"en-GB":["scored"],"en-CA":["scored"],he:["ניקד"],ar:["مسجل"],de:["erzielt"],fr:["noté"],it:["segnato"],es:["puntuado"],ja:["スコアされた"],nl:["gescoord"],pt:["pontuado"],pl:["oceniony"],ru:["забитый"],tw:["得分"],tr:["puan aldı"],ua:["забитий"],zh:["得分"],sl:["zadel"],sk:["zaznamenaný"],hu:["pontozott"],cs:["skóroval"],sv:["gjorde mål"],no:["scoret"],fi:["tehnyt maalin"],uk:["забитий"],ro:["marcat"],ga:["scóráilte"],el:["βαθμολογημένος"],sr:["постигао"],bs:["postigao"],hr:["postigao"],lb:["gescorët"],sq:["shënuar"],da:["scoret"]},carousel:{en:["carousel"],"en-GB":["carousel"],"en-CA":["carousel"],he:["קרוסלה"],ar:["دور","دوار","دائري","عارض شرائح","دوّارة"],de:["Karussell"],fr:["carrousel"],it:["carosello"],es:["carrusel"],ja:["カルーセル"],nl:["carrousel"],pt:["carrossel"],pl:["karuzela"],ru:["карусель"],tw:["輪播","旋轉木馬"],tr:["dönme","karusel","karousel"],ua:["карусель"],zh:["旋转木马"],sl:["vrtiljak"],sk:["kolotoč"],hu:["körhinta","Karusell"],cs:["kolotoč"],sv:["karusell"],no:["karusell"],fi:["karuselli"],uk:["карусель"],ro:["carusel"],ga:["cairéal","Carasal"],el:["καρουζέλ"],sr:["вртуљак","Vrteška"],bs:["vrtić","Vrteška"],hr:["vrtuljak","Vrteška"],lb:["Karussell"],sq:["karusel"],da:["karrusel"]},slideshow:{en:["slideshow"],"en-GB":["slideshow"],"en-CA":["slideshow"],he:["מצגת"],ar:["عرض الشرائح"],de:["Diashow"],fr:["diaporama"],it:["diapositiva"],es:["presentación"],ja:["スライドショー"],nl:["diavoorstelling"],pt:["apresentação de slides"],pl:["pokaz slajdów"],ru:["слайд-шоу"],tw:["幻燈片"],tr:["slayt gösterisi"],ua:["слайд-шоу"],zh:["幻灯片"],sl:["diaprojekcija"],sk:["prezentácia"],hu:["diavetítés"],cs:["prezentace"],sv:["bildspel"],no:["lysbildefremvisning"],fi:["diaesitys"],uk:["слайд-шоу"],ro:["prezentare de diapozitive"],ga:["taispeántas sleamhnán"],el:["παρουσίαση διαφανειών"],sr:["слајд шоу"],bs:["slajdovi"],hr:["prezentacija"],lb:["Diashow"],sq:["prezantim me slajde"],da:["diasshow"]},rotator:{en:["rotator"],"en-GB":["rotator"],"en-CA":["rotator"],he:["רוטטור"],ar:["دوار"],de:["Rotator"],fr:["rotateur"],it:["rotatore"],es:["rotador"],ja:["ローテーター"],nl:["rotator"],pt:["rotador"],pl:["rotator"],ru:["ротатор"],tw:["轉子"],tr:["döndürücü"],ua:["ротатор"],zh:["旋转器"],sl:["rotator"],sk:["rotátor"],hu:["forgató"],cs:["rotátor"],sv:["rotator"],no:["rotator"],fi:["pyörijä"],uk:["ротатор"],ro:["rotator"],ga:["rothlóir"],el:["περιστρεφόμενος"],sr:["ротациони"],bs:["rotator"],hr:["rotator"],lb:["Rotator"],sq:["rrotullues"],da:["rotator"]},next:{en:["next"],"en-GB":["next"],"en-CA":["next"],he:["הבא"],ar:["التالي"],de:["nächster"],fr:["suivant"],it:["prossimo"],es:["siguiente"],ja:["次"],nl:["volgende"],pt:["próximo"],pl:["następny"],ru:["следующий"],tw:["下一個"],tr:["sonraki"],ua:["наступний"],zh:["下一个"],sl:["naslednji"],sk:["ďalší"],hu:["következő"],cs:["další"],sv:["nästa"],no:["neste"],fi:["seuraava"],uk:["наступний"],ro:["următor"],ga:["eile"],el:["επόμενος"],sr:["следећи"],bs:["sljedeći"],hr:["sljedeći"],lb:["nächst"],sq:["tjetër"],da:["næste"]},prev:{en:["prev"],"en-GB":["prev"],"en-CA":["prev"],he:["הקודם"],ar:["السابق"],de:["vorherige"],fr:["précédent"],it:["precedente"],es:["anterior"],ja:["前"],nl:["vorige"],pt:["anterior"],pl:["poprzedni"],ru:["предыдущий"],tw:["上一個"],tr:["önceki"],ua:["попередній"],zh:["上一个"],sl:["prejšnji"],sk:["predchádzajúci"],hu:["előző"],cs:["předchozí"],sv:["föregående"],no:["forrige"],fi:["edellinen"],uk:["попередній"],ro:["anterior"],ga:["roimhe seo"],el:["προηγούμενο"],sr:["претходни"],bs:["prethodni"],hr:["prethodni"],lb:["virdrun"],sq:["e mëparshme"],da:["forrige"]},previous:{en:["previous"],"en-GB":["previous"],"en-CA":["previous"],he:["הקודם"],ar:["السابق"],de:["vorherige"],fr:["précédent"],it:["precedente"],es:["anterior"],ja:["前"],nl:["vorige"],pt:["anterior"],pl:["poprzedni"],ru:["предыдущий"],tw:["上一個"],tr:["önceki"],ua:["попередній"],zh:["上一个"],sl:["prejšnji"],sk:["predchádzajúci"],hu:["előző"],cs:["předchozí"],sv:["tidigare"],no:["tidligere"],fi:["edellinen"],uk:["попередній"],ro:["anterior"],ga:["roimhe seo"],el:["προηγούμενος"],sr:["претходни"],bs:["prethodni"],hr:["prethodni"],lb:["virdrun"],sq:["e mëparshme"],da:["tidligere"]},slide:{en:["slide"],"en-GB":["slide"],"en-CA":["slide"],he:["שקופית"],ar:["شريحة"],de:["Folie"],fr:["diapositive"],it:["diapositiva"],es:["diapositiva"],ja:["スライド"],nl:["dia"],pt:["slide"],pl:["slajd"],ru:["слайд"],tw:["幻燈片"],tr:["slayt"],ua:["слайд"],zh:["幻灯片"],sl:["diapozitiv"],sk:["snímka"],hu:["diavetítés"],cs:["snímek"],sv:["bildspel"],no:["lysbilde"],fi:["dia"],uk:["слайд"],ro:["diapozitiv"],ga:["sleamhnán"],el:["διαφάνεια"],sr:["слајд"],bs:["slajd"],hr:["slajd"],lb:["Folie"],sq:["slaid"],da:["slide"]},search:{en:["search"],"en-GB":["search"],"en-CA":["search"],he:["חיפוש","חפש","חפשי","חפשו"],ar:["بحث"],de:["Suche"],fr:["recherche","rechercher"],it:["ricerca"],es:["búsqueda"],ja:["検索"],nl:["zoeken"],pt:["pesquisa"],pl:["szukaj"],ru:["поиск"],tw:["搜尋"],tr:["arama"],ua:["пошук"],zh:["搜索"],sl:["iskanje"],sk:["vyhľadávanie"],hu:["keresés"],cs:["hledat"],sv:["sök"],no:["søk"],fi:["haku"],uk:["пошук"],ro:["căutare"],ga:["cuardach"],el:["αναζήτηση"],sr:["претрага"],bs:["pretraga"],hr:["pretraga"],lb:["Sich"],sq:["kërkim"],da:["søg"]},send:{en:["send"],"en-GB":["send"],"en-CA":["send"],he:["שלח"],ar:["إرسال"],de:["senden"],fr:["envoyer"],it:["invia"],es:["enviar"],ja:["送信"],nl:["verzenden"],pt:["enviar"],pl:["wyślij"],ru:["отправить"],tw:["發送"],tr:["göndermek"],ua:["надіслати"],zh:["发送"],sl:["pošlji"],sk:["poslať"],hu:["küld"],cs:["odeslat"],sv:["skicka"],no:["sende"],fi:["lähettää"],uk:["надіслати"],ro:["trimite"],ga:["seol"],el:["στείλε"],sr:["пошаљи"],bs:["pošalji"],hr:["pošalji"],lb:["schécken"],sq:["dërgo"],da:["send"]},register:{en:["register"],"en-GB":["register"],"en-CA":["register"],he:["הירשם","הרשמה","רישום"],ar:["تسجيل"],de:["registrieren"],fr:["enregistrer"],it:["registrati"],es:["registrarse"],ja:["登録"],nl:["registreren"],pt:["registrar"],pl:["zarejestrować"],ru:["зарегистрировать"],tw:["註冊"],tr:["kayıt ol"],ua:["зареєструвати"],zh:["注册"],sl:["registriraj"],sk:["registrovať"],hu:["regisztrál"],cs:["registrovat"],sv:["registrera"],no:["registrere"],fi:["rekisteröidy"],uk:["зареєструватися"],ro:["înregistrare"],ga:["cláraigh"],el:["εγγραφή"],sr:["региструј се"],bs:["registracija"],hr:["registracija"],lb:["registréieren"],sq:["regjistrohu"],da:["registrer"]},enter:{en:["enter"],"en-GB":["enter"],"en-CA":["enter"],he:["הכנס","כניסה"],ar:["ادخل"],de:["eingeben"],fr:["entrer"],it:["inserisci"],es:["entrar"],ja:["入力"],nl:["voer in"],pt:["entrar"],pl:["wprowadź"],ru:["войти"],tw:["輸入"],tr:["giriş"],ua:["ввести"],zh:["输入"],sl:["vnesi"],sk:["zadajte"],hu:["belép"],cs:["zadat"],sv:["ange"],no:["skriv inn"],fi:["syötä"],uk:["введіть"],ro:["introduceți"],ga:["iontráil"],el:["εισάγετε"],sr:["унеси"],bs:["unesi"],hr:["unesi"],lb:["androen"],sq:["futni"],da:["indtast"]},login:{en:["login"],"en-GB":["login"],"en-CA":["login"],he:["התחבר","התחברות"],ar:["تسجيل الدخول"],de:["anmelden"],fr:["connexion"],it:["accesso"],es:["inicio de sesión"],ja:["ログイン"],nl:["inloggen"],pt:["login"],pl:["zaloguj"],ru:["войти"],tw:["登錄"],tr:["giriş"],ua:["увійти"],zh:["登录"],sl:["prijavi se"],sk:["prihlásiť sa"],hu:["bejelentkezés"],cs:["přihlásit se"],sv:["logga in"],no:["logg inn"],fi:["kirjaudu sisään"],uk:["увійти"],ro:["autentificare"],ga:["logáil isteach"],el:["σύνδεση"],sr:["пријава"],bs:["prijava"],hr:["prijava"],lb:["umellen"],sq:["hyrje"],da:["log ind"]},submit:{en:["Submit"],"en-GB":["Submit"],"en-CA":["Submit"],he:["הגשת טופס"],ar:["خضع"],de:["Einreichen"],fr:["Soumettre"],it:["Sottoscrivi"],es:["Enviar"],ja:["参加する"],nl:["voorleggen"],pt:["Enviar"],pl:["Prześlij"],ru:["Отправить"],tw:["提交"],tr:["Gönder"],ua:["Надіслати"],zh:["提交"],sl:["Oddaj"],sk:["Odoslať"],hu:["Küldés"],cs:["Odeslat"],sv:["skicka in"],no:["send inn"],fi:["Lähetä"],uk:["Надіслати"],ro:["Trimite"],ga:["Cuir isteach"],el:["Υποβολή"],sr:["Пошаљи"],bs:["Pošalji"],hr:["Pošalji"],lb:["Aschécken","Ofschécken","ofgëtt","ofginn"],sq:["Dërgo","dërgojë","Dorëzo"],da:["Indsend"]},back:{en:["back"],"en-GB":["back"],"en-CA":["back"],he:["חזור"],ar:["رجوع"],de:["zurück"],fr:["retour"],it:["indietro"],es:["atrás"],ja:["バック"],nl:["terug"],pt:["voltar"],pl:["powrót"],ru:["назад"],tw:["返回"],tr:["geri"],ua:["назад"],zh:["返回"],sl:["nazaj"],sk:["späť"],hu:["vissza"],cs:["zpět"],sv:["tillbaka"],no:["tilbake"],fi:["takaisin"],uk:["назад"],ro:["înapoi"],ga:["ar ais"],el:["πίσω"],sr:["назад"],bs:["nazad"],hr:["nazad"],lb:["zréck"],sq:["mbrapa"],da:["tilbage"]},forward:{en:["forward"],"en-GB":["forward"],"en-CA":["forward"],he:["קדימה"],ar:["إلى الأمام"],de:["vorwärts"],fr:["avant"],it:["avanti"],es:["adelante"],ja:["前進"],nl:["vooruit"],pt:["para a frente"],pl:["do przodu"],ru:["вперед"],tw:["向前"],tr:["ileri"],ua:["вперед"],zh:["向前"],sl:["naprej"],sk:["vpred"],hu:["előre"],cs:["vpřed"],sv:["framåt"],no:["fremover"],fi:["eteenpäin"],uk:["вперед"],ro:["înainte"],ga:["ar aghaidh"],el:["μπροστά"],sr:["напред"],bs:["naprijed"],hr:["naprijed"],lb:["virun"],sq:["përpara"],da:["fremad"]},required:{en:["required"],"en-GB":["required"],"en-CA":["required"],he:["חובה"],ar:["إلزامي"],de:["Pflichtfeld"],fr:["obligatoire"],it:["obbligatorio"],es:["obligatorio"],ja:["必須"],nl:["verplicht"],pt:["obrigatório"],pl:["wymagane"],ru:["обязательно"],tw:["必填"],tr:["zorunlu"],ua:["обов'язково"],zh:["必填"],sl:["obvezno"],sk:["povinné"],hu:["kötelező"],cs:["povinné"],sv:["obligatoriskt"],no:["påkrevd"],fi:["pakollinen"],uk:["обов'язковий"],ro:["obligatoriu"],ga:["riachtanach"],el:["απαραίτητο"],sr:["обавезно"],bs:["obavezno"],hr:["obavezno"],lb:["obligatoresch"],sq:["e detyrueshme"],da:["påkrævet"]},optional:{en:["optional"],"en-GB":["optional"],"en-CA":["optional"],he:["בחירה"],ar:["اختياري"],de:["optional"],fr:["facultatif"],it:["facoltativo"],es:["opcional"],ja:["任意"],nl:["optioneel"],pt:["opcional"],pl:["opcjonalne"],ru:["необязательно"],tw:["選填"],tr:["isteğe bağlı"],ua:["необов'язково"],zh:["选填"],sl:["izbirno"],sk:["voliteľné"],hu:["választható"],cs:["volitelné"],sv:["valfritt"],no:["valgfritt"],fi:["valinnainen"],uk:["необов’язковий"],ro:["opțional"],ga:["roghnach"],el:["προαιρετικό"],sr:["опционо"],bs:["opciono"],hr:["opciono"],lb:["fakultativ"],sq:["opsionale"],da:["valgfri"]},new_window:{en:["New Window"],"en-GB":["New Window"],"en-CA":["New Window"],he:["חלון חדש"],ar:["نافذة جديدة"],de:["Neues Fenster"],fr:["Nouvelle fenêtre"],it:["Nuova finestra"],es:["Nueva Ventana"],ja:["新しいウィンドウ"],nl:["Nieuw venster"],pt:["Nova Janela"],pl:["Nowe Okno"],ru:["Новое окно"],tw:["新視窗"],tr:["Yeni Pencere"],ua:["Нове вікно"],zh:["新窗口"],sl:["Novo okno"],sk:["Nové okno"],hu:["Új ablak"],cs:["Nové okno"],sv:["Nytt fönster"],no:["Nytt vindu"],fi:["Uusi ikkuna"],uk:["Нове вікно"],ro:["Fereastră nouă"],ga:["Fuinneog nua"],el:["Νέο παράθυρο"],sr:["Нови прозор"],bs:["Novi prozor"],hr:["Novi prozor"],lb:["Neit Fënster","Neit Fenster"],sq:["Dritare e re"],da:["Nyt vindue"]},new_tab:{en:["New Tab"],"en-GB":["New Tab"],"en-CA":["New Tab"],he:["כרטיסייה חדשה"],ar:["علامة تبويب جديدة"],de:["Neuer Tab"],fr:["Nouvel onglet"],it:["Nuova scheda"],es:["Nueva pestaña"],ja:["新しいタブ"],nl:["Nieuw tabblad"],pt:["Nova Aba"],pl:["Nowa karta"],ru:["Новая вкладка"],tw:["新分頁"],tr:["Yeni Sekme"],ua:["Нова вкладка"],zh:["新标签页"],sl:["Nov zavihek"],sk:["Nová karta"],hu:["Új lap"],cs:["Nová karta"],sv:["Ny flik"],no:["Ny fane"],fi:["Uusi välilehti"],uk:["Нова вкладка"],ro:["Filă nouă"],ga:["Cluaisín nua"],el:["Νέα καρτέλα"],sr:["Нови таб"],bs:["Novi tab"],hr:["Novi tab"],lb:["Neien Tab"],sq:["Tab i ri"],da:["Ny fane"]},separate_window:{en:["Separate Window"],"en-GB":["Separate Window"],"en-CA":["Separate Window"],he:["חלון נפרד"],ar:["نافذة منفصلة"],de:["Separates Fenster"],fr:["Fenêtre séparée"],it:["Finestra separata"],es:["Ventana separada"],ja:["別ウィンドウ"],nl:["Apart venster"],pt:["Janela separada"],pl:["Osobne okno"],ru:["Отдельное окно"],tw:["分開視窗"],tr:["Ayrı Pencere"],ua:["Окреме вікно"],zh:["单独窗口"],sl:["Ločeno okno"],sk:["Samostatné okno"],hu:["Külön ablak"],cs:["Samostatné okno"],sv:["Separat fönster"],no:["Separat vindu"],fi:["Erillinen ikkuna"],uk:["Окреме вікно"],ro:["Fereastră separată"],ga:["Fuinneog scartha"],el:["Ξεχωριστό παράθυρο"],sr:["Посебан прозор"],bs:["Poseban prozor"],hr:["Poseban prozor"],lb:["Separat Fënster"],sq:["Dritare e veçuar"],da:["Separat vindue"]},separate_tab:{en:["Separate Tab"],"en-GB":["Separate Tab"],"en-CA":["Separate Tab"],he:["כרטיסייה נפרדת"],ar:["علامة تبويب منفصلة"],de:["Separater Tab"],fr:["Onglet séparé"],it:["Scheda separata"],es:["Pestaña separada"],ja:["別のタブ"],nl:["Apart tabblad"],pt:["Aba separada"],pl:["Osobna karta"],ru:["Отдельная вкладка"],tw:["分開分頁"],tr:["Ayrı Sekme"],ua:["Окрема вкладка"],zh:["单独标签页"],sl:["Ločen zavihek"],sk:["Samostatná karta"],hu:["Külön lap"],cs:["Samostatná karta"],sv:["Separat flik"],no:["Separat fane"],fi:["Erillinen välilehti"],uk:["Окрема вкладка"],ro:["Filă separată"],ga:["Cluaisín scartha"],el:["Ξεχωριστή καρτέλα"],sr:["Посебан таб"],bs:["Poseban tab"],hr:["Poseban tab"],lb:["Separaten Tab"],sq:["Tab i veçuar"],da:["Separat fane"]},navigation:{en:["Navigation"],"en-GB":["Navigation"],"en-CA":["Navigation"],he:["ניווט"],ar:["الملاحة"],de:["Navigation"],fr:["Navigation"],it:["Navigazione"],es:["Navegación"],ja:["ナビゲーション"],nl:["Navigatie"],pt:["Navegação"],pl:["Nawigacja"],ru:["Навигация"],tw:["導航"],tr:["Navigasyon"],ua:["Навігація"],zh:["导航"],sl:["Navigacija"],sk:["Navigácia"],hu:["Navigáció"],cs:["Navigace"],sv:["Navigering"],no:["Navigasjon"],fi:["Navigointi"],uk:["Навігація"],ro:["Navigare"],ga:["Nascleanúint"],el:["Πλοήγηση"],sr:["Навигација"],bs:["Navigacija"],hr:["Navigacija"],lb:["Navigatioun"],sq:["Navigim"],da:["Navigation"]},original_price:{en:["original price"],"en-GB":["original price"],"en-CA":["original price"],he:["מחיר מקורי"],ar:["السعر الأصلي"],de:["Originalpreis","Ursprünglicher Preis"],fr:["prix original","Prix d'origine"],it:["prezzo originale"],es:["precio original"],ja:["元の価格"],nl:["oorspronkelijke prijs"],pt:["preço original"],pl:["cena wyjściowa","Cena oryginalna"],ru:["оригинальная цена"],tw:["原價","原始價格"],tr:["orijinal fiyat"],ua:["оригінальна ціна"],zh:["原价"],sl:["izvirna cena","Originalna cena"],sk:["pôvodná cena"],hu:["eredeti ár"],cs:["původní cena"],sv:["ursprungligt pris"],no:["opprinnelig pris"],fi:["alkuperäinen hinta"],uk:["оригінальна ціна"],ro:["preț original"],ga:["praghas bunaidh"],el:["αρχική τιμή"],sr:["оригинална цена"],bs:["originalna cijena"],hr:["originalna cijena"],lb:["Original Präis"],sq:["çmimi origjinal"],da:["oprindelig pris","Original Pris"]},was:{en:["was"],"en-GB":["was"],"en-CA":["was"],he:["היה"],ar:["كان"],de:["war"],fr:["était"],it:["era"],es:["fue"],ja:["だった"],nl:["was"],pt:["era"],pl:["był"],ru:["был"],tw:["是"],tr:["oldu"],ua:["був"],zh:["是"],sl:["je bil"],sk:["bol"],hu:["volt"],cs:["byl"],sv:["var"],no:["var"],fi:["oli"],uk:["був"],ro:["a fost"],ga:["bhí"],el:["ήταν"],sr:["био"],bs:["bio"],hr:["bio"],lb:["war"],sq:["ishte"],da:["var"]},before:{en:["before"],"en-GB":["before"],"en-CA":["before"],he:["לפני"],ar:["قبل"],de:["vor"],fr:["avant"],it:["prima"],es:["antes"],ja:["前"],nl:["voor"],pt:["antes"],pl:["przed"],ru:["до"],tw:["之前"],tr:["önce"],ua:["до"],zh:["之前"],sl:["pred"],sk:["pred"],hu:["előtt"],cs:["před"],sv:["före"],no:["før"],fi:["ennen"],uk:["до"],ro:["înainte"],ga:["roimh"],el:["πριν"],sr:["пре"],bs:["prije"],hr:["prije"],lb:["virun"],sq:["para"],da:["før"]},old_price:{en:["old price"],"en-GB":["old price"],"en-CA":["old price"],he:["מחיר ישן"],ar:["السعر القديم"],de:["alter Preis"],fr:["ancien prix"],it:["vecchio prezzo"],es:["precio antiguo"],ja:["古い価格"],nl:["oude prijs"],pt:["preço antigo"],pl:["stara cena"],ru:["старая цена"],tw:["舊價"],tr:["eski fiyat"],ua:["стара ціна"],zh:["旧价"],sl:["stara cena"],sk:["stará cena"],hu:["régi ár"],cs:["stará cena"],sv:["gammalt pris"],no:["gammel pris"],fi:["vanha hinta"],uk:["стара ціна"],ro:["preț vechi"],ga:["seanphraghas"],el:["παλιά τιμή"],sr:["стара цена"],bs:["stara cijena"],hr:["stara cijena"],lb:["ale Präis"],sq:["çmimi i vjetër"],da:["gammel pris"]},previously:{en:["previously"],"en-GB":["previously"],"en-CA":["previously"],he:["בעבר"],ar:["سابقا"],de:["früher"],fr:["précédemment"],it:["precedentemente"],es:["previamente"],ja:["以前"],nl:["voorheen"],pt:["anteriormente"],pl:["poprzednio"],ru:["ранее"],tw:["以前"],tr:["daha önce"],ua:["раніше"],zh:["以前"],sl:["prej"],sk:["predtým"],hu:["korábban"],cs:["dříve"],sv:["tidigare"],no:["tidligere"],fi:["aiemmin"],uk:["раніше"],ro:["anterior"],ga:["roimhe seo"],el:["παλαιότερα"],sr:["раније"],bs:["ranije"],hr:["ranije"],lb:["fréier"],sq:["më parë"],da:["tidligere"]},formerly:{en:["formerly"],"en-GB":["formerly"],"en-CA":["formerly"],he:["בעבר"],ar:["سابقا"],de:["ehemals"],fr:["autrefois"],it:["precedentemente"],es:["anteriormente"],ja:["以前"],nl:["voorheen"],pt:["anteriormente"],pl:["poprzednio"],ru:["ранее"],tw:["以前"],tr:["daha önce"],ua:["раніше"],zh:["以前"],sl:["nekdanji"],sk:["predtým"],hu:["korábban"],cs:["dříve"],sv:["tidigare"],no:["tidligere"],fi:["aikaisemmin"],uk:["раніше"],ro:["anterior"],ga:["faoi láthair"],el:["προηγουμένως"],sr:["некада"],bs:["nekada"],hr:["nekada"],lb:["virdrun"],sq:["dikur"],da:["tidligere"]},reduced_from:{en:["reduced from"],"en-GB":["reduced from"],"en-CA":["reduced from"],he:["הופחת מ"],ar:["خفض من"],de:["reduziert von"],fr:["réduit de"],it:["ridotto da"],es:["reducido de"],ja:["から削減"],nl:["verlaagd van"],pt:["reduzido de"],pl:["zmniejszony z"],ru:["снижено с"],tw:["降價自"],tr:["indirildi"],ua:["знижено з"],zh:["降价自"],sl:["zmanjšano od"],sk:["znížené z"],hu:["csökkentett"],cs:["sníženo z"],sv:["sänkt från"],no:["redusert fra"],fi:["alentunut"],uk:["зменшено з"],ro:["redus de la"],ga:["laghdaigh ó"],el:["μειώθηκε από"],sr:["снижено са"],bs:["sniženo s"],hr:["sniženo s"],lb:["reduzéiert vun"],sq:["ulur nga"],da:["nedsat fra"]},discounted_from:{en:["discounted from"],"en-GB":["discounted from"],"en-CA":["discounted from"],he:["הוזל מ"],ar:["خصم من"],de:["rabattiert von"],fr:["rabais de"],it:["scontato da"],es:["descontado de"],ja:["から割引"],nl:["korting van"],pt:["descontado de"],pl:["przeceniony z"],ru:["скидка с"],tw:["折扣自"],tr:["indirimli"],ua:["знижка з"],zh:["折扣自"],sl:["popust od"],sk:["zľava z"],hu:["kedvezményes"],cs:["sleva z"],sv:["rabatterat från"],no:["rabattert fra"],fi:["alennettu"],uk:["зі знижкою з"],ro:["discount de la"],ga:["lascaine ó"],el:["έκπτωση από"],sr:["попуст са"],bs:["popust od"],hr:["popust od"],lb:["Rabatt vun"],sq:["zbritur nga"],da:["rabat fra"]},was_originally:{en:["was originally"],"en-GB":["was originally"],"en-CA":["was originally"],he:["היה במקור"],ar:["كان في الأصل"],de:["war ursprünglich"],fr:["était à l'origine"],it:["era originariamente"],es:["fue originalmente"],ja:["元々は"],nl:["was oorspronkelijk"],pt:["era originalmente"],pl:["był pierwotnie"],ru:["был изначально"],tw:["原本是"],tr:["aslen"],ua:["був спочатку"],zh:["原本是"],sl:["je bil prvotno"],sk:["bol pôvodne"],hu:["eredetileg"],cs:["byl původně"],sv:["var ursprungligen"],no:["var opprinnelig"],fi:["oli alun perin"],uk:["був спочатку"],ro:["a fost inițial"],ga:["bhí sé ar dtús"],el:["ήταν αρχικά"],sr:["првобитно је био"],bs:["izvorno je bio"],hr:["izvorno je bio"],lb:["war ursprénglech"],sq:["ishte fillimisht"],da:["var oprindeligt"]},last_sold_at:{en:["last sold at"],"en-GB":["last sold at"],"en-CA":["last sold at"],he:["נמכר לאחרונה ב"],ar:["بيع آخر في"],de:["zuletzt verkauft bei"],fr:["dernière vente à"],it:["ultimo venduto a"],es:["última venta en"],ja:["最後に販売された"],nl:["laatst verkocht bij"],pt:["última venda em"],pl:["ostatnio sprzedany w"],ru:["последняя продажа в"],tw:["最後售於"],tr:["son satıldı"],ua:["останній проданий в"],zh:["最后售于"],sl:["nazadnje prodano na"],sk:["naposledy predaný na"],hu:["utoljára eladva"],cs:["naposledy prodáno v"],sv:["senast såld för"],no:["sist solgt for"],fi:["viimeksi myyty hintaan"],uk:["останній раз продано за"],ro:["vândut ultima dată la"],ga:["díolta ar an bpraghas seo go deireanach"],el:["τελευταία πώληση σε"],sr:["последњи пут продато за"],bs:["zadnji put prodano na"],hr:["zadnji put prodano na"],lb:["Lescht verkaaft op"],sq:["shitur për herë të fundit me"],da:["sidst solgt til"]},marked_down_from:{en:["marked down from"],"en-GB":["marked down from"],"en-CA":["marked down from"],he:["הופחת מ"],ar:["خفض من"],de:["heruntergesetzt von"],fr:["marqué en baisse de"],it:["scontato da"],es:["rebajado de"],ja:["から値下げ"],nl:["afgeprijsd van"],pt:["reduzido de"],pl:["przeceniony z"],ru:["снижена с"],tw:["降價自"],tr:["indirimli"],ua:["знижено з"],zh:["降价自"],sl:["znižano od"],sk:["znížené z"],hu:["leértékelt"],cs:["sleva z"],sv:["nedsatt från"],no:["nedsatt fra"],fi:["alennettu hinnasta"],uk:["знижено з"],ro:["redus de la"],ga:["laghdaigh ó"],el:["μειωμένο από"],sr:["снижено са"],bs:["sniženo s"],hr:["sniženo s"],lb:["reduzéiert vun"],sq:["zbritur nga"],da:["nedsat fra"]},sale_from:{en:["sale from"],"en-GB":["sale from"],"en-CA":["sale from"],he:["מכירה מ"],ar:["بيع من"],de:["Verkauf von"],fr:["vente à partir de"],it:["vendita da"],es:["venta desde"],ja:["からの販売"],nl:["verkoop vanaf"],pt:["venda a partir de"],pl:["sprzedaż od"],ru:["продажа от"],tw:["特價自"],tr:["satış"],ua:["продаж від"],zh:["销售自"],sl:["prodaja od"],sk:["predaj od"],hu:["eladás"],cs:["prodej od"],sv:["försäljning från"],no:["salg fra"],fi:["myynti alkaen"],uk:["продаж від"],ro:["vânzare de la"],ga:["díolachán ó"],el:["πώληση από"],sr:["продаја од"],bs:["prodaja od"],hr:["prodaja od"],lb:["Verkaf vun"],sq:["shitje nga"],da:["salg fra"]},originally_priced_at:{en:["originally priced at"],"en-GB":["originally priced at"],"en-CA":["originally priced at"],he:["מחיר מקורי של"],ar:["السعر الأصلي هو"],de:["ursprünglich zum Preis von"],fr:["prix original à"],it:["prezzo originale a"],es:["precio original en"],ja:["元の価格は"],nl:["oorspronkelijk geprijsd op"],pt:["originalmente precificado em"],pl:["pierwotna cena to"],ru:["оригинальная цена"],tw:["原價為"],tr:["orijinal fiyatı"],ua:["оригінальна ціна"],zh:["原价为"],sl:["izvirna cena"],sk:["pôvodná cena"],hu:["eredeti ár"],cs:["původní cena"],sv:["ursprungligt pris"],no:["opprinnelig pris"],fi:["alkuperäinen hinta"],uk:["оригінальна ціна"],ro:["prețul original"],ga:["praghas bunaidh"],el:["αρχική τιμή"],sr:["оригинална цена"],bs:["originalna cijena"],hr:["originalna cijena"],lb:["Original Präis"],sq:["çmimi origjinal"],da:["oprindelig pris"]},pre_sale_price:{en:["pre-sale price"],"en-GB":["pre-sale price"],"en-CA":["pre-sale price"],he:["מחיר לפני המכירה"],ar:["السعر قبل البيع"],de:["Preis vor dem Verkauf"],fr:["prix avant vente"],it:["prezzo pre-vendita"],es:["precio antes de la venta"],ja:["販売前の価格"],nl:["prijs voor de verkoop"],pt:["preço pré-venda"],pl:["cena przed sprzedażą"],ru:["цена до продажи"],tw:["預售價"],tr:["ön satış fiyatı"],ua:["ціна до продажу"],zh:["预售价"],sl:["cena pred prodajo"],sk:["cena pred predajom"],hu:["elővételi ár"],cs:["cena před prodejem"],sv:["pris före försäljning"],no:["pris før salg"],fi:["ennen myyntiä hinta"],uk:["ціна до продажу"],ro:["preț înainte de vânzare"],ga:["praghas roimh an díolachán"],el:["τιμή πριν από την πώληση"],sr:["цена пре продаје"],bs:["cijena prije prodaje"],hr:["cijena prije prodaje"],lb:["Präis virum Verkaf"],sq:["çmimi para shitjes"],da:["pris før salg"]},previous_price:{en:["previous price"],"en-GB":["previous price"],"en-CA":["previous price"],he:["מחיר קודם"],ar:["السعر السابق"],de:["vorheriger Preis"],fr:["prix précédent"],it:["prezzo precedente"],es:["precio anterior"],ja:["前の価格"],nl:["vorige prijs"],pt:["preço anterior"],pl:["poprzednia cena"],ru:["предыдущая цена"],tw:["先前價格"],tr:["önceki fiyat"],ua:["попередня ціна"],zh:["先前价格"],sl:["prejšnja cena"],sk:["predchádzajúca cena"],hu:["előző ár"],cs:["předchozí cena"],sv:["föregående pris"],no:["tidligere pris"],fi:["edellinen hinta"],uk:["попередня ціна"],ro:["preț anterior"],ga:["praghas roimhe seo"],el:["προηγούμενη τιμή"],sr:["претходна цена"],bs:["prethodna cijena"],hr:["prethodna cijena"],lb:["viregte Präis"],sq:["çmimi i mëparshëm"],da:["tidligere pris"]},used_to_be:{en:["used to be"],"en-GB":["used to be"],"en-CA":["used to be"],he:["היה בעבר"],ar:["كان في السابق"],de:["früher"],fr:["était autrefois"],it:["era una volta"],es:["solía ser"],ja:["以前は"],nl:["was vroeger"],pt:["costumava ser"],pl:["kiedyś był"],ru:["был раньше"],tw:["過去是"],tr:["eskiden"],ua:["колись був"],zh:["过去是"],sl:["je bil"],sk:["bol"],hu:["volt"],cs:["býval"],sv:["brukade vara"],no:["pleide å være"],fi:["oli ennen"],uk:["колись був"],ro:["a fost"],ga:["bhíodh sé"],el:["ήταν κάποτε"],sr:["био је некад"],bs:["bio nekada"],hr:["bio nekada"],lb:["war fréier"],sq:["ishte dikur"],da:["var engang"]},right:{en:["right"],"en-GB":["right"],"en-CA":["right"],he:["ימין"],ar:["يمين"],de:["rechts"],fr:["droite"],it:["destra"],es:["derecha"],ja:["右"],nl:["rechts"],pt:["direita"],pl:["prawo"],ru:["право"],tw:["右"],tr:["sağ"],ua:["право"],zh:["右"],sl:["desno"],sk:["pravý"],hu:["jobb"],cs:["pravý"],sv:["höger"],no:["høyre"],fi:["oikea"],uk:["правий"],ro:["dreapta"],ga:["ar dheis"],el:["δεξιά"],sr:["десно"],bs:["desno"],hr:["desno"],lb:["riets"],sq:["djathtas"],da:["højre"]},left:{en:["left"],"en-GB":["left"],"en-CA":["left"],he:["שמאל"],ar:["يسار"],de:["links"],fr:["gauche"],it:["sinistra"],es:["izquierda"],ja:["左"],nl:["links"],pt:["esquerda"],pl:["lewo"],ru:["лево"],tw:["左"],tr:["sol"],ua:["ліво"],zh:["左"],sl:["levo"],sk:["ľavý"],hu:["bal"],cs:["levý"],sv:["vänster"],no:["venstre"],fi:["vasen"],uk:["лівий"],ro:["stânga"],ga:["ar chlé"],el:["αριστερά"],sr:["лево"],bs:["lijevo"],hr:["lijevo"],lb:["lénks"],sq:["majtas"],da:["venstre"]},opens_email:{en:["Opens Email"],"en-GB":["Opens Email"],"en-CA":["Opens Email"],he:["פותח אימייל"],ar:["يفتح البريد الإلكتروني"],de:["Öffnet E-Mail"],fr:["Ouvre l'e-mail"],it:["Apre e-mail"],es:["Abre correo"],ja:["メールを開きます"],nl:["Opent e-mail"],pt:["Abre e-mail"],pl:["Otwiera e-mail"],ru:["Открывает e-mail"],tw:["開啟電子郵件"],tr:["E-postayı açar"],ua:["Відкриває e-mail"],zh:["打开电子邮件"],sl:["Odpira e-pošto"],sk:["Otvára e-mail"],hu:["Megnyitja az e-mailt"],cs:["Otevírá e-mail"],sv:["Öppnar e-post"],no:["Åpner e-post"],fi:["Avaa sähköpostin"],uk:["відкриває e-mail"],ro:["Deschide e-mail"],ga:["Osclaíonn ríomhphost"],el:["Ανοίγει το email"],sr:["Отвара е-пошту"],bs:["Otvara e-mail"],hr:["Otvara e-mail"],lb:["Maacht E-Mail op"],sq:["Hap emailin"],da:["Åbner e-mail"]},composes_email:{en:["Composes Email"],"en-GB":["Composes Email"],"en-CA":["Composes Email"],he:["כותב אימייל"],ar:["يكتب البريد الإلكتروني"],de:["Verfasst E-Mail"],fr:["Rédige l'e-mail"],it:["Compone e-mail"],es:["Redacta correo"],ja:["メールを作成します"],nl:["Stelt e-mail op"],pt:["Redige e-mail"],pl:["Tworzy e-mail"],ru:["Создаёт e-mail"],tw:["撰寫電子郵件"],tr:["E-posta oluşturur"],ua:["Створює e-mail"],zh:["撰写电子邮件"],sl:["Sestavi e-pošto"],sk:["Píše e-mail"],hu:["E-mailt ír"],cs:["Sestavuje e-mail"],sv:["Skriver e-post"],no:["Skriver e-post"],fi:["Kirjoittaa sähköpostin"],uk:["пише e-mail"],ro:["Compune e-mail"],ga:["Cumann ríomhphost"],el:["Συνθέτει email"],sr:["Саставља е-пошту"],bs:["Piše e-mail"],hr:["Piše e-mail"],lb:["Schreift E-Mail"],sq:["Shkruan email"],da:["Skriver e-mail"]},launches_email:{en:["Launches Email"],"en-GB":["Launches Email"],"en-CA":["Launches Email"],he:["משגר אימייל"],ar:["يشغل البريد الإلكتروني"],de:["Startet E-Mail-Programm"],fr:["Lance l'e-mail"],it:["Lancia e-mail"],es:["Lanza correo"],ja:["メールを起動します"],nl:["Start e-mailprogramma"],pt:["Lança e-mail"],pl:["Uruchamia e-mail"],ru:["Запускает e-mail"],tw:["啟動電子郵件"],tr:["E-posta başlatılır"],ua:["Запускає e-mail"],zh:["启动电子邮件"],sl:["Zažene e-pošto"],sk:["Spúšťa e-mailový program"],hu:["Elindítja az e-mailt"],cs:["Spouští e-mail"],sv:["Startar e-post"],no:["Starter e-post"],fi:["Käynnistää sähköpostin"],uk:["запускає e-mail"],ro:["Lansează e-mail"],ga:["Seolann ríomhphost"],el:["Εκκινεί το email"],sr:["Покреће е-пошту"],bs:["Pokreće e-mail"],hr:["Pokreće e-mail"],lb:["Start E-Mail"],sq:["Nis emailin"],da:["Starter e-mail"]},opens_phone:{en:["Opens Phone"],"en-GB":["Opens Phone"],"en-CA":["Opens Phone"],he:["פותח טלפון"],ar:["يفتح الهاتف"],de:["Öffnet Telefon"],fr:["Ouvre le téléphone"],it:["Apre telefono"],es:["Abre el teléfono"],ja:["電話を開きます"],nl:["Opent telefoon"],pt:["Abre telefone"],pl:["Otwiera telefon"],ru:["Открывает телефон"],tw:["開啟電話"],tr:["Telefonu açar"],ua:["Відкриває телефон"],zh:["打开电话"],sl:["Odpira telefon"],sk:["Otvára telefón"],hu:["Megnyitja a telefont"],cs:["Otevírá telefon"],sv:["Öppnar telefonen"],no:["Åpner telefonen"],fi:["Avaa puhelimen"],uk:["відкриває телефон"],ro:["Deschide telefonul"],ga:["Osclaíonn an fón","Osclaíonn Fón"],el:["Ανοίγει το τηλέφωνο"],sr:["Отвара телефон"],bs:["Otvara telefon"],hr:["Otvara telefon"],lb:["Macht den Telefon op","Maacht Telefon op","Mécht Telefon op"],sq:["Hap telefonin"],da:["Åbner telefonen","Åbner telefon"]},opens_dialer:{en:["Opens Dialer"],"en-GB":["Opens Dialer"],"en-CA":["Opens Dialer"],he:["פותח חייגן"],ar:["يفتح لوحة الاتصال"],de:["Öffnet Wähltastatur"],fr:["Ouvre le composeur"],it:["Apre tastierino"],es:["Abre el marcador"],ja:["ダイヤルを開きます"],nl:["Opent kiezer"],pt:["Abre discador"],pl:["Otwiera dialer"],ru:["Открывает набор номера"],tw:["開啟撥號鍵盤"],tr:["Numara çeviriciyi açar"],ua:["Відкриває набірник"],zh:["打开拨号器"],sl:["Odpira klicalnik"],sk:["Otvára číselník"],hu:["Megnyitja a tárcsázót"],cs:["Otevírá číselník"],sv:["Öppnar uppringare"],no:["Åpner oppringer"],fi:["Avaa valitsimen"],uk:["відкриває набірник"],ro:["Deschide tastatura de apelare"],ga:["Osclaíonn dialer"],el:["Ανοίγει τον επιλογέα"],sr:["Отвара бројчаник"],bs:["Otvara biranik"],hr:["Otvara biranik"],lb:["Macht den Wieltastatur op"],sq:["Hap tastierin e telefonit"],da:["Åbner opkaldstastatur"]},opens_image:{en:["Opens an image"],"en-GB":["Opens an image"],"en-CA":["Opens an image"],he:["פותח תמונה"],ar:["يفتح صورة"],de:["Öffnet ein Bild"],fr:["Ouvre une image"],it:["Apre un'immagine"],es:["Abre una imagen"],ja:["画像を開きます"],nl:["Opent een afbeelding"],pt:["Abre uma imagem"],pl:["Otwiera obraz"],ru:["Открывает изображение"],tw:["開啟圖片"],tr:["Bir görüntü açar"],ua:["Відкриває зображення"],zh:["打开图片"],sl:["Odpira sliko"],sk:["Otvára obrázok"],hu:["Megnyit egy képet"],cs:["Otevírá obrázek"],sv:["Öppnar en bild"],no:["Åpner et bilde"],fi:["Avaa kuvan"],uk:["відкриває зображення"],ro:["Deschide o imagine"],ga:["Osclaíonn íomhá"],el:["Ανοίγει μια εικόνα"],sr:["Отвара слику"],bs:["Otvara sliku"],hr:["Otvara sliku"],lb:["Macht eng Bild op","Maacht e Bild op"],sq:["Hap një imazh"],da:["Åbner et billede"]},opens_pdf:{en:["Opens PDF"],"en-GB":["Opens PDF"],"en-CA":["Opens PDF"],he:["פותח PDF"],ar:["يفتح PDF","يفتح ملف PDF"],de:["Öffnet PDF"],fr:["Ouvre le PDF"],it:["Apre PDF","Apre il PDF"],es:["Abre PDF"],ja:["PDFを開きます"],nl:["Opent PDF"],pt:["Abre PDF"],pl:["Otwiera PDF"],ru:["Открывает PDF"],tw:["開啟 PDF","開啟PDF"],tr:["PDF'yi açar"],ua:["Відкриває PDF"],zh:["打开 PDF"],sl:["Odpira PDF"],sk:["Otvára PDF"],hu:["Megnyitja a PDF-et"],cs:["Otevírá PDF"],sv:["Öppnar PDF"],no:["Åpner PDF"],fi:["Avaa PDF"],uk:["відкриває PDF"],ro:["Deschide PDF"],ga:["Osclaíonn PDF"],el:["Ανοίγει το PDF","Ανοίγει PDF"],sr:["Отвара PDF"],bs:["Otvara PDF"],hr:["Otvara PDF"],lb:["Macht den PDF op","Maacht PDF op"],sq:["Hap PDF"],da:["Åbner PDF"]},downloads_pdf:{en:["Downloads PDF"],"en-GB":["Downloads PDF"],"en-CA":["Downloads PDF"],he:["מוריד PDF"],ar:["ينزل PDF"],de:["Lädt PDF herunter"],fr:["Télécharge le PDF"],it:["Scarica PDF"],es:["Descarga PDF"],ja:["PDFをダウンロードします"],nl:["Downloadt PDF"],pt:["Baixa PDF"],pl:["Pobiera PDF"],ru:["Скачивает PDF"],tw:["下載 PDF"],tr:["PDF'yi indirir"],ua:["Завантажує PDF"],zh:["下载 PDF"],sl:["Prenese PDF"],sk:["Sťahuje PDF"],hu:["Letölti a PDF-et"],cs:["Stahuje PDF"],sv:["Laddar ner PDF"],no:["Laster ned PDF"],fi:["Lataa PDF"],uk:["завантажує PDF"],ro:["Descarcă PDF"],ga:["Íoslódálann PDF"],el:["Κατεβάζει το PDF"],sr:["Преузима PDF"],bs:["Preuzima PDF"],hr:["Preuzima PDF"],lb:["Luet den PDF erof"],sq:["Shkarkon PDF"],da:["Downloader PDF"]},view_pdf:{en:["View PDF"],"en-GB":["View PDF"],"en-CA":["View PDF"],he:["צפה ב-PDF"],ar:["عرض PDF"],de:["PDF anzeigen"],fr:["Afficher le PDF"],it:["Visualizza PDF"],es:["Ver PDF"],ja:["PDFを表示"],nl:["Bekijk PDF"],pt:["Visualizar PDF"],pl:["Wyświetl PDF"],ru:["Просмотр PDF"],tw:["查看 PDF"],tr:["PDF'yi görüntüle"],ua:["Переглянути PDF"],zh:["查看 PDF"],sl:["Ogled PDF"],sk:["Zobraziť PDF"],hu:["PDF megtekintése"],cs:["Zobrazit PDF"],sv:["Visa PDF"],no:["Vis PDF"],fi:["Näytä PDF"],uk:["переглянути PDF"],ro:["Vizualizează PDF"],ga:["Amharc ar PDF"],el:["Προβολή PDF"],sr:["Прегледај PDF"],bs:["Pregledaj PDF"],hr:["Pregledaj PDF"],lb:["PDF uweisen"],sq:["Shiko PDF"],da:["Se PDF"]},home:{en:["Home"],"en-GB":["Home"],"en-CA":["Home"],he:["דף הבית"],ar:["الصفحة الرئيسية"],de:["Startseite"],fr:["Accueil"],it:["Home"],es:["Inicio"],ja:["ホーム"],nl:["Startpagina"],pt:["Página inicial"],pl:["Strona główna"],ru:["Главная"],tw:["首頁"],tr:["Ana Sayfa"],ua:["Головна"],zh:["主页"],sl:["Domača stran"],sk:["Domovská stránka"],hu:["Főoldal"],cs:["Domovská stránka"],sv:["Hem"],no:["Hjem"],fi:["Koti"],uk:["Головна"],ro:["Acasă"],ga:["Baile"],el:["Αρχική"],sr:["Почетна"],bs:["Početna"],hr:["Početna"],lb:["Haaptsäit"],sq:["Faqja kryesore"],da:["Hjem"]},homepage:{en:["Homepage"],"en-GB":["Homepage"],"en-CA":["Homepage"],he:["דף הבית"],ar:["الصفحة الرئيسية"],de:["Startseite"],fr:["Page d'accueil"],it:["Pagina iniziale"],es:["Página principal"],ja:["ホームページ"],nl:["Startpagina"],pt:["Página inicial"],pl:["Strona główna","stronę głównej","stronę główną"],ru:["Главная страница","главную страницу"],tw:["首頁"],tr:["Ana sayfa"],ua:["Головна сторінка","головну сторінку"],zh:["主页"],sl:["Domača stran","domačo stran"],sk:["Domovská stránka","domovskú stránku"],hu:["Főoldal"],cs:["Domovská stránka","domovskou stránku"],sv:["Hemsida"],no:["Hjemmeside"],fi:["Kotisivu"],uk:["Головна сторінка","головну сторінку"],ro:["Pagină principală"],ga:["Leathanach baile"],el:["Αρχική σελίδα"],sr:["Почетна страница"],bs:["Početna stranica","početnu stranicu"],hr:["Početna stranica","početnu stranicu"],lb:["Haaptsäit"],sq:["Faqja kryesore","Faqen kryesore"],da:["Hjemmeside"]},form:{en:["Form"],"en-GB":["Form"],"en-CA":["Form"],he:["טופס"],ar:["نموذج"],de:["Formular"],fr:["Formulaire"],it:["Modulo"],es:["Formulario"],ja:["フォーム"],nl:["Formulier"],pt:["Formulário"],pl:["Formularz"],ru:["Форма"],tw:["表單"],tr:["Form"],ua:["Форма"],zh:["表单"],sl:["Obrazec","obrazca"],sk:["Formulár"],hu:["Űrlap"],cs:["Formulář"],sv:["Formulär"],no:["Skjema"],fi:["Lomake","Lomaketta","Lomakkeen"],uk:["Форма"],ro:["Formular"],ga:["Foirm","fhoirm"],el:["Φόρμα"],sr:["Forma","obrazac"],bs:["Forma","obrazac"],hr:["obrasca","obrazac"],lb:["Formular"],sq:["Formular"],da:["Formular"]},submission:{en:["Submission"],"en-GB":["Submission"],"en-CA":["Submission"],he:["שליחה"],ar:["إرسال"],de:["Übermittlung"],fr:["Soumission"],it:["Invio"],es:["Envío"],ja:["送信"],nl:["indienen"],pt:["Envio"],pl:["Przesłanie"],ru:["Отправка"],tw:["提交"],tr:["Gönderme"],ua:["подання"],zh:["提交"],sl:["Pošiljanje"],sk:["Odoslanie"],hu:["Beküldés"],cs:["Odeslání"],sv:["Inlämning"],no:["Innsending"],fi:["lähetys"],uk:["подання"],ro:["Trimitere"],ga:["Seoladh"],el:["Υποβολή"],sr:["Slanje"],bs:["Slanje"],hr:["Slanje"],lb:["Ofschécken"],sq:["Dërgimi"],da:["Indsendelse"]},previous_slide:{en:["Previous Slide"],"en-GB":["Previous Slide"],"en-CA":["Previous Slide"],he:["שקופית קודמת"],ar:["الشريحة السابقة"],de:["Vorherige Folie"],fr:["Diapositive précédente"],it:["Diapositiva precedente"],es:["Diapositiva anterior"],ja:["前のスライド"],nl:["Vorige dia"],pt:["Slide anterior"],pl:["Poprzedni slajd"],ru:["Предыдущий слайд"],tw:["上一張投影片"],tr:["Önceki slayt"],ua:["Попередній слайд"],zh:["上一张幻灯片"],sl:["Prejšnji diapozitiv"],sk:["Predchádzajúci snímok"],hu:["Előző dia"],cs:["Předchozí snímek"],sv:["Föregående bild"],no:["Forrige lysbilde"],fi:["Edellinen dia"],uk:["Попередній слайд"],ro:["Diapozitiv anterior"],ga:["Sleamhnán Roimhe Seo"],el:["Προηγούμενη διαφάνεια"],sr:["Prethodni slajd"],bs:["Prethodni slajd"],hr:["Prethodni slajd"],lb:["Virdrun Rutsch"],sq:["Sllajdi i mëparshëm"],da:["Forrige dias"]},next_slide:{en:["Next Slide"],"en-GB":["Next Slide"],"en-CA":["Next Slide"],he:["שקופית הבאה"],ar:["الشريحة التالية"],de:["Nächste Folie"],fr:["Diapositive suivante"],it:["Prossima diapositiva"],es:["Siguiente diapositiva"],ja:["次のスライド"],nl:["Volgende dia"],pt:["Próximo slide"],pl:["Następny slajd"],ru:["Следующий слайд"],tw:["下一張幻燈片"],tr:["Sonraki slayt"],ua:["Наступний слайд"],zh:["下一张幻灯片"],sl:["Naslednji diapozitiv"],sk:["Ďalší snímok"],hu:["Következő dia"],cs:["Další snímek"],sv:["Nästa bild"],no:["Neste lysbilde"],fi:["Seuraava dia"],uk:["Наступний слайд"],ro:["Diapozitiv următor"],ga:["Sleamhnán Ar Aghaidh"],el:["Επόμενη διαφάνεια"],sr:["Sledeći slajd"],bs:["Sljedeći slajd"],hr:["Sljedeći slajd"],lb:["Nächst Folie"],sq:["Sllajdi i radhës"],da:["Næste dias"]},carouselSlidePicker:{en:["Carousel Slide Picker"],"en-GB":["Carousel Slide Picker"],"en-CA":["Carousel Slide Picker"],he:["בורר שקופיות קרוסלה"],ar:["محدد شريحة الدوار"],de:["Karussell-Schieber"],fr:["Sélecteur de diapositives de carrousel"],it:["Selettore"],es:["Selector de diapositivas de carrusel"],ja:["カルーセルスライドピッカー"],nl:["Carrousel dia keuze"],pt:["Selecionador de slides de carrossel"],pl:["Wybór slajdów karuzeli"],ru:["Выбор слайдов карусели"],tw:["輪播幻燈片選取器"],tr:["Karousel Slayt Seçici"],ua:["Вибір слайдів каруселі"],zh:["轮播幻灯片选择器"],sl:["Izbirnik diapozitivov karuzela"],sk:["Výber snímok karusel"],hu:["Karusell dia választó"],cs:["Výběr snímků karusel"],sv:["Karusellbildväljare"],no:["Karusellbildevelger"],fi:["Karusellin dian valitsin"],uk:["Вибір слайдів каруселі"],ro:["Selector de diapozitive carusel"],ga:["Roghnóir Sleamhnán Carasóil"],el:["Επιλογέας διαφανειών καρουζέλ"],sr:["Birač slajdova karusela"],bs:["Birač slajdova karusela"],hr:["Birač slajdova karusela"],lb:["Karussell-Dia-Wieler"],sq:["Përzgjedhës i diapozitivave të karuselit"],da:["Karussel diasvælger"]},subscribe:{en:["Subscribe"],"en-GB":["Subscribe"],"en-CA":["Subscribe"],he:["הירשם"],ar:["الاشتراك"],de:["Abonnieren"],fr:["S'abonner"],it:["Iscriviti"],es:["Suscribirse"],ja:["購読する"],nl:["Abonneren"],pt:["Inscrever-se"],pl:["Subskrybuj"],ru:["Подписаться"],tw:["訂閱"],tr:["Abone ol"],ua:["Підписатися"],zh:["订阅"],sl:["Naroči se"],sk:["Prihlásiť sa"],hu:["Feliratkozás"],cs:["Přihlásit se"],sv:["Prenumerera"],no:["Abonner"],fi:["Tilaa"],uk:["Підписатися"],ro:["Abonează-te"],ga:["Liostáil"],el:["Εγγραφή"],sr:["Pretplati se"],bs:["Pretplati se"],hr:["Pretplati se"],lb:["Abonnéieren"],sq:["Abonohu"],da:["Abonner"]},favorites:{en:["Favorites"],"en-GB":["Favourites"],"en-CA":["Favourites"],he:["מועדפים"],ar:["المفضلة"],de:["Favoriten"],fr:["Favoris"],it:["Preferiti"],es:["Favoritos"],ja:["お気に入り"],nl:["Favorieten"],pt:["Favoritos"],pl:["Ulubione"],ru:["Избранное"],tw:["收藏"],tr:["Favoriler"],ua:["Улюблені"],zh:["收藏夹"],sl:["Priljubljene"],sk:["Obľúbené"],hu:["Kedvencek"],cs:["Oblíbené"],sv:["Favoriter"],no:["Favoritter"],fi:["Suosikit"],uk:["Улюблені"],ro:["Favorite"],ga:["Favorites"],el:["Αγαπημένα"],sr:["Omiljeno"],bs:["Omiljeno"],hr:["Omiljeno"],lb:["Favoriten"],sq:["Të preferuarat"],da:["Favoritter"]},enlarge:{en:["Enlarge"],"en-GB":["Enlarge"],"en-CA":["Enlarge"],he:["הגדל"],ar:["تكبير"],de:["Vergrößern"],fr:["Agrandir"],it:["Ingrandire"],es:["Ampliar"],ja:["拡大する"],nl:["Vergroten"],pt:["Ampliar"],pl:["Powiększ"],ru:["Увеличить"],tw:["放大"],tr:["Büyüt"],ua:["Збільшити"],zh:["放大"],sl:["Povečaj"],sk:["Zväčšiť"],hu:["Nagyítás"],cs:["Zvětšit"],sv:["Förstora"],no:["Forstørr"],fi:["Suurenna"],uk:["Збільшити"],ro:["Mărește"],ga:["Méadú"],el:["Μεγέθυνση"],sr:["Uvećaj"],bs:["Uvećaj"],hr:["Uvećaj"],lb:["Vergréisseren"],sq:["Zmadho"],da:["Forstør"]},print:{en:["Print"],"en-GB":["Print"],"en-CA":["Print"],he:["הדפס"],ar:["طباعة"],de:["Drucken"],fr:["Imprimer"],it:["Stampa"],es:["Imprimir"],ja:["印刷する"],nl:["Afdrukken"],pt:["Imprimir"],pl:["Drukuj"],ru:["Печать"],tw:["打印"],tr:["Yazdır"],ua:["Друк"],zh:["打印"],sl:["Natisni"],sk:["Tlačiť"],hu:["Nyomtatás"],cs:["Tisk"],sv:["Skriv ut"],no:["Skriv ut"],fi:["Tulosta"],uk:["Друк"],ro:["Tipărește"],ga:["Priontáil"],el:["Εκτύπωση"],sr:["Štampaj"],bs:["Štampaj"],hr:["Ispis"],lb:["Drécken"],sq:["Printo"],da:["Udskriv"]},plus:{en:["Plus"],"en-GB":["Plus"],"en-CA":["Plus"],he:["פלוס"],ar:["زائد"],de:["Plus"],fr:["Plus"],it:["Più"],es:["Más"],ja:["プラス"],nl:["Plus"],pt:["Mais"],pl:["Plus"],ru:["Плюс"],tw:["加"],tr:["Artı"],ua:["Плюс"],zh:["加"],sl:["Plus"],sk:["Plus"],hu:["Plusz"],cs:["Plus"],sv:["Plus"],no:["Pluss"],fi:["Plus"],uk:["Плюс"],ro:["Plus"],ga:["Móide"],el:["Συν"],sr:["Plus"],bs:["Plus"],hr:["Plus"],lb:["Plus"],sq:["Më"],da:["Plus"]},minus:{en:["Minus"],"en-GB":["Minus"],"en-CA":["Minus"],he:["מינוס"],ar:["ناقص"],de:["Minus"],fr:["Moins"],it:["Meno"],es:["Menos"],ja:["マイナス"],nl:["Min"],pt:["Menos"],pl:["Minus"],ru:["Минус"],tw:["減"],tr:["Eksi"],ua:["Мінус"],zh:["减"],sl:["Minus"],sk:["Mínus"],hu:["Mínusz"],cs:["Minus"],sv:["Minus"],no:["Minus"],fi:["Miinus"],uk:["Мінус"],ro:["Minus"],ga:["Lúide"],el:["Μείον"],sr:["Minus"],bs:["Minus"],hr:["Minus"],lb:["Minus"],sq:["Më pak"],da:["Minus"]},video:{en:["Video"],"en-GB":["Video"],"en-CA":["Video"],he:["וידאו"],ar:["فيديو"],de:["Video"],fr:["Vidéo"],it:["Video"],es:["Vídeo"],ja:["ビデオ"],nl:["Video"],pt:["Vídeo"],pl:["Wideo"],ru:["Видео"],tw:["影片"],tr:["Video"],ua:["Відео"],zh:["视频"],sl:["Video"],sk:["Video"],hu:["Videó"],cs:["Video"],sv:["Video"],no:["Video"],fi:["Video"],uk:["Відео"],ro:["Video"],ga:["Físeán"],el:["Βίντεο"],sr:["Video"],bs:["Video"],hr:["Video"],lb:["Video"],sq:["Video"],da:["Video"]},color:{en:["Color"],"en-GB":["Colour"],"en-CA":["Colour"],he:["צבע"],ar:["لون"],de:["Farbe"],fr:["Couleur"],it:["Colore"],es:["Color"],ja:["色"],nl:["Kleur"],pt:["Cor"],pl:["Kolor"],ru:["Цвет"],tw:["顏色"],tr:["Renk"],ua:["Колір"],zh:["颜色"],sl:["Barva"],sk:["Farba"],hu:["Szín"],cs:["Barva"],sv:["Färg"],no:["Farge"],fi:["Väri"],uk:["Колір"],ro:["Culoare"],ga:["Dath"],el:["Χρώμα"],sr:["Boja"],bs:["Boja"],hr:["Boja"],lb:["Faarf"],sq:["Ngjyra"],da:["Farve"]},pause:{en:["Pause"],"en-GB":["Pause"],"en-CA":["Pause"],he:["השהה"],ar:["وقفة"],de:["Pause"],fr:["Pause"],it:["Pausa"],es:["Pausa"],ja:["一時停止"],nl:["Pauze"],pt:["Pausa"],pl:["Pauza"],ru:["Пауза"],tw:["暫停"],tr:["Duraklat"],ua:["Пауза"],zh:["暂停"],sl:["Premor"],sk:["Pauza"],hu:["Szünet"],cs:["Pauza"],sv:["Paus"],no:["Pause"],fi:["Tauko"],uk:["Пауза"],ro:["Pauză"],ga:["Sos"],el:["Παύση"],sr:["Pauza"],bs:["Pauza"],hr:["Pauza"],lb:["Paus"],sq:["Ndalo"],da:["Pause"]},country:{en:["Country"],"en-GB":["Country"],"en-CA":["Country"],he:["מדינה"],ar:["بلد"],de:["Land"],fr:["Pays"],it:["Paese"],es:["País"],ja:["国"],nl:["Land"],pt:["País"],pl:["Kraj"],ru:["Страна"],tw:["國家"],tr:["Ülke"],ua:["Країна"],zh:["国家"],sl:["Država"],sk:["Krajina"],hu:["Ország"],cs:["Země"],sv:["Land"],no:["Land"],fi:["Maa"],uk:["Країна"],ro:["Țară"],ga:["Tír"],el:["Χώρα"],sr:["Država"],bs:["Država"],hr:["Država"],lb:["Land"],sq:["Vendi"],da:["Land"]},scroll:{en:["Scroll"],"en-GB":["Scroll"],"en-CA":["Scroll"],he:["גלול"],ar:["التمرير"],de:["Scrollen"],fr:["Défiler"],it:["Scorrere"],es:["Desplazar"],ja:["スクロール"],nl:["Scrollen"],pt:["Rolar"],pl:["Przewiń"],ru:["Прокрутка"],tw:["滾動"],tr:["Kaydır"],ua:["Прокрутка"],zh:["滚动"],sl:["Pomakni"],sk:["Posunúť"],hu:["Görgetés"],cs:["Posun"],sv:["Skrolla"],no:["Bla"],fi:["Vieritä"],uk:["Прокрутка"],ro:["Derulează"],ga:["Scrolláil"],el:["Κύλιση"],sr:["Skroluj"],bs:["Skroluj"],hr:["Pomakni"],lb:["Scrollen"],sq:["Rrëshqit"],da:["Rul"]},recaptcha:{en:["reCAPTCHA"],"en-GB":["reCAPTCHA"],"en-CA":["reCAPTCHA"],he:["reCAPTCHA"],ar:["reCAPTCHA"],de:["reCAPTCHA"],fr:["reCAPTCHA"],it:["reCAPTCHA"],es:["reCAPTCHA"],ja:["reCAPTCHA"],nl:["reCAPTCHA"],pt:["reCAPTCHA"],pl:["reCAPTCHA"],ru:["reCAPTCHA"],tw:["reCAPTCHA"],tr:["reCAPTCHA"],ua:["reCAPTCHA"],zh:["reCAPTCHA"],sl:["reCAPTCHA"],sk:["reCAPTCHA"],hu:["reCAPTCHA"],cs:["reCAPTCHA"],sv:["reCAPTCHA"],no:["reCAPTCHA"],fi:["reCAPTCHA"],uk:["reCAPTCHA"],ro:["reCAPTCHA"],ga:["reCAPTCHA"],el:["reCAPTCHA"],sr:["reCAPTCHA"],bs:["reCAPTCHA"],hr:["reCAPTCHA"],lb:["reCAPTCHA"],sq:["reCAPTCHA"],da:["reCAPTCHA"]},hCaptcha:{en:["hCaptcha"],"en-GB":["hCaptcha"],"en-CA":["hCaptcha"],he:["hCaptcha"],ar:["hCaptcha"],de:["hCaptcha"],fr:["hCaptcha"],it:["hCaptcha"],es:["hCaptcha"],ja:["hCaptcha"],nl:["hCaptcha"],pt:["hCaptcha"],pl:["hCaptcha"],ru:["hCaptcha"],tw:["hCaptcha"],tr:["hCaptcha"],ua:["hCaptcha"],zh:["hCaptcha"],sl:["hCaptcha"],sk:["hCaptcha"],hu:["hCaptcha"],cs:["hCaptcha"],sv:["hCaptcha"],no:["hCaptcha"],fi:["hCaptcha"],uk:["hCaptcha"],ro:["hCaptcha"],ga:["hCaptcha"],el:["hCaptcha"],sr:["hCaptcha"],bs:["hCaptcha"],hr:["hCaptcha"],lb:["hCaptcha"],sq:["hCaptcha"],da:["hCaptcha"]},cfTurnstile:{en:["cfTurnstile"],"en-GB":["cfTurnstile"],"en-CA":["cfTurnstile"],he:["cfTurnstile"],ar:["cfTurnstile"],de:["cfTurnstile"],fr:["cfTurnstile"],it:["cfTurnstile"],es:["cfTurnstile"],ja:["cfTurnstile"],nl:["cfTurnstile"],pt:["cfTurnstile"],pl:["cfTurnstile"],ru:["cfTurnstile"],tw:["cfTurnstile"],tr:["cfTurnstile"],ua:["cfTurnstile"],zh:["cfTurnstile"],sl:["cfTurnstile"],sk:["cfTurnstile"],hu:["cfTurnstile"],cs:["cfTurnstile"],fi:["cfTurnstile"],uk:["cfTurnstile"],ro:["cfTurnstile"],ga:["cfTurnstile"],el:["cfTurnstile"],sr:["cfTurnstile"],bs:["cfTurnstile"],hr:["cfTurnstile"],lb:["cfTurnstile"],sq:["cfTurnstile"],da:["cfTurnstile"],sv:["cfTurnstile"],no:["cfTurnstile"]},friendlyCaptcha:{en:["friendlyCaptcha"],"en-GB":["friendlyCaptcha"],"en-CA":["friendlyCaptcha"],he:["friendlyCaptcha"],ar:["friendlyCaptcha"],de:["friendlyCaptcha"],fr:["friendlyCaptcha"],it:["friendlyCaptcha"],es:["friendlyCaptcha"],ja:["friendlyCaptcha"],nl:["friendlyCaptcha"],pt:["friendlyCaptcha"],pl:["friendlyCaptcha"],ru:["friendlyCaptcha"],tw:["friendlyCaptcha"],tr:["friendlyCaptcha"],ua:["friendlyCaptcha"],zh:["friendlyCaptcha"],sl:["friendlyCaptcha"],sk:["friendlyCaptcha"],hu:["friendlyCaptcha"],cs:["friendlyCaptcha"],fi:["friendlyCaptcha"],uk:["friendlyCaptcha"],ro:["friendlyCaptcha"],ga:["friendlyCaptcha"],el:["friendlyCaptcha"],sr:["friendlyCaptcha"],bs:["friendlyCaptcha"],hr:["friendlyCaptcha"],lb:["friendlyCaptcha"],sq:["friendlyCaptcha"],da:["friendlyCaptcha"],sv:["friendlyCaptcha"],no:["friendlyCaptcha"]},form_context_change_warning:{en:["Please note, filling out the following fields will automatically submit the form"],"en-GB":["Please note, filling out the following fields will automatically submit the form"],"en-CA":["Please note, filling out the following fields will automatically submit the form"],he:["שים לב, מילוי השדות הבאים יגרום לשליחת טופס באופן אוטומטי"],ar:["يرجى ملاحظة أن ملء الحقول التالية سيؤدي إلى إرسال النموذج تلقائيًا"],de:["Bitte beachten Sie, dass das Ausfüllen der folgenden Felder das Formular automatisch absendet"],fr:["Veuillez noter que le remplissage des champs suivants soumettra automatiquement le formulaire"],it:["Si prega di notare che la compilazione dei seguenti campi invierà automaticamente il modulo"],es:["Tenga en cuenta que completar los siguientes campos enviará automáticamente el formulario"],ja:["次のフィールドに入力すると、フォームが自動的に送信されることに注意してください"],nl:["Houd er rekening mee dat het invullen van de volgende velden het formulier automatisch indient"],pt:["Observe que o preenchimento dos seguintes campos enviará automaticamente o formulário"],pl:["Należy pamiętać, że wypełnienie następujących pól automatycznie wyśle formularz"],ru:["Обратите внимание, что заполнение следующих полей автоматически отправит форму"],tw:["請注意，填寫以下字段將自動提交表單"],tr:["Lütfen, aşağıdaki alanları doldurmanın formu otomatik olarak göndereceğini unutmayın"],ua:["Зверніть увагу, що заповнення наступних полів автоматично надішле форму"],zh:["请注意，填写以下字段将自动提交表单"],sl:["Upoštevajte, da bo izpolnitev naslednjih polj samodejno poslala obrazec"],sk:["Upozorňujeme, že vyplnenie nasledujúcich polí automaticky odošle formulár"],hu:["Kérjük, vegye figyelembe, hogy a következő mezők kitöltése automatikusan elküldi a űrlapot"],cs:["Vezměte prosím na vědomí, že vyplnění následujících polí automaticky odešle formulář"],sv:["Observera att om du fyller i följande fält skickas formuläret automatiskt"],no:["Vennligst merk at utfylling av feltene nedenfor automatisk sender inn skjemaet"],fi:["Huomaa, että seuraavien kenttien täyttäminen lähettää lomakkeen automaattisesti"],uk:["Зверніть увагу, що заповнення наступних полів автоматично надішле форму"],ro:["Vă rugăm să rețineți că completarea următoarelor câmpuri va trimite automat formularul"],ga:["Tabhair faoi deara, má líonann tú na réimsí seo a leanas, seolfaidh sé an foirm go huathoibríoch"],el:["Λάβετε υπόψη ότι η συμπλήρωση των παρακάτω πεδίων θα υποβάλει αυτόματα τη φόρμα"],sr:["Imajte na umu da popunjavanje sledećih polja automatski šalje obrazac"],bs:["Imajte na umu da popunjavanje sledećih polja automatski šalje obrazac"],hr:["Imajte na umu da popunjavanje sljedećih polja automatski šalje obrazac"],lb:["Ech wëll Iech wëssen, datt d'Fëllung vun de folgende Felder d'Formular automatesch ofgëtt"],sq:["Ju lutemi vini re se plotësimi i fushave të mëposhtme do të dërgojë automatikisht formularin"],da:["Bemærk venligst, at udfyldning af følgende felter automatisk sender formularen"]},carouselJumpToPage:{en:["Jump to page $1 of the carousel"],"en-GB":["Jump to page $1 of the carousel"],"en-CA":["Jump to page $1 of the carousel"],he:["עבור לעמוד $1 של הקרוסלה"],ar:["انتقل إلى الصفحة $1 من الدوّار"],de:["Gehe zu Seite $1 des Karussells"],fr:["Aller à la page $1 du carrousel"],it:["Vai alla pagina $1 del carosello"],es:["Ir à la página $1 del carrusel"],ja:["カルーセルのページ $1 に移動"],nl:["Ga naar pagina $1 van de carrousel"],pt:["Ir para a página $1 do carrossel"],pl:["Przejdź do strony $1 karuzeli"],ru:["Перейти на страницу $1 карусели"],tw:["跳到輪播的第 $1 頁"],tr:["Döngünün $1. sayfasına atla"],ua:["Перейти на сторінку $1 каруселі"],zh:["跳转到轮播的第 $1 页"],sl:["Pojdi na stran $1 vrtiljaka"],sk:["Prejsť na stránku $1 karuselu"],hu:["Ugrás a karusszel $1. oldalára"],cs:["Přejít na stránku $1 kolotoče"],sv:["Hoppa till sida $1 i karusellen"],no:["Hopp til side $1 i karusellen"],fi:["Siirry karusellin sivulle $1"],uk:["Перейти на сторінку $1 каруселі"],ro:["Mergi la pagina $1 a caruselului"],ga:["Léim go leathanach $1 den charaséal"],el:["Μετάβαση στη σελίδα $1 του καρουζέλ"],sr:["Idi na stranicu $1 karusela"],bs:["Idi na stranicu $1 karusela"],hr:["Idi na stranicu $1 karusela"],lb:["Géi op Säit $1 vum Karussell"],sq:["Kalo në faqen $1 të karuselit"],da:["Gå til side $1 i karrusellen"]},originalPrice:{en:["Original Price"],"en-GB":["Original Price"],"en-CA":["Original Price"],he:["מחיר מקורי"],ar:["السعر الأصلي"],de:["Ursprünglicher Preis"],fr:["Prix d'origine"],it:["Prezzo originale"],es:["Precio original"],ja:["元の価格"],nl:["Oorspronkelijke prijs"],pt:["Preço original"],pl:["Cena oryginalna"],ru:["Оригинальная цена"],tw:["原始價格"],tr:["Orijinal Fiyat"],ua:["Оригінальна ціна"],zh:["原价"],sl:["Originalna cena"],sk:["Pôvodná cena"],hu:["Eredeti ár"],cs:["Původní cena"],sv:["Ursprungligt pris"],no:["Opprinnelig pris"],fi:["Alkuperäinen hinta"],uk:["Оригінальна ціна"],ro:["Preț original"],ga:["Praghas Bunaidh"],el:["Αρχική τιμή"],sr:["Originalna cena"],bs:["Originalna cijena"],hr:["Originalna cijena"],lb:["Original Präis"],sq:["Çmimi origjinal"],da:["Original Pris"]},submenu:{en:["Submenu"],"en-GB":["Submenu"],"en-CA":["Submenu"],he:["תת-תפריט"],ar:["قائمة فرعية"],de:["Untermenü"],fr:["Sous-menu"],it:["Sottomenu"],es:["Submenú"],ja:["サブメニュー"],nl:["Submenu"],pt:["Submenu"],pl:["Podmenu"],ru:["Подменю"],tw:["子選單"],tr:["Alt menü"],ua:["Підменю"],zh:["子菜单"],sl:["Podmeni"],sk:["Podmenu"],hu:["Almenü"],cs:["Podmenu"],sv:["Undermeny"],no:["Undermeny"],fi:["Alavalikko"],uk:["Підменю"],ro:["Submeniu"],ga:["Fomhuir"],el:["Υπομενού"],sr:["Podmeni"],bs:["Podmeni"],hr:["Podmeni"],lb:["Ënnermenu"],sq:["Nënmenu"],da:["Undermenu"]},opens_homepage:{en:["Redirects to homepage"],"en-GB":["Redirects to homepage"],"en-CA":["Redirects to homepage"],he:["מעביר לדף הבית"],ar:["يعيد التوجيه إلى الصفحة الرئيسية"],de:["Leitet zur Startseite weiter"],fr:["Redirige vers la page d'accueil"],it:["Reindirizza alla pagina iniziale"],es:["Redirige a la página principal"],ja:["ホームページにリダイレクト"],nl:["Redirect naar de startpagina"],pt:["Redireciona para a página inicial"],pl:["Przekierowuje na stronę główną"],ru:["Перенаправляет на главную страницу"],tw:["重新導向到首頁"],tr:["Ana sayfaya yönlendirir"],ua:["Перенаправляє на головну сторінку"],zh:["重定向到主页"],sl:["Preusmeri na domačo stran"],sk:["Presmeruje na domovskú stránku"],hu:["Átirányít a főoldalra"],cs:["Přesměrovává na domovskou stránku"],fi:["Ohjaa kotisivulle"],sv:["Omdirigerar till hemsidan"],no:["Omdirigerer til hjemmesiden"],uk:["Перенаправляє на головну сторінку"],ro:["Redirecționează către pagina principală"],ga:["Treoraíonn chuig an leathanach baile"],el:["Ανακατευθύνει στην αρχική σελίδα"],sr:["Преусмерава на почетну страницу"],bs:["Preusmjerava na početnu stranicu"],hr:["Preusmjerava na početnu stranicu"],lb:["Leet op d’Haaptsäit ëm"],sq:["Riorienton në faqen kryesore"],da:["Omdirigerer til Hjemmeside"]},unlabelled:{en:["Unlabelled"],"en-GB":["Unlabelled"],"en-CA":["Unlabelled"],he:["ללא תווית"],ar:["بدون تسمية"],de:["Unbeschriftet"],fr:["Sans étiquette"],it:["Non etichettato"],es:["Sin etiqueta"],ja:["ラベルなし"],nl:["Ongeëtiketteerd"],pt:["Sem rótulo"],pl:["Bez etykiety"],ru:["Без этикетки"],tw:["未標記"],tr:["Etiketlenmemiş"],ua:["Без етикетки"],zh:["未标记"],sl:["Brez oznake"],sk:["Bez označenia"],hu:["Megjelölés nélkül"],cs:["Bez označení"],fi:["Ilman etikettiä"],uk:["Без етикетки"],ro:["Fără etichetă"],ga:["Gan lipéad"],el:["Χωρίς ετικέτα"],sr:["Bez oznake"],bs:["Bez oznake"],hr:["Bez oznake"],lb:["Ouni Label"],sq:["Pa etiketë"],da:["Uden etiket"],sv:["Oetiketterad"],no:["Uten etikett"]},cancel:{en:["Cancel"],"en-GB":["Cancel"],"en-CA":["Cancel"],he:["ביטול"],ar:["إلغاء"],de:["Abbrechen"],fr:["Annuler"],it:["Annulla"],es:["Cancelar"],ja:["キャンセル"],nl:["Annuleren"],pt:["Cancelar"],pl:["Anuluj"],ru:["Отмена"],tw:["取消"],tr:["İptal et"],ua:["Скасувати"],zh:["取消"],sl:["Prekliči"],sk:["Zrušiť"],hu:["Mégse"],cs:["Zrušit"],sv:["Avbryt"],no:["Avbryt"],fi:["Peruuta"],uk:["Скасувати"],ro:["Anulați","Anulare"],ga:["Cealaigh","Cealú"],el:["Ακύρωση","Ακυρώστε"],sr:["отказати","отказује"],bs:["otkazati","otkazivanje"],hr:["otkazati","otkazivanje"],lb:["Ofbriechen","Ofbriechen"],sq:["Anulo","Anulimi"],da:["Afbryd","Afbryde"]},dismiss:{en:["Dismiss"],"en-GB":["Dismiss"],"en-CA":["Dismiss"],he:["דחה"],ar:["رفض"],de:["Ablehnen"],fr:["Rejeter"],it:["Scarta"],es:["Descartar"],ja:["却下する"],nl:["Afwijzen"],pt:["Dispensar"],pl:["Odrzuć"],ru:["Отклонить"],tw:["拒絕"],tr:["Reddetmek"],ua:["Відхилити"],zh:["拒绝"],sl:["Zavrniti"],sk:["Zamietnuť"],hu:["Elutasít","Elutasítás"],cs:["Odmítnout","Odmítnutí"],sv:["Avvisa","Avvisning"],no:["Avvis","Avvisning"],fi:["Hylkää","Hylkäys"],uk:["Відхилити","Відхилення"],ro:["Respingeți","Respingere"],ga:["Diúltóidh","Diúltú"],el:["Απόρριψη","Απορρίπτετε"],sr:["одбити","одбијање"],bs:["odbaciti","odbacivanje"],hr:["odbaciti","odbacivanje"],lb:["Ofweisen","Ofweisung"],sq:["Refuzoni","Refuzimi"],da:["Afvis","Afvisning"]},no:{en:["No"],"en-GB":["No"],"en-CA":["No"],he:["לא"],ar:["لا"],de:["Nein"],fr:["Non"],it:["No"],es:["No"],ja:["いいえ"],nl:["Nee"],pt:["Não"],pl:["Nie"],ru:["Нет"],tw:["不"],tr:["Hayır"],ua:["Ні"],zh:["不"],sl:["Ne"],sk:["Nie"],hu:["Nem","Nem"],cs:["Ne","Ne"],sv:["Nej","Nej"],no:["Nei","Nei"],fi:["Ei","Ei"],uk:["Ні","Ні"],ro:["Nu","Nu"],ga:["Níl","Níl"],el:["Όχι","Όχι"],sr:["не","не"],bs:["ne","ne"],hr:["ne","ne"],lb:["Nee","Nee"],sq:["Jojo","Jojo"],da:["Nej","Nej"]},main_menu:{en:["Main Menu"],"en-GB":["Main Menu"],"en-CA":["Main Menu"],he:["תפריט ראשי"],ar:["القائمة الرئيسية"],de:["Hauptmenü"],fr:["Menu Principal"],it:["Menu Principale"],es:["Menú Principal"],ja:["メインメニュー"],nl:["Hoofdmenu"],pt:["Menu Principal"],pl:["Menu Główne"],ru:["Главное меню"],tw:["主選單"],tr:["Ana Menü"],ua:["Головне меню"],zh:["主菜单"],sl:["Glavni meni"],sk:["Hlavné menu"],hu:["Főmenü"],cs:["Hlavní nabídka"],sv:["Huvudmeny"],no:["Hovedmeny"],fi:["Päävalikko"],uk:["Головне меню"],ro:["Meniu Principal"],ga:["Príomh Roghchlár"],el:["Κύριο Μενού"],sr:["Glavni meni"],bs:["Glavni meni"],hr:["Glavni izbornik"],lb:["Haaptmenü"],sq:["Meny Kryesor"],da:["Hovedmenu"]},remove:{en:["Remove"],"en-GB":["Remove"],"en-CA":["Remove"],he:["הסר"],ar:["إزالة"],de:["Entfernen"],fr:["Supprimer"],it:["Rimuovi"],es:["Eliminar"],ja:["削除"],nl:["Verwijderen"],pt:["Remover"],pl:["Usuń"],ru:["Удалить"],tw:["移除"],tr:["Kaldır"],ua:["Видалити"],zh:["移除"],sl:["Odstrani"],sk:["Odstrániť"],hu:["Eltávolítás"],cs:["Odstranit"],sv:["Ta bort"],no:["Fjern"],fi:["Poista"],uk:["Видалити"],ro:["Elimină","Eliminare"],ga:["Bain","Bain amach"],el:["Αφαίρεση","Αφαιρείτε"],sr:["уклонити","уклањање"],bs:["ukloniti","uklanjanje"],hr:["ukloniti","uklanjanje"],lb:["Ewechhuelen","Ewechhuelechung"],sq:["Hiq","Hiqje nga lista e preferuarave"],da:["Fjern","Fjern fra favoritter"]},contact:{en:["Contact"],"en-GB":["Contact"],"en-CA":["Contact"],he:["צור קשר"],ar:["اتصل"],de:["Kontakt"],fr:["Contact"],it:["Contatto"],es:["Contacto"],ja:["連絡先"],nl:["Contact"],pt:["Contato"],pl:["Kontakt"],ru:["Контакт"],tw:["聯繫方式"],tr:["İletişim"],ua:["Контакт"],zh:["联系方式"],sl:["Kontakt"],sk:["Kontakt"],hu:["Kapcsolat"],cs:["Kontakt"],sv:["Kontakt"],no:["Kontakt"],fi:["Yhteystiedot"],uk:["Контакт"],ro:["Contact","Contactează-ne"],ga:["Teagmháil","Teagmháil linn"],el:["Επικοινωνία","Επικοινωνήστε μαζί μας"],sr:["Kontakt","Kontaktirajte nas"],bs:["Kontakt","Kontaktirajte nas"],hr:["Kontakt","Kontaktirajte nas"],lb:["Kontakt","Kontaktiere eis"],sq:["Kontakt","Na kontaktoni ne"],da:["Kontakt","Kontakt os"]},cart:{en:["Cart"],"en-GB":["Cart"],"en-CA":["Cart"],he:["עגלת קניות"],ar:["عربة التسوق"],de:["Warenkorb"],fr:["Panier"],it:["Carrello"],es:["Carrito"],ja:["カート"],nl:["Winkelwagentje"],pt:["Carrinho"],pl:["Koszyk"],ru:["Корзина"],tw:["購物車"],tr:["Sepet"],ua:["Кошик"],zh:["购物车"],sl:["Košarica"],sk:["Nákupný košík"],hu:["Kosár"],cs:["Košík"],sv:["Kundvagn"],no:["Handlekurv"],fi:["Ostoskori"],uk:["Кошик для покупок"],ro:["Coș","Coș de cumpărături"],ga:["Cartlann","Cartlann Siopadóireachta"],el:["Καλάθι","Καλάθι αγορών"],sr:["Korpa","Korpa za kupovinu"],bs:["Korpa","Korpa za kupovinu"],hr:["Košarica","Košarica za kupnju"],lb:["Kuerf","Kuerf fir Kafee ze kafen"],sq:["Karrocë","Karrocë Blerjeje"],da:["Kurv","Indkøbskurv"]},menu:{en:["Menu"],"en-GB":["Menu"],"en-CA":["Menu"],he:["תפריט"],ar:["قائمة"],de:["Menü"],fr:["Menu"],it:["Menu"],es:["Menú"],ja:["メニュー"],nl:["Menu"],pt:["Menu"],pl:["Menu"],ru:["Меню"],tw:["選單"],tr:["Menü"],ua:["Меню"],zh:["菜单"],sl:["Meni"],sk:["Menu"],hu:["Menü"],cs:["Nabídka"],sv:["Meny"],no:["Meny"],fi:["Valikko"],uk:["Меню"],ro:["Meniu"],ga:["Roghchlár"],el:["Μενού"],sr:["Meni"],bs:["Meni"],hr:["Meni"],lb:["Menü"],sq:["Meny"],da:["Menu"]},download:{en:["Download"],"en-GB":["Download"],"en-CA":["Download"],he:["הורדה"],ar:["تحميل"],de:["Herunterladen"],fr:["Télécharger"],it:["Scarica"],es:["Descargar"],ja:["ダウンロード"],nl:["Downloaden"],pt:["Baixar"],pl:["Pobierz"],ru:["Скачать"],tw:["下載"],tr:["İndir"],ua:["Завантажити"],zh:["下载"],sl:["Prenesi"],sk:["Stiahnuť"],hu:["Letöltés"],cs:["Stáhnout"],sv:["Ladda ner"],no:["Last ned"],fi:["Lataa"],uk:["Завантажити"],ro:["Descarcă","Descărcare"],ga:["Íoslódáil","Íoslódáil anois"],el:["Λήψη","Κατεβάστε τώρα"],sr:["Preuzmi","Preuzimanje sada"],bs:["Preuzmi","Preuzimanje sada"],hr:["Preuzmi","Preuzimanje sada"],lb:["Downloaden","Download elooscht elo maachen"],sq:["Shkarko","Shkarkimi tani"],da:["Download","Download nu"]},order:{en:["Order"],"en-GB":["Order"],"en-CA":["Order"],he:["הזמנה"],ar:["طلب"],de:["Bestellung"],fr:["Commande"],it:["Ordine"],es:["Pedido"],ja:["注文"],nl:["Bestelling"],pt:["Pedido"],pl:["Zamówienie"],ru:["Заказ"],tw:["訂單"],tr:["Sipariş"],ua:["Замовлення"],zh:["订单"],sl:["Naročilo"],sk:["Objednávka"],hu:["Rendelés"],cs:["Objednávka"],sv:["Beställning"],no:["Bestilling"],fi:["Tilaus"],uk:["Замовлення"],ro:["Comandă","Comandă acum"],ga:["Ordú","Ordú anois"],el:["Παραγγελία","Παραγγείλετε τώρα"],sr:["Naruči","Naručivanje sada"],bs:["Naruči","Naručivanje sada"],hr:["Naruči","Naručivanje sada"],lb:["Bestellung","Bestellung elooscht elo maachen"],sq:["Porosit","Porosit tani"],da:["Bestil","Bestil nu"]},share:{en:["Share"],"en-GB":["Share"],"en-CA":["Share"],he:["שתף"],ar:["مشاركة"],de:["Teilen"],fr:["Partager"],it:["Condividi"],es:["Compartir"],ja:["共有"],nl:["Delen"],pt:["Compartilhar"],pl:["Udostępnij"],ru:["Поделиться"],tw:["分享"],tr:["Paylaş"],ua:["Поділитися"],zh:["分享"],sl:["Deli"],sk:["Zdieľať"],hu:["Megosztás"],cs:["Sdílet"],sv:["Dela"],no:["Del"],fi:["Jaa"],uk:["Поділитися"],ro:["Partajează","Partajare acum"],ga:["Roinn","Roinn anois"],el:["Κοινοποίηση","Κοινοποιήστε τώρα"],sr:["Podeli","Deljenje sada"],bs:["Podijeli","Dijeljenje sada"],hr:["Podijeli","Dijeljenje sada"],lb:["Deelen","Deelen elooscht elo maachen"],sq:["Ndaj","Ndaje tani"],da:["Del","Del nu"]},move:{en:["Move"],"en-GB":["Move"],"en-CA":["Move"],he:["הזז"],ar:["تحريك"],de:["Verschieben"],fr:["Déplacer"],it:["Sposta"],es:["Mover"],ja:["移動"],nl:["Verplaatsen"],pt:["Mover"],pl:["Przenieś"],ru:["Переместить"],tw:["移動"],tr:["Taşı"],ua:["Перемістити"],zh:["移动"],sl:["Premakni"],sk:["Presunúť"],hu:["Mozgatás"],cs:["Přesunout"],sv:["Flytta"],no:["Flytt"],fi:["Siirrä"],uk:["Перемістити"],ro:["Mută","Mutare acum"],ga:["Bogadh","Bogadh anois"],el:["Μετακίνηση","Μετακινήστε τώρα"],sr:["Pomeri","Premještanje sada"],bs:["Pomjeri","Premještanje sada"],hr:["Pomakni","Premještanje sada"],lb:["Beweeg","Beweeg elooscht elo maachen"],sq:["Lëviz","Lëviz tani"],da:["Flyt","Flyt nu"]},toggle:{en:["Toggle"],"en-GB":["Toggle"],"en-CA":["Toggle"],he:["החלף"],ar:["تبديل"],de:["Umschalten"],fr:["Basculer"],it:["Attiva/Disattiva"],es:["Alternar"],ja:["切り替え"],nl:["Wissel"],pt:["Alternar"],pl:["Przełącz"],ru:["Переключить"],tw:["切換"],tr:["Değiştir"],ua:["Перемикнути"],zh:["切换"],sl:["Preklopi"],sk:["Prepínať"],hu:["Váltás"],cs:["Přepnout"],sv:["Växla"],no:["Veksle"],fi:["Vaihda"],uk:["Перемкнути"],ro:["Comută","Comutare acum"],ga:["Athraigh","Athrú anois"],el:["Εναλλαγή","Εναλλαγή τώρα"],sr:["Prebaci","Prebacivanje sada"],bs:["Prebaci","Prebacivanje sada"],hr:["Prebaci","Prebacivanje sada"],lb:["Umschalten","Umschalten elooscht elo maachen"],sq:["Ndrysho","Ndrysho tani"],da:["Skift","Skift nu"]},accept:{en:["Accept"],"en-GB":["Accept"],"en-CA":["Accept"],he:["קבל"],ar:["قبول"],de:["Akzeptieren"],fr:["Accepter"],it:["Accetta"],es:["Aceptar"],ja:["受け入れる"],nl:["Accepteren"],pt:["Aceitar"],pl:["Akceptuj"],ru:["Принять"],tw:["接受"],tr:["Kabul et"],ua:["Прийняти"],zh:["接受"],sl:["Sprejmi"],sk:["Prijať"],hu:["Elfogadás"],cs:["Přijmout"],sv:["Acceptera"],no:["Godta"],fi:["Hyväksy"],uk:["Прийняти"],ro:["Acceptă","Acceptare acum"],ga:["Glac","Glac anois"],el:["Αποδοχή","Αποδεχτείτε τώρα"],sr:["Prihvati","Prihvatite sada"],bs:["Prihvati","Prihvatite sada"],hr:["Prihvati","Prihvaćanje sada"],lb:["Akzeptéieren","Akzeptéieren elo elo maachen"],sq:["Prano","Pranoni tani"],da:["Accepter","Accepter nu"]},account:{en:["Account"],"en-GB":["Account"],"en-CA":["Account"],he:["חשבון"],ar:["حساب"],de:["Konto"],fr:["Compte"],it:["Account"],es:["Cuenta"],ja:["アカウント"],nl:["Account"],pt:["Conta"],pl:["Konto"],ru:["Аккаунт"],tw:["帳戶"],tr:["Hesap"],ua:["Обліковий запис"],zh:["账户"],sl:["Račun"],sk:["Účet"],hu:["Fiók"],cs:["Účet"],sv:["Konto"],no:["Konto"],fi:["Tili"],uk:["Обліковий запис"],ro:["Cont","Contul meu"],ga:["Cuntas","Mo Chuntas"],el:["Λογαριασμός","Ο λογαριασμός μου"],sr:["Nalog","Moj nalog"],bs:["Nalog","Moj nalog"],hr:["Račun","Moj račun"],lb:["Kont","Meng Kont"],sq:["Llogari","Llogaria ime"],da:["Konto","Min konto"]},date:{en:["Date"],"en-GB":["Date"],"en-CA":["Date"],he:["תאריך"],ar:["تاريخ"],de:["Datum"],fr:["Date"],it:["Data"],es:["Fecha"],ja:["日付"],nl:["Datum"],pt:["Data"],pl:["Data"],ru:["Дата"],tw:["日期"],tr:["Tarih"],ua:["Дата"],zh:["日期"],sl:["Datum"],sk:["Dátum"],hu:["Dátum"],cs:["Datum"],sv:["Datum"],no:["Dato"],fi:["Päivämäärä"],uk:["Дата"],ro:["Dată","Data curentă"],ga:["Dáta","An Dáta Reatha"],el:["Ημερομηνία","Η τρέχουσα ημερομηνία"],sr:["Datum","Trenutni datum"],bs:["Datum","Trenutni datum"],hr:["Datum","Trenutni datum"],lb:["Datum","Aktuell Datum"],sq:["Datë","Data aktuale"],da:["Dato","Aktuel dato"]},address:{en:["Address"],"en-GB":["Address"],"en-CA":["Address"],he:["כתובת"],ar:["عنوان"],de:["Adresse"],fr:["Adresse"],it:["Indirizzo"],es:["Dirección"],ja:["住所"],nl:["Adres"],pt:["Endereço"],pl:["Adres"],ru:["Адрес"],tw:["地址"],tr:["Adres"],ua:["Адреса"],zh:["地址"],sl:["Naslov"],sk:["Adresa"],hu:["Cím"],cs:["Adresa"],sv:["Adress"],no:["Adresse"],fi:["Osoite"],uk:["Адреса"],ro:["Adresă","Adresa mea"],ga:["Seoladh","Mo Seoladh"],el:["Διεύθυνση","Η διεύθυνσή μου"],sr:["Adresa","Moja adresa"],bs:["Adresa","Moja adresa"],hr:["Adresa","Moja adresa"],lb:["Adress","Meng Adress"],sq:["Adresë","Adresa ime"],da:["Adresse","Min adresse"]},on:{en:["On"],"en-GB":["On"],"en-CA":["On"],he:["פעיל"],ar:["تشغيل"],de:["Ein"],fr:["Activé"],it:["Attivo"],es:["Encendido"],ja:["オン"],nl:["Aan"],pt:["Ligado"],pl:["Włączone"],ru:["Включено"],tw:["開啟"],tr:["Açık"],ua:["Увімкнено"],zh:["开启"],sl:["Vklopljeno"],sk:["Zapnuté"],hu:["Bekapcsolva"],cs:["Zapnuto"],sv:["Påslagen"],no:["Påslått"],fi:["Päällä"],uk:["Увімкнено"],ro:["Activat"],ga:["Ar siúl"],el:["Ενεργό"],sr:["Uključeno"],bs:["Uključeno"],hr:["Uključeno"],lb:["Aktivéiert"],sq:["Ekyçur"],da:["Tændt"]},off:{en:["Off"],"en-GB":["Off"],"en-CA":["Off"],he:["כבוי"],ar:["إيقاف"],de:["Aus"],fr:["Désactivé"],it:["Disattivo"],es:["Apagado"],ja:["オフ"],nl:["Uit"],pt:["Desligado"],pl:["Wyłączone"],ru:["Выключено"],tw:["關閉"],tr:["Kapalı"],ua:["Вимкнено"],zh:["关闭"],sl:["Izklopljeno"],sk:["Vypnuté"],hu:["Kikapcsolva"],cs:["Vypnuto"],sv:["Avstängd"],no:["Avslått"],fi:["Pois päältä"],uk:["Вимкнено"],ro:["Dezactivat"],ga:["Múchta"],el:["Ανενεργό"],sr:["Isključeno"],bs:["Isključeno"],hr:["Isključeno"],lb:["Deaktivéiert"],sq:["Çaktivizuar"],da:["Slukket"]},enable:{en:["Enable"],"en-GB":["Enable"],"en-CA":["Enable"],he:["הפעל"],ar:["تفعيل"],de:["Aktivieren"],fr:["Activer"],it:["Abilita"],es:["Habilitar"],ja:["有効にする"],nl:["Inschakelen"],pt:["Ativar"],pl:["Włącz"],ru:["Включить"],tw:["啟用"],tr:["Etkinleştir"],ua:["Увімкнути"],zh:["启用"],sl:["Omogoči"],sk:["Povoliť"],hu:["Engedélyezés"],cs:["Povolit"],sv:["Aktivera"],no:["Aktiver"],fi:["Ota käyttöön"],uk:["Увімкнути"],ro:["Activează"],ga:["Cumasaigh"],el:["Ενεργοποίηση"],sr:["Omogući"],bs:["Omogući"],hr:["Omogući"],lb:["Aktivéieren"],sq:["Aktivizo"],da:["Aktivér"]},disable:{en:["Disable"],"en-GB":["Disable"],"en-CA":["Disable"],he:["השבת"],ar:["تعطيل"],de:["Deaktivieren"],fr:["Désactiver"],it:["Disabilita"],es:["Deshabilitar"],ja:["無効にする"],nl:["Uitschakelen"],pt:["Desativar"],pl:["Wyłącz"],ru:["Отключить"],tw:["停用"],tr:["Devre dışı bırak"],ua:["Вимкнути"],zh:["禁用"],sl:["Onemogoči"],sk:["Zakázať"],hu:["Letiltás"],cs:["Zakázat"],sv:["Inaktivera"],no:["Deaktiver"],fi:["Poista käytöstä"],uk:["Вимкнути"],ro:["Dezactivează"],ga:["Díchumasaigh"],el:["Απενεργοποίηση"],sr:["Onemogući"],bs:["Onemogući"],hr:["Onemogući"],lb:["Desaktivéieren"],sq:["Çaktivizo"],da:["Deaktivér"]},activate:{en:["Activate"],"en-GB":["Activate"],"en-CA":["Activate"],he:["הפעל"],ar:["تفعيل"],de:["Aktivieren"],fr:["Activer"],it:["Attiva"],es:["Activar"],ja:["有効化する"],nl:["Activeren"],pt:["Ativar"],pl:["Aktywuj"],ru:["Активировать"],tw:["啟動"],tr:["Aktifleştir"],ua:["Активувати"],zh:["激活"],sl:["Aktiviraj"],sk:["Aktivovať"],hu:["Aktiválás"],cs:["Aktivovat"],sv:["Aktivera"],no:["Aktiver"],fi:["Aktivoi"],uk:["Активувати"],ro:["Activează"],ga:["Gníomhachtaigh"],el:["Ενεργοποιώ"],sr:["Aktiviraj"],bs:["Aktiviraj"],hr:["Aktiviraj"],lb:["Aktivéieren"],sq:["Aktivizo"],da:["Aktivér"]},deactivate:{en:["Deactivate"],"en-GB":["Deactivate"],"en-CA":["Deactivate"],he:["השבת"],ar:["تعطيل"],de:["Deaktivieren"],fr:["Désactiver"],it:["Disattiva"],es:["Desactivar"],ja:["無効化する"],nl:["Deactiveren"],pt:["Desativar"],pl:["Dezaktywuj"],ru:["Деактивировать"],tw:["停用"],tr:["Devre dışı bırak"],ua:["Деактивувати"],zh:["停用"],sl:["Deaktiviraj"],sk:["Deaktivovať"],hu:["Deaktiválás"],cs:["Deaktivovat"],sv:["Avaktivera"],no:["Deaktiver"],fi:["Deaktivoi"],uk:["Деактивувати"],ro:["Dezactivează"],ga:["Díghníomhachtaigh"],el:["Απενεργοποιώ"],sr:["Deaktiviraj"],bs:["Deaktiviraj"],hr:["Deaktiviraj"],lb:["Desaktivéieren"],sq:["Çaktivizo"],da:["Deaktivér"]},active:{en:["Active"],"en-GB":["Active"],"en-CA":["Active"],he:["פעיל"],ar:["نشط"],de:["Aktiv"],fr:["Actif"],it:["Attivo"],es:["Activo"],ja:["アクティブ"],nl:["Actief"],pt:["Ativo"],pl:["Aktywny"],ru:["Активный"],tw:["啟用"],tr:["Aktif"],ua:["Активний"],zh:["激活"],sl:["Aktiven"],sk:["Aktívny"],hu:["Aktív"],cs:["Aktivní"],sv:["Aktiv"],no:["Aktiv"],fi:["Aktiivinen"],uk:["Активний"],ro:["Activ"],ga:["Gníomhach"],el:["Ενεργός"],sr:["Aktivan"],bs:["Aktivan"],hr:["Aktivan"],lb:["Aktiv"],sq:["Aktiv"],da:["Aktiv"]},suggestions_available:{en:["Suggestions available. Use up and down arrow keys to browse"],"en-GB":["Suggestions available. Use up and down arrow keys to browse"],"en-CA":["Suggestions available. Use up and down arrow keys to browse"],he:["יש הצעות זמינות. השתמש במקשי החצים למעלה ולמטה כדי לעיין"],ar:["الاقتراحات متاحة. استخدم مفاتيح الأسهم لأعلى ولأسفل للتصفح"],de:["Vorschläge verfügbar. Verwenden Sie die Pfeiltasten nach oben und unten, um zu blättern"],fr:["Suggestions disponibles. Utilisez les flèches haut et bas pour parcourir"],it:["Suggerimenti disponibili. Usa i tasti freccia su e giù per navigare"],es:["Sugerencias disponibles. Usa las flechas arriba y abajo para navegar"],ja:["候補があります。上下の矢印キーで閲覧してください"],nl:["Suggesties beschikbaar. Gebruik de pijltjestoetsen omhoog en omlaag om te bladeren"],pt:["Sugestões disponíveis. Use as setas para cima e para baixo para navegar"],pl:["Dostępne sugestie. Użyj strzałek w górę i w dół, aby przeglądać"],ru:["Доступны предложения. Используйте стрелки вверх и вниз для просмотра"],tw:["有建議可用。使用上下箭頭鍵瀏覽"],tr:["Öneriler mevcut. Göz atmak için yukarı ve aşağı ok tuşlarını kullanın"],ua:["Доступні пропозиції. Використовуйте клавіші зі стрілками вгору та вниз для перегляду"],zh:["有建议可用。使用上下箭头键浏览"],sl:["Na voljo so predlogi. Za brskanje uporabite puščici gor in dol"],sk:["Dostupné návrhy. Použite šípky hore a dole na prehliadanie"],hu:["Elérhetők javaslatok. A böngészéshez használja a felfelé és lefelé nyilakat"],cs:["Dostupné návrhy. K procházení použijte šipky nahoru a dolů"],sv:["Förslag tillgängliga. Använd upp- och nedpilarna för att bläddra"],no:["Forslag tilgjengelig. Bruk piltastene opp og ned for å bla"],fi:["Ehdotuksia saatavilla. Selaa ylös- ja alasnuolinäppäimillä"],uk:["Доступні пропозиції. Використовуйте клавіші зі стрілками вгору та вниз для перегляду"],ro:["Sugestii disponibile. Folosiți săgețile sus și jos pentru a răsfoi"],ga:["Moltaí ar fáil. Bain úsáid as eochracha saigheada suas agus síos chun brabhsáil"],el:["Διαθέσιμες προτάσεις. Χρησιμοποιήστε τα βελάκια πάνω και κάτω για περιήγηση"],sr:["Dostupni su predlozi. Koristite strelice gore i dole za pregled"],bs:["Dostupni su prijedlozi. Koristite strelice gore i dolje za pregled"],hr:["Dostupni su prijedlozi. Koristite strelice gore i dolje za pregled"],lb:["Virschléi verfügbar. Benotzt d'Pfeiltasten erop an erof fir ze bliederen"],sq:["Sugjerime të disponueshme. Përdorni shigjetat lart dhe poshtë për të shfletuar"],da:["Forslag tilgængelige. Brug piletasterne op og ned for at gennemse"]},available:{en:["available"],"en-GB":["available"],"en-CA":["available"],he:["זמין","זמינה","זמינים","זמינות"],ar:["متاح","متاحة","متاحون","متاحات"],de:["verfügbar","verfügbare","verfügbares","verfügbarer"],fr:["disponible","disponibles"],it:["disponibile","disponibili"],es:["disponible","disponibles"],ja:["利用可能","利用可能な"],nl:["beschikbaar","beschikbare"],pt:["disponível","disponíveis"],pl:["dostępny","dostępna","dostępne","dostępni"],ru:["доступен","доступна","доступно","доступны"],tw:["可用"],tr:["mevcut","mevcutlar"],ua:["доступний","доступна","доступне","доступні"],zh:["可用"],sl:["na voljo","na razpolago"],sk:["dostupný","dostupná","dostupné"],hu:["elérhető","elérhetők"],cs:["dostupný","dostupná","dostupné"],sv:["tillgänglig","tillgängliga"],no:["tilgjengelig","tilgjengelige"],fi:["saatavilla","saatavissa"],uk:["доступний","доступна","доступне","доступні"],ro:["disponibil","disponibilă","disponibili"],ga:["ar fáil"],el:["διαθέσιμος","διαθέσιμη","διαθέσιμο","διαθέσιμοι","διαθέσιμα"],sr:["доступан","доступна","доступно","доступни"],bs:["dostupan","dostupna","dostupno","dostupni"],hr:["dostupan","dostupna","dostupno","dostupni"],lb:["verfügbar","verfügbarer"],sq:["disponueshëm","disponueshme"],da:["tilgængelig","tilgængelige"]},result:{en:["result","results"],"en-GB":["result","results"],"en-CA":["result","results"],he:["תוצאה","תוצאות"],ar:["نتيجة","نتائج"],de:["Ergebnis","Ergebnisse"],fr:["résultat","résultats"],it:["risultato","risultati"],es:["resultado","resultados"],ja:["結果"],nl:["resultaat","resultaten"],pt:["resultado","resultados"],pl:["wynik","wyniki"],ru:["результат","результаты"],tw:["結果"],tr:["sonuç","sonuçlar"],ua:["результат","результати"],zh:["结果"],sl:["rezultat","rezultati"],sk:["výsledok","výsledky"],hu:["eredmény","eredmények"],cs:["výsledek","výsledky"],sv:["resultat"],no:["resultat","resultater"],fi:["tulos","tulokset"],uk:["результат","результати"],ro:["rezultat","rezultate"],ga:["toradh","torthaí"],el:["αποτέλεσμα","αποτελέσματα"],sr:["резултат","резултати"],bs:["rezultat","rezultati"],hr:["rezultat","rezultati"],lb:["Resultat","Resultater"],sq:["rezultat","rezultate","rezultatet"],da:["resultat","resultater"]},search_results_available:{en:["Results or suggestions will be displayed as they become available. Continue navigating to access them"],"en-GB":["Results or suggestions will be displayed as they become available. Continue navigating to access them"],"en-CA":["Results or suggestions will be displayed as they become available. Continue navigating to access them"],he:["תוצאות או הצעות יוצגו ככל שהן זמינות. המשך לנווט כדי לגשת אליהן"],ar:["ستظهر النتائج أو الاقتراحات عند توفرها. استمر في التنقل للوصول إليها"],de:["Ergebnisse oder Vorschläge werden angezeigt, sobald sie verfügbar sind. Navigieren Sie weiter, um darauf zuzugreifen"],fr:["Les résultats ou suggestions s'afficheront dès qu'ils seront disponibles. Continuez à naviguer pour y accéder"],it:["I risultati o i suggerimenti verranno visualizzati quando disponibili. Continua a navigare per accedervi"],es:["Los resultados o sugerencias se mostrarán cuando estén disponibles. Continúa navegando para acceder a ellos"],ja:["結果または提案は利用可能になると表示されます。続けてナビゲートしてアクセスしてください"],nl:["Resultaten of suggesties worden weergegeven zodra ze beschikbaar zijn. Blijf navigeren om er toegang toe te krijgen"],pt:["Resultados ou sugestões serão exibidos quando disponíveis. Continue navegando para acessá-los"],pl:["Wyniki lub sugestie będą wyświetlane w miarę ich dostępności. Kontynuuj nawigację, aby uzyskać do nich dostęp"],ru:["Результаты или предложения будут отображаться по мере их появления. Продолжайте навигацию для доступа к ним"],tw:["結果或建議將在可用時顯示。繼續導航以訪問它們"],tr:["Sonuçlar veya öneriler kullanılabilir oldukça görüntülenecektir. Bunlara erişmek için gezintiyi sürdürün"],ua:["Результати або пропозиції будуть відображатися, коли вони стануть доступними. Продовжуйте навігацію для доступу до них"],zh:["结果或建议将在可用时显示。继续导航以访问它们"],sl:["Rezultati ali predlogi bodo prikazani, ko bodo na voljo. Nadaljujte z navigacijo za dostop"],sk:["Výsledky alebo návrhy sa zobrazia, keď budú k dispozícii. Pokračujte v navigácii pre prístup"],hu:["Az eredmények vagy javaslatok megjelennek, amikor elérhetővé válnak. Folytassa a navigálást a hozzáféréshez"],cs:["Výsledky nebo návrhy se zobrazí, jakmile budou k dispozici. Pokračujte v navigaci pro přístup"],sv:["Resultat eller förslag visas när de blir tillgängliga. Fortsätt navigera för att komma åt dem"],no:["Resultater eller forslag vises når de blir tilgjengelige. Fortsett å navigere for å få tilgang"],fi:["Tulokset tai ehdotukset näytetään, kun ne ovat saatavilla. Jatka navigointia päästäksesi niihin"],uk:["Результати або пропозиції будуть відображатися, коли вони стануть доступними. Продовжуйте навігацію для доступу до них"],ro:["Rezultatele sau sugestiile vor fi afișate pe măsură ce devin disponibile. Continuați navigarea pentru a le accesa"],ga:["Taispeánfar torthaí nó moltaí de réir mar a bheidh siad ar fáil. Lean ort ag nascleanúint chun rochtain a fháil orthu"],el:["Τα αποτελέσματα ή οι προτάσεις θα εμφανίζονται καθώς γίνονται διαθέσιμα. Συνεχίστε την πλοήγηση για πρόσβαση"],sr:["Резултати или предлози ће бити приказани када буду доступни. Наставите навигацију за приступ"],bs:["Rezultati ili prijedlozi će biti prikazani kada budu dostupni. Nastavite navigaciju za pristup"],hr:["Rezultati ili prijedlozi će biti prikazani kada budu dostupni. Nastavite navigaciju za pristup"],lb:["Resultater oder Virschléi ginn ugewisen soubal se verfügbar sinn. Fuert d'Navigatioun weider fir dran ze kommen"],sq:["Rezultatet ose sugjerimet do të shfaqen kur të bëhen të disponueshme. Vazhdoni navigimin për t'i arritur"],da:["Resultater eller forslag vises, når de bliver tilgængelige. Fortsæt med at navigere for at få adgang"]},checkout:{en:["Checkout"],"en-GB":["Checkout"],"en-CA":["Checkout"],he:["תשלום"],ar:["الدفع"],de:["Zur Kasse"],fr:["Passer à la caisse"],it:["Cassa"],es:["Pagar"],ja:["チェックアウト"],nl:["Afrekenen"],pt:["Finalizar compra"],pl:["Kasa"],ru:["Оформить заказ"],tw:["結帳"],tr:["Ödeme"],ua:["Оформити замовлення"],zh:["结账"],sl:["Blagajna"],sk:["Pokladňa"],hu:["Pénztár"],cs:["Pokladna"],sv:["Kassa"],no:["Kasse"],fi:["Kassalle"],uk:["Оформити замовлення"],ro:["Finalizare comandă","Finalizați comanda"],ga:["Seiceáil Amach","Seiceáil Amach Anois"],el:["Ολοκλήρωση αγοράς","Ολοκληρώστε την αγορά τώρα"],sr:["Kasa","Završi kupovinu sada"],bs:["Kasa","Završi kupovinu sada"],hr:["Blagajna","Završi kupovinu sada"],lb:["Kasse","Kaf ze kafen elooscht elo maachen"],sq:["Arkëtim","Përfundo blerjen tani"],da:["Kassen","Gennemfør købet nu"]},check_out:{en:["Check Out"],"en-GB":["Check Out"],"en-CA":["Check Out"],he:["צא"],ar:["الخروج"],de:["Auschecken"],fr:["Vérifier"],it:["Controlla"],es:["Revisar"],ja:["チェックアウト"],nl:["Uitchecken"],pt:["Verificar"],pl:["Sprawdź"],ru:["Проверить"],tw:["結帳"],tr:["Kontrol Et"],ua:["Перевірити"],zh:["结账"],sl:["Preveri"],sk:["Skontrolovať"],hu:["Ellenőrizze"],cs:["Zkontrolovat"],sv:["Kolla in"],no:["Sjekk ut"],fi:["Tarkista"],uk:["Перевірити"],ro:["Verifică","Verifică acum"],ga:["Seiceáil Amach","Seiceáil Amach Anois"],el:["Έλεγχος","Ελέγξτε τώρα"],sr:["Proveri","Proveri sada"],bs:["Provjeri","Provjeri sada"],hr:["Provjeri","Provjeri sada"],lb:["Kuckt eraus","Kuckt elooscht elo maachen"],sq:["Kontrollo","Kontrollo tani"],da:["Tjek ud","Tjek ud nu"]},footer_navigation_label:{en:["Footer Menu"],"en-GB":["Footer Menu"],"en-CA":["Footer Menu"],he:["תפריט תחתון"],ar:["قائمة التذييل"],de:["Fußzeilenmenü"],fr:["Menu de pied de page"],it:["Menu piè di pagina"],es:["Menú de pie de página"],ja:["フッターメニュー"],nl:["Voettekstmenu"],pt:["Menu do rodapé"],pl:["Menu stopki"],ru:["Меню нижнего колонтитула"],tw:["頁尾選單"],tr:["Altbilgi Menüsü"],ua:["Меню нижнього колонтитула"],zh:["页脚菜单"],sl:["Meni noge"],sk:["Menu päty"],hu:["Lábléc menü"],cs:["Menu zápatí"],sv:["Sidfotsmeny"],no:["Bunntekstmeny"],fi:["Alatunnistevalikko"],uk:["Меню нижнього колонтитула"],ro:["Meniu subsol"],ga:["Roghchlár Buntásca"],el:["Μενού υποσέλιδου"],sr:["Meni podnožja"],bs:["Meni podnožja"],hr:["Izbornik podnožja"],lb:["Fousszeile Menü"],sq:["Menuja e fundfaqes"],da:["Sidefodsmenu"]},header_navigation_label:{en:["Header Menu"],"en-GB":["Header Menu"],"en-CA":["Header Menu"],he:["תפריט עליון"],ar:["قائمة الرأس"],de:["Kopfzeilenmenü"],fr:["Menu d'en-tête"],it:["Menu intestazione"],es:["Menú de encabezado"],ja:["ヘッダーメニュー"],nl:["Koptekstmenu"],pt:["Menu do cabeçalho"],pl:["Menu nagłówka"],ru:["Меню верхнего колонтитула"],tw:["頁首選單"],tr:["Üstbilgi Menüsü"],ua:["Меню верхнього колонтитула"],zh:["页眉菜单"],sl:["Meni glave"],sk:["Menu hlavičky"],hu:["Fejléc menü"],cs:["Menu záhlaví"],sv:["Sidhuvudmeny"],no:["Topptekstmeny"],fi:["Ylätunnistevalikko"],uk:["Меню верхнього колонтитула"],ro:["Meniu antet"],ga:["Roghchlár Ceanntásca"],el:["Μενού κεφαλίδας"],sr:["Meni zaglavlja"],bs:["Meni zaglavlja"],hr:["Izbornik zaglavlja"],lb:["Kappzeile Menü"],sq:["Menuja e kreut"],da:["Sidehovedmenu"]},inner_content_navigation_label:{en:["Inner Menu"],"en-GB":["Inner Menu"],"en-CA":["Inner Menu"],he:["תפריט פנימי"],ar:["القائمة الداخلية"],de:["Innenmenü"],fr:["Menu interne"],it:["Menu interno"],es:["Menú interno"],ja:["内部メニュー"],nl:["Intern menu"],pt:["Menu interno"],pl:["Menu wewnętrzne"],ru:["Внутреннее меню"],tw:["內部選單"],tr:["İç Menü"],ua:["Внутрішнє меню"],zh:["内部菜单"],sl:["Notranji meni"],sk:["Vnútorné menu"],hu:["Belső menü"],cs:["Vnitřní menu"],sv:["Intern meny"],no:["Intern meny"],fi:["Sisäinen valikko"],uk:["Внутрішнє меню"],ro:["Meniu intern"],ga:["Roghchlár Inmheánach"],el:["Εσωτερικό μενού"],sr:["Unutrašnji meni"],bs:["Unutrašnji meni"],hr:["Unutarnji izbornik"],lb:["Bannenmenü"],sq:["Menu e brendshme"],da:["Intern menu"]}};},574:(e,a)=>{var r;Object.defineProperty(a,"__esModule",{value:!0}),a.LocaleEnum=void 0,function(e){e.en="en",e["en-GB"]="en-GB",e["en-CA"]="en-CA",e.he="he",e.ar="ar",e.de="de",e.fr="fr",e.it="it",e.es="es",e.ja="ja",e.nl="nl",e.pt="pt",e.pl="pl",e.ru="ru",e.tw="tw",e.tr="tr",e.ua="ua",e.zh="zh",e.sl="sl",e.sk="sk",e.hu="hu",e.cs="cs",e.sv="sv",e.no="no",e.fi="fi",e.uk="uk",e.ro="ro",e.ga="ga",e.el="el",e.sr="sr",e.bs="bs",e.hr="hr",e.lb="lb",e.sq="sq",e.da="da";}(r||(a.LocaleEnum=r={}));},695:(e,a)=>{Object.defineProperty(a,"__esModule",{value:!0}),a.findPattern=function(e,a,r){if(e===a)return !0;const n=a.replace(/[.*+?^${}()|[\]\\]/g,"\\$&"),i=["en","en_gb","en_ca","de","fr","it","es","nl","pt","pl","tr","sl","sk","hu","cs","sv","no","fi","uk","ro","ga","el","sr","bs","hr","lb","sq","da"].includes(r)?`(?<!\\p{L})${n.replace(/\s+/g,"\\s+")}(?!\\p{L})`:n.replace(/\s+/g,"\\s+");return new RegExp(i,"iu").test(e)};},993:(e,a)=>{Object.defineProperty(a,"__esModule",{value:!0}),a.linkingLetters=void 0,a.linkingLetters={he:["ה","ו","ב","כ","ל","מ","ש","ת"],ar:["و","ب","ف","ك","ل"],de:["d","z","b","k","l","m","v","r"],fr:["l","d'","n'","s'","t'","m'","c'","j'","qu'","d","n","s","t","m","c","j","qu","e"],it:["l","d","s","t","m","c","n","a","o"],es:["el","la","los","las","un","una","unos","unas"],ja:[],nl:["de","het","een"],pt:["o","a","os","as","um","uma","uns","umas"],pl:["i","w","z","na","do","za","o","po"],ru:["и","в","на","под","с","о","к","от","ы","а","у"],tw:[],tr:["ve","bir","ile","ya"],ua:["і","та","або","але","бо","для","и","ня"],zh:[],sl:["in","v","na","z","k","o"],sk:["a","v","na","za","pod","s"],hu:["és","vagy","de","mert","ra"],cs:["a","v","na","za","pod","s"],sv:["och","att","som","med","utan","en","ett","den","det","n"],no:["og","at","som","med","uten","en","ei","et","den","det","n"],fi:["ja","vai","mutta","koska","sekä","lle"],uk:["і","та","або","але","бо","для","и","ня"],ro:["și","sau","dar","deoarece","la","ă","a"],ga:["agus","nó","ach","mar","le"],el:["και","ή","αλλά","επειδή","σε"],sr:["и","или","али","зато","за","у","а"],bs:["i","ili","ali","zato","za","u"],hr:["i","ili","ali","zato","za","u"],lb:["an","oder","awer","well","bei"],sq:["dhe","ose","por","sepse","në"],da:["og","eller","men","fordi","på","n"]};}},a={};return function r(n){var i=a[n];if(void 0!==i)return i.exports;var t=a[n]={exports:{}};return e[n].call(t.exports,t,t.exports,r),t.exports}(156)})())); 
    	} (dist));
    	return dist.exports;
    }

    var distExports = /*@__PURE__*/ requireDist();

    /**
     * Get the type of component of an element, i.e. what is the element's purpose (close, search etc.)
     */
    class ComponentMatch extends Operation {
        targetElement;
        resources;
        classifier;
        /**
         * @inheritdoc
         */
        static dependencies = [];
        /**
         * @inheritdoc
         */
        operations;
        constructor(targetElement, resources, classifier) {
            super();
            this.targetElement = targetElement;
            this.resources = resources;
            this.classifier = classifier;
            this.operations = this.classifier.getOperations(this.targetElement);
        }
        // A util remove a list of strings from a source string
        static removeChars(str, removalCandidates) {
            for (const candidate of removalCandidates) {
                str = str.replaceAll(candidate, "");
            }
            return str;
        }
        /**
         * @generator
         * @param element the element for which we want to extract the children contexts
         * @param classifier the classifier instance to use for extracting the context
         * @yields the context of the children of the element
         */
        static *extractChildContexts(element, classifier) {
            // Getting all the classes and attributes of the element's children
            const walker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT);
            while (walker.nextNode()) {
                const child = walker.currentNode;
                // Extract the related textual content that can be associated with the element (labels, aria-contents etc.)
                const operations = classifier.getOperations(child);
                const { relatedText } = operations.contentInfo;
                yield relatedText.toLowerCase();
                const childContexts = extractElementContexts(child);
                for (const childContext of childContexts) {
                    yield childContext;
                }
            }
        }
        /**
         * Getting a context part of the element, each part represents:
         * 1. elements background image (if exists)
         * 2. all related text content for the element
         * 3. lightly manipulated strings as generated using the {@link extractElementContexts} generator
         *
         * @generator
         * @param element Element from which to extract contextual strings
         * @param operations The OperationService instance to use for extracting the context
         * @param classifier The classifier instance to use for extracting the context
         * @yields strings representing a part of the elements contextual content
         */
        static *extractContexts({ element, operations, classifier, includeChildren }) {
            const domain = window.location.hostname.replace("www", "");
            /**
             * background-image link might contain useful information about the element (icon name might be there).
             * Note that we are only checking this for the main element, and not for the children.
             * This is due to performance reasons - we want to avoid calling getComputedStyle for each child.
             */
            const { colorInfo } = operations;
            const bgImage = colorInfo.backgroundImage;
            if (bgImage !== "none") {
                yield bgImage.toLowerCase().replace(domain, "").trim();
            }
            /**
             * Removing the hostname from the URL to avoid unexpected matching based on the domain
             * For cases like a domain like "close.com" or "cart.com".
             */
            const prepareContext = (context) => {
                const ignoredWords = [domain, ...IGNORED_WORDS];
                return this.removeChars(context, ignoredWords);
            };
            // Extract all the context strings that can be associated with the element (classes, attributes etc.)
            const elementContexts = extractElementContexts(element);
            for (const context of elementContexts) {
                yield prepareContext(context);
            }
            if (includeChildren) {
                // Extract all the context strings that can be associated with the elements children (classes, attributes etc.)
                for (const context of this.extractChildContexts(element, classifier)) {
                    yield prepareContext(context);
                }
            }
        }
        /**
         * Checking for exactly matching content.
         * For example, a button with an X as content will be matched with the close matcher.
         *
         * @param text The text to match
         * @param matcherName The name of the matcher to use
         * @returns The name of the matcher that matched the text, or empty string if none found
         */
        static getExactMatch(text, matcherName) {
            const matcher = COMPONENT_MATCHERS[matcherName];
            for (const exact of matcher.exacts) {
                if (text === exact) {
                    return matcherName;
                }
            }
            return "";
        }
        /**
         * Checking for string the their inclusion in the button content will match the matcher.
         * For example, a button with the text "close this page" will be matched with the close matcher.
         *
         * @param text The text to match
         * @param matcherName The name of the matcher to use
         * @returns The name of the matcher that matched the text, or empty string if none found
         */
        static getCloseMatch(text, matcherName) {
            const matcher = COMPONENT_MATCHERS[matcherName];
            for (const word of matcher.words) {
                // eslint-disable-next-line security/detect-non-literal-regexp
                const wordRegex = new RegExp(`\\b${word}\\b`, "i");
                if (wordRegex.test(text)) {
                    return matcherName;
                }
            }
            return "";
        }
        /**
         * Checking text for an occurrence of the translation of a word in a component matcher.
         * For example, an element with the text "חיפוש" will be matched with the "search" matcher.
         *
         * @param text The text to match
         * @param matcherName The name of the matcher to use
         * @returns The name of the matcher that matched the text, or empty string if none found
         */
        static getCloseTranslationMatch(text, matcherName) {
            const matcher = COMPONENT_MATCHERS[matcherName];
            for (const word of matcher.words) {
                if (distExports.wordHasTranslation(word)) {
                    if (distExports.textContainsWord(text, word)) {
                        return matcherName;
                    }
                }
            }
            return "";
        }
        *getElementMatch({ includeChildren }) {
            for (const context of ComponentMatch.extractContexts({
                element: this.targetElement,
                operations: this.operations,
                classifier: this.classifier,
                includeChildren,
            })) {
                for (const matcherName in COMPONENT_MATCHERS) {
                    const closeMatchType = ComponentMatch.getCloseMatch(context, matcherName);
                    if (closeMatchType) {
                        yield {
                            type: closeMatchType,
                        };
                    }
                    const closeTranslationType = ComponentMatch.getCloseTranslationMatch(context, matcherName);
                    if (closeTranslationType) {
                        yield {
                            type: closeTranslationType,
                        };
                    }
                }
            }
            yield {
                type: "",
            };
        }
        get elements() {
            return this.getElementMatch({
                includeChildren: true,
            });
        }
        get elementsChildrenExcluded() {
            return this.getElementMatch({
                includeChildren: false,
            });
        }
        get elementChildrenExcluded() {
            return this.elementsChildrenExcluded.next().value;
        }
        get element() {
            return this.elements.next().value;
        }
        *getContentMatch() {
            const contentInfo = this.operations.contentInfo;
            const visibleText = contentInfo.visibleText.toLowerCase();
            const allText = contentInfo.allText.toLowerCase();
            for (const matcherName in COMPONENT_MATCHERS) {
                // Trying to match an exact method type from the visible text of the element (e.g. "close" for "X" or "search" for "🔍")
                const exactMatchType = ComponentMatch.getExactMatch(visibleText, matcherName);
                if (exactMatchType) {
                    yield {
                        type: exactMatchType,
                        exactMatch: true,
                    };
                }
                const closeMatchType = ComponentMatch.getCloseMatch(allText, matcherName);
                if (closeMatchType) {
                    yield {
                        type: closeMatchType,
                        exactMatch: false,
                    };
                }
                const translationMatchType = ComponentMatch.getCloseTranslationMatch(allText, matcherName);
                if (translationMatchType) {
                    yield {
                        type: translationMatchType,
                        exactMatch: false,
                    };
                }
            }
            yield {
                type: "",
                exactMatch: false,
            };
        }
        get content() {
            return this.contents.next().value;
        }
        get contents() {
            return this.getContentMatch();
        }
    }

    /**
     * Retries all ancestors for given element
     * @param element the element to get ancestors for
     * @param root the root element to stop at
     */
    function* getAncestors(element, root = document.body) {
        let parent = element.parentElement;
        while (parent && parent !== root.parentElement) {
            yield parent;
            parent = parent.parentElement;
        }
    }

    const isElementOverflowed = (element) => {
        return element.scrollHeight > element.clientHeight || element.scrollWidth > element.clientWidth;
    };

    /**
     * Extracts the values from a CSS `rect` value string, ie: `inset(1px 2px 3px 4px)` => `['1px', '2px', '3px', '4px']`
     */
    const extractCssRectValues = (valueString) => {
        const regex = /(-?\d*\.?\d+(?:px|%|em|rem|vh|vw)?)/g;
        const values = valueString.match(regex) || [];
        const [top, right, bottom, left] = values;
        if (values.length === 0)
            return ["", "", "", ""];
        if (values.length === 1)
            return [top, top, top, top];
        if (values.length === 2)
            return [top, right, top, right];
        if (values.length === 3)
            return [top, right, bottom, right];
        return [top, right, bottom, left];
    };

    /**
     * given a matrix, return the transposed matrix, i.e:
     * [[1, 2, 3], [4, 5, 6]] => [[1, 4], [2, 5], [3, 6]]
     */
    const transposeMatrix = (matrix) => {
        return matrix[0].map((_, i) => matrix.map((row) => row[i])).map((row) => [...new Set(row)]);
    };

    /**
     * Get the center point of an element
     */
    const getElementCenterPoint = (rect) => {
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        return { x: centerX, y: centerY };
    };

    /**
     * Get the proximity between two element rects by using their center points.
     * instead of the need to determine which element is positioned before the other,
     * we calculate the distance between the two center points while subtracting the half width and half height of the two elements.
     */
    const getElementProximity = (rectA, rectB) => {
        const centerA = getElementCenterPoint(rectA);
        const centerB = getElementCenterPoint(rectB);
        const xDistance = Math.max(Math.abs(centerA.x - centerB.x) - rectA.width / 2 - rectB.width / 2, 0);
        const yDistance = Math.max(Math.abs(centerA.y - centerB.y) - rectA.height / 2 - rectB.height / 2, 0);
        return { x: xDistance, y: yDistance };
    };

    /**
     * Determines whether the given element is a button like input.
     * if the element is an input with that it's value is used as the button's label or if it's an image button, then it's a button like input.
     */
    const isButtonLikeInput = (element) => {
        return inputButtonWithValueAsLabel(element) || isImageButton(element);
    };
    const inputButtonWithValueAsLabel = (element) => {
        return element.matches("input[type=button], input[type=submit], input[type=reset]");
    };
    const isImageButton = (element) => {
        return element.matches("input[type=image]");
    };

    /**
     * Checks if the given href corresponds to a valid Shopify cart endpoint.
     * These endpoints are used for cart operations like adding, changing, clearing, or updating cart items.
     *
     * @param href - The href attribute value to check
     * @returns `true` if the href starts with a valid Shopify cart endpoint, `false` otherwise
     * @private
     */
    function validShopifyCartEndpoints(href) {
        const validEndpoints = ["/cart/add", "/cart/change", "/cart/clear", "/cart/update"];
        return validEndpoints.some((endpoint) => href.startsWith(endpoint));
    }
    /**
     * Determines whether the given element a button like anchor.
     * if the element has a href attribute that starts with javascript: or #, it's a button like anchor.
     * - `javascript:` is used to execute javascript code,
     * - `#` is used to link to an anchor on the same page.
     * @param element the element to check
     * @private
     *
     * NOTE: this is considered a bad practice to use js in href attribute, or anchor with onClick event, but sites still do it and we consider them as buttons.
     * @see https://github.com/dequelabs/eslint-plugin-jsx-a11y/blob/584d21a95f1aaf8a14a0c499fdece82a3bda87de/docs/rules/anchor-is-valid.md
     */
    const isButtonLikeAnchor = (element) => {
        if (element.tagName !== "A")
            return false;
        const href = element.getAttribute("href");
        return !href || href.startsWith("javascript:") || href === "#" || validShopifyCartEndpoints(href);
    };

    /**
     * a utility class that provides methods to get the client rects and bounding client rects of a node via the Range API.
     */
    class NodeRects {
        node;
        range;
        constructor(node) {
            this.node = node;
            this.range = document.createRange();
        }
        get nodeContentsClientRects() {
            this.range.selectNodeContents(this.node);
            return this.range.getClientRects();
        }
        get nodeContentsBoundingClientRect() {
            this.range.selectNodeContents(this.node);
            return this.range.getBoundingClientRect();
        }
        get clientRects() {
            this.range.selectNode(this.node);
            return this.range.getClientRects();
        }
        get boundingClientRect() {
            this.range.selectNode(this.node);
            return this.range.getBoundingClientRect();
        }
    }

    /**
     * Checking if element's coords are within the parent's coords.
     * This is a shorthand to have the conditions in one place.
     */
    function isWithinBoundsByCoords(elementRect, parentRect) {
        return elementRect.left >= parentRect.left && elementRect.right <= parentRect.right && elementRect.top >= parentRect.top && elementRect.bottom <= parentRect.bottom;
    }

    /**
     * Returns the parent element of a given node if it is an SVG or HTML element and returns the host element if the node is inside a shadow root.
     *
     * TODO: consider having this logic to be seemless by integrating it to sanitizer, so we can continue checking `parentElement` without needing to use this function manually.
     */
    const getParentElement = (element) => {
        if (isSvgOrHtmlElement(element.parentElement)) {
            return element.parentElement;
        }
        const rootNode = element.getRootNode();
        if (isInstanceOf(rootNode, ShadowRoot)) {
            if (isSvgOrHtmlElement(rootNode.host)) {
                return rootNode.host;
            }
        }
        return null;
    };

    /**
     * gets all the repetitive element paths and the number of their occurrences grouped by the path identifier string ([A, LI, DIV] => "ALIDIV")
     */
    const getRepetitivePathOccurrences = (root, elements) => {
        const pathOccurrences = new Map();
        for (const element of elements) {
            let elementsPathIdentifier = "";
            let parent = element;
            const path = [];
            while (parent && parent !== getParentElement(root)) {
                if (parent === element) {
                    /**
                     * there are instances where the tag name is different but the element is of the same "type/trait/component", so we add an underscore to have the same path identifier for the start of the path
                     * (e.g: src/perceivable/components/list-menu/atomic-tests/pass/menu-with-mixed-clickable-types.html).
                     */
                    elementsPathIdentifier += "_";
                }
                else {
                    elementsPathIdentifier += parent.tagName;
                }
                path.push(parent);
                parent = getParentElement(parent);
            }
            if (elementsPathIdentifier) {
                pathOccurrences.set(elementsPathIdentifier, pathOccurrences.get(elementsPathIdentifier) ? pathOccurrences.get(elementsPathIdentifier)?.add(path) : new Set([path]));
            }
        }
        return pathOccurrences;
    };

    /**
     * checks if all given elements are siblings
     */
    const allElementsAreSiblings = (elements) => {
        const parent = elements[0]?.parentElement;
        return elements.every((el) => el.parentElement === parent);
    };

    /**
     * A safe version of the closest method that will stop searching after a certain number of iterations
     * If you know how far the parent element with the tag is, you better use this function for better performance.
     * Example: the <table> tag, when searching from a <td> tag.
     * We know that the <table> tag is at most 3 levels up from the <td> tag, so we can set maxIterations to 3.
     * If it's not there, no need to search further.
     *
     * @param element Element to start the search from
     * @param tag HTML Tag to search for
     * @param maxIteration Maximum number of iterations to search for the tag (default 5)
     * @returns The closest element with the given tag or null if not found within the maxIterations
     */
    function safeClosest(element, tag, maxIterations = 5) {
        let currentElement = element;
        let safetyCounter = 0;
        while (currentElement && safetyCounter < maxIterations) {
            if (currentElement.tagName === tag.toUpperCase()) {
                return currentElement;
            }
            currentElement = currentElement.parentElement;
            safetyCounter++;
        }
        return null;
    }

    /**
     * Checks if the total length of the visible text generated by the generator is within the specified length range.
     *
     * @param {IterableIterator<string>} textGenerator - The generator that yields visible text.
     * @param {LengthOptions} options - The length options object.
     * @param {number} options.min - The minimum length to check against (defaults to 0).
     * @param {number} options.max - The maximum length to check against.
     * @returns {boolean} - Returns `true` if the total length is between `minLength` and `maxLength`, otherwise `false`.
     */
    function isTextLengthInRange(textGenerator, options) {
        const { min = 0, max } = options;
        let counter = 0;
        for (const text of textGenerator) {
            counter += text.trim().length;
            if (counter >= max) {
                return false;
            }
        }
        return counter >= min;
    }

    /**
     * Returns all descendant elements of the given root (equivalent to querySelectorAll("*")) while also handling shadow DOMs and iframes.
     */
    function getAllDescendants(root) {
        const descendants = [];
        const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);
        /**
         * Note: we are starting from the root element itself, while excluding it from the results.
         * this is done because if we run nextNode() when the element is a document-fragment or an iframe it will return null and we will not be able to traverse its children.
         */
        let current = walker.root;
        while (current) {
            if (!isInstanceOf(current, Element)) {
                current = walker.nextNode();
                continue;
            }
            /**
             * Skip the root element itself if it is not the root of the search
             */
            if (current !== root) {
                descendants.push(current);
            }
            /**
             * If the current element is a shadow host, recursively get its shadow DOM descendants.
             */
            if (current.shadowRoot) {
                descendants.push(...getAllDescendants(current.shadowRoot));
            }
            /**
             * If the current element is an iframe, try to access its contentWindow and get its descendants.
             */
            if (isInstanceOf(current, HTMLIFrameElement)) {
                try {
                    const iframeContext = current.contentWindow;
                    if (iframeContext?.document) {
                        descendants.push(...getAllDescendants(iframeContext.document));
                    }
                }
                catch (error) { } // omit cross-origin errors
            }
            current = walker.nextNode();
        }
        return descendants;
    }

    /**
     * Returns the larger of two DOMRects based on rendered area.
     *
     * Comparison uses the visual area defined as:
     *    area = rect.width * rect.height
     *
     * If both rectangles have equal area, the first rectangle is returned.
     *
     * @param rectA - The DOMRect of the first element.
     * @param rectB - The DOMRect of the second element.
     * @returns The DOMRect with the larger calculated area. If one rectangle is null, returns the other. If both are null, returns null.
     */
    function getLargerRect(rectA, rectB) {
        if (!rectA && !rectB)
            return null;
        if (!rectA)
            return rectB;
        if (!rectB)
            return rectA;
        const areaA = rectA.width * rectA.height;
        const areaB = rectB.width * rectB.height;
        return areaA >= areaB ? rectA : rectB;
    }

    function getLowestCommonAncestor(element1, element2) {
        const path1 = [];
        let current1 = element1;
        // Build the path from element1 to the root
        while (current1) {
            path1.push(current1);
            current1 = current1.parentElement;
        }
        const path2 = [];
        let current2 = element2;
        // Build the path from element2 to the root
        while (current2) {
            path2.push(current2);
            current2 = current2.parentElement;
        }
        let lowestCommonAncestor;
        // Find the common ancestor
        while (path1.length > 0 && path2.length > 0) {
            const ancestor1 = path1.pop();
            const ancestor2 = path2.pop();
            if (ancestor1 === ancestor2) {
                lowestCommonAncestor = ancestor1;
            }
            else {
                break;
            }
        }
        return lowestCommonAncestor;
    }

    /**
     * Get the lowest common ancestor of many elements
     * @param elements
     */
    function getLowestCommonAncestorOfMany(elements) {
        if (!elements.length) {
            return null;
        }
        let lca = elements[0];
        for (let i = 1; i < elements.length; i++) {
            lca = getLowestCommonAncestor(lca, elements[i]);
            if (!lca) {
                return null;
            }
        }
        return lca;
    }

    /**
     * * Sort elements by their rendered area in descending order (largest first).
     * @param elements
     * @param classifier
     * @returns {SvgOrHtmlElement[]} The sorted elements
     */
    function sortByArea(elements, classifier) {
        return elements.sort((f1, f2) => {
            const rect1 = classifier.getOperations(f1).layoutInfo.rect;
            const rect2 = classifier.getOperations(f2).layoutInfo.rect;
            const largerRect = getLargerRect(rect1, rect2);
            return largerRect === rect1 ? -1 : 1;
        });
    }

    /**
     * Utility class for handling visible text in elements.
     * @classdesc Provides methods to retrieve and check visibility of text content in elements.
     */
    class VisibleTextUtils {
        /**
         * Checks if a text node is visible (not hidden by CSS or hidden by an ancestor).
         * @param textNode - The text node to check for visibility.
         * @param classifier - The classifier instance to use for checking visibility.
         * @returns True if the text node is visible, false otherwise.
         */
        static isTextNodeVisible(textNode, classifier) {
            let ancestor = textNode.parentElement;
            while (ancestor) {
                const ancestorResource = classifier.getOperations(ancestor).resources;
                if (this.hasOverflowHidden(ancestorResource) && this.hasTextIndentOverflow(ancestorResource, textNode)) {
                    return false;
                }
                ancestor = ancestor.parentElement;
            }
            return true;
        }
        /**
         * Checks if an element has overflow:hidden.
         * @param ancestorResources - The resources of the ancestor element to check for overflow:hidden.
         * @returns True if the element has overflow:hidden, false otherwise.
         */
        static hasOverflowHidden(ancestorResources) {
            return ancestorResources.computedStyle.overflow === "hidden";
        }
        /**
         * Checks if the text-indent causes the textNode to overflow.
         * @param ancestorResources - The resources of the ancestor element to check for text-indent overflow.
         * @param textNode - The text node to check for text-indent overflow.
         * @returns True if the textNode overflows due to text-indent, false otherwise.
         */
        static hasTextIndentOverflow(ancestorResources, textNode) {
            const parentComputedStyle = ancestorResources.computedStyle;
            const parentBoundingRect = ancestorResources.boundingClientRect;
            const textIndent = parseFloat(parentComputedStyle.textIndent);
            const nodeRect = new NodeRects(textNode).boundingClientRect;
            const parentRect = parentBoundingRect;
            return nodeRect.left + textIndent < parentRect.left || nodeRect.right + textIndent > parentRect.right;
        }
    }

    class PerceivableDetector extends Detector {
        /** @inheritDoc */
        static type = "perceivable";
    }

    /**
     * Detector whether element is Renderable.
     * Meaning they have a visual representation
     */
    class PerceivableTraitRenderable extends PerceivableDetector {
        /** @inheritDoc */
        static id = "perceivable-trait-renderable";
        /** @inheritDoc */
        static skipChildrenWhen = "negative";
        /** @inheritDoc */
        static ignoreUpdates = true;
        /** @inheritDoc */
        static subsetOf = [];
        /**
         * Non renderable tag names
         */
        static nonRenderableTagNames = ["SCRIPT", "OPTION", "NOSCRIPT", "STYLE", "BR", "LINK", "META", "HTML", "HEAD", "SOURCE", "PATH"];
        /** @inheritDoc */
        static detect(element) {
            if (!element.isConnected) {
                return false;
            }
            for (const selector of PerceivableTraitRenderable.nonRenderableTagNames) {
                if (element.tagName === selector) {
                    return false;
                }
            }
            if (element.matches("svg *:not(foreignObject, foreignObject *)")) {
                return false;
            }
            return true;
        }
    }

    class CompliantDetector extends Detector {
        /** @inheritDoc */
        static skipChildrenWhen = "never";
        /** @inheritDoc */
        static type = "compliant";
    }

    /**
     * Detector whether screen-reader will consider given `element` as a generic.
     */
    class CompliantTraitGeneric extends CompliantDetector {
        /** @inheritDoc */
        static id = "compliant-trait-generic";
        /** @inheritDoc */
        static subsetOf = [];
        /** @inheritDoc */
        static detect(element) {
            return element.matches("div:not([role]), div[role=''], span:not([role]), span[role=''], b:not([role]), b[role=''], i:not([role]), i[role=''], [role=generic]");
        }
    }

    /**
     * Detector whether element is interactable.
     * Meaning the user can interact with it.
     */
    class CompliantTraitInteractable extends CompliantDetector {
        /** @inheritDoc */
        static id = "compliant-trait-interactable";
        /** @inheritDoc */
        static skipChildrenWhen = "never";
        /** @inheritDoc */
        static subsetOf = [];
        /**
         * Selector for interactable elements
         */
        static interactableSelectors = [
            "a[href]:not([disabled], [aria-disabled='true'])",
            "button:not([disabled], [aria-disabled='true'])",
            "input:not([disabled], [aria-disabled='true'])",
            "select:not([disabled], [aria-disabled='true'])",
            "textarea:not([disabled], [aria-disabled='true'])",
            "[contenteditable]:not([contenteditable='false'], [disabled], [aria-disabled='true'])",
            "audio[controls]:not([disabled], [aria-disabled='true'])",
            "video[controls]:not([disabled], [aria-disabled='true'])",
            "details:not([disabled], [aria-disabled='true'])",
            "[role=button]:not([disabled], [aria-disabled='true'])",
            "[role=link]:not([disabled], [aria-disabled='true'])",
            "[role=checkbox]:not([disabled], [aria-disabled='true'])",
            "[role=radio]:not([disabled], [aria-disabled='true'])",
            "[role=menuitem]:not([disabled], [aria-disabled='true'])",
            "[role=tab]:not([disabled], [aria-disabled='true'])",
            "[role=slider]:not([disabled], [aria-disabled='true'])",
            "[role=searchbox]:not([disabled], [aria-disabled='true'])",
            "[role=spinbutton]:not([disabled], [aria-disabled='true'])",
            "[role=textbox]:not([disabled], [aria-disabled='true'])",
            "[draggable]:not([disabled], [aria-disabled='true'], [draggable='false'])",
        ].join(", ");
        /** @inheritDoc */
        static detect(element) {
            return element.matches(this.interactableSelectors);
        }
    }

    /**
     * Detector whether screen-reader will consider element content as visible.
     */
    class CompliantTraitVisible extends CompliantDetector {
        /** @inheritDoc */
        static id = "compliant-trait-visible";
        /** @inheritDoc */
        static skipChildrenWhen = (element, classifier) => {
            if (element.matches("[hidden], [aria-hidden=true], [inert]")) {
                return true;
            }
            const { visibilityInfo } = classifier.getOperations(element);
            if (visibilityInfo.display === "none") {
                return true;
            }
            return false;
        };
        /** @inheritDoc */
        static subsetOf = [PerceivableTraitRenderable];
        /**
         * TODO: Implement dependency sorting between Operation Dependencies.
         *
         * We have to add CompliantTraitInteractable as a dependency because the operation dependencies are added in alphabetical
         * order of the operation names. This means that CompliantTraitVisible would be added after CompliantTraitInteractable, which breaks isAffectedByRolePresentation.
         */
        /** @inheritDoc */
        static dependencies = [CompliantTraitGeneric, CompliantTraitInteractable];
        /** @inheritDoc */
        static detect(element, classifier) {
            if (element.matches("[hidden], [aria-hidden=true], [inert]")) {
                return false;
            }
            const { visibilityInfo } = classifier.getOperations(element);
            if (visibilityInfo.display === "none") {
                return false;
            }
            if (visibilityInfo.visibility === "hidden") {
                return false;
            }
            // Empty div should not be detected as visible
            if (classifier.assert(element, CompliantTraitGeneric) && !element.childNodes.length && visibilityInfo.isAffectedByRolePresentation) {
                return false;
            }
            return true;
        }
    }

    /**
     * Detects if an element is visible in screen reader only
     *
     * explanation of sr-only use cases:
     * @see https://www.useragentman.com/enable/screen-reader-only-text.php#:~:text=Screen%20reader%20only%20text%20(also,visual%20text%20on%20the%20screen.
     * @see https://webaim.org/techniques/css/invisiblecontent/
     * @see https://enterprise-accessibility.vercel.app/topics/accessible-uis/visibility-methods#visually-hidden-or-sr-only-css-classes
     * @see https://www.a11yproject.com/posts/how-to-hide-content/
     * @see https://github.com/txstate-etc/svelte-components/blob/main/docs/ScreenReaderOnly.md
     * @see https://ionic.io/docs/accessibility/visibility
     * @see https://gist.github.com/ffoodd/000b59f431e3e64e4ce1a24d5bb36034
     * @see https://tailwindcss.com/docs/screen-readers
     * @see https://getbootstrap.com/docs/5.3/getting-started/accessibility/#visually-hidden-content
     * @see https://chakra-ui.com/docs/components/visually-hidden/usage
     * @see https://reach.tech/visually-hidden/
     * @see https://www.tpgi.com/the-anatomy-of-visually-hidden/ - this article explaines the reasoning behing each of the css rules used for sr-only
     *
     * conculusions:
     * - checking if element is Tabbable isn't accurate because sr-only elements can also be not-tabbable, e.g:
     *  `<p class="text-danger"><span class="visually-hidden">Danger: </span>This action is not reversible</p>`
     */
    class PerceivableTraitScreenReaderOnly extends PerceivableDetector {
        /** @inheritDoc */
        static id = "perceivable-trait-screen-reader-only";
        /** @inheritDoc */
        static skipChildrenWhen = "positive";
        /** @inheritDoc */
        static subsetOf = [
            CompliantTraitVisible,
            /**
             * eliminate irrelevant elements by checking if they are interactable
             */
            PerceivableTraitRenderable,
        ];
        /**
         * list of common sr-only related classes
         */
        static selector = [
            ".sr-only", // https://webaim.org/techniques/css/invisiblecontent/, https://tailwindcss.com/docs/screen-readers
            ".element-invisible", // https://snook.ca/archives/html_and_css/hiding-content-for-accessibility
            ".visually-hidden", // https://getbootstrap.com/docs/5.3/getting-started/accessibility/#visually-hidden-content
            ".sronly",
            ".sr-text",
            ".srtext",
            ".show-for-sr", // https://get.foundation/sites/docs/visibility.html
            ".text-for-sr",
            ".screen-reader",
            ".screen-reader-only",
            ".screen-reader-text",
            ".screen-reader-only-text",
            ".elementor-screen-only",
        ].join(",");
        /**
         * Detects if an element is visible in screen reader only
         */
        static detect(element, classifier) {
            /**
             * REMOVED:
             *      let spansOnly   = true;
             *      const $children = AJS.picks('*', $el);
             *
             *      for( let $child of $children ) {
             *          if( $child.tagName !== 'SPAN' || Utilities.isClickable($child) ) {
             *              spansOnly = false;
             *              break;
             *          }
             *      }
             *
             *
             *      if( $children.length > 0 && ! spansOnly ) return false;
             *
             *    TODO: check why is this necessary
             */
            /**
             *   REMOVED:
             *       try {
             *          JSON.parse(text);
             *          return false;
             *      } catch( err ) {
             *
             *      }
             *
             *  REASON:
             *  redundant check
             */
            /**
             *  REMOVED:
             *  if( $el.closest('[data-acsb]')
             *      || AJS.elements.style($el, 'background-image') !== 'none'
             *      || ! ['SPAN', 'A', 'DIV', 'STRONG', 'P', 'B', 'LABEL'].includes($el.tagName) ) {
             *      return false;
             *  }
             *
             * REASON:
             * - there is no reason to exclude these elements since they are usualy used as sr-only elements
             * - the background-image check isn't necessary since we can rely on text nodes being present (this might have been used to check for sr-only:focus styles @see https://make.wordpress.org/accessibility/handbook/markup/the-css-class-screen-reader-text/#the-css)
             */
            const { visibilityInfo, layoutInfo } = classifier.getOperations(element);
            /**
             * checking if the element is absolute or fixed positioned (core requirement for sr-only elements to remove them from the document flow)
             */
            const isAbsoluteOrFixed = ["absolute", "fixed"].includes(layoutInfo.position);
            if (!isAbsoluteOrFixed) {
                return false;
            }
            /**
             * if the element's display is none, it's invisible both to the screen and to screen readers
             */
            if (visibilityInfo.display === "none") {
                return false;
            }
            /**
             *  if element doesn't have any sr-visible text, it's not sr-only
             */
            if (!classifier.getOperations(element).contentInfo.srVisibleText) {
                return false;
            }
            /**
             * if the element has visibility hidden, it's invisible to screen readers
             * note: we negate this for preventing false-positives by checking for common classes that are used for sr-only elements
             */
            if (visibilityInfo.isElementAndChildrenHidden && !element.matches(this.selector)) {
                return false;
            }
            if (visibilityInfo.isVisuallyHidden) {
                return true;
            }
            return false;
        }
    }

    /**
     * The detector for tabbable elements, incorporates some logic from the `tabbable` package @see https://github.com/focus-trap/tabbable
     */
    class PerceivableTraitTabbable extends PerceivableDetector {
        /** @inheritDoc */
        static id = "perceivable-trait-tabbable";
        /** @inheritDoc */
        static skipChildrenWhen = "never";
        /** @inheritDoc */
        static subsetOf = [PerceivableTraitRenderable];
        /**
         * Determines whether the given element is focusable via selector
         * @see //https://github.com/focus-trap/tabbable/blob/b8c755009a35fd2c37a3748c8c6b11b462212f04/src/index.js#L1
         *
         * NOTE:
         * - we might want to replace this with a more robust selector with consideration to `inert` due to JSDOM limitations: @see https://github.com/focus-trap/tabbable/blob/2cbb8493b7619db3b811b9d626ccfac8ad831441/src/index.js#L6
         */
        static isFocusableElement(element) {
            const tagNames = ["input", "select", "textarea", "button"];
            for (const tagName of tagNames) {
                if (element.localName === tagName) {
                    return element.tabIndex > -1;
                }
            }
            //contenteditable ignores tabindex, so we need to check it separately (can be element.isContentEditable as well)
            if (element.matches("[contenteditable]")) {
                return true;
            }
            const selectors = ["a[href]", "[tabindex]:not(slot)", "details>summary:first-of-type"];
            for (const selector of selectors) {
                if (element.matches(selector)) {
                    return element.tabIndex > -1;
                }
            }
            return false;
        }
        /**
         * Determines whether the given element is inert, if it or it's parent have inert attribute.
         */
        static isInert(element) {
            return element.matches("[inert], [inert] *");
        }
        /**
         * Determines whether the given element is disabled
         *
         * NOTE: we are using `element.matches(':disabled')` and not `element.disabled` because there can be cases where element's prototype was manipulated to have a "fake" disabled property.
         * in this instance, `matches` works as expected, returning false while the latter returns true.
         */
        static isElementDisabled(element) {
            return element.matches(":disabled");
        }
        /**
         * Determines whether the given element is tabbable,
         * Based on ALL the following rules:
         * 1. element matches the `tabbableSelector`
         * 2. element is focusable
         * 3. element is visible
         * 4. element has a tabbable parent
         */
        static detect(element, classifier) {
            /**
             * REPLACES:
             *  if ($el.getAttribute("tabindex") === "-1" || $el.matches(":disabled, [inert], [inert] *"))
             *  return false;
             */
            if (!this.isFocusableElement(element)) {
                return false;
            }
            if (this.isElementDisabled(element)) {
                return false;
            }
            if (this.isInert(element)) {
                return false;
            }
            const { visibilityInfo } = classifier.getOperations(element);
            if (visibilityInfo.display === "none") {
                return false;
            }
            /**
             *
             * REMOVED:
             * if ($el.getAttribute("data-aflw-clickable") === "true") {
             * if (!$el.parentElement || !$el.parentElement.closest("[data-aflw-tabbable]")) {
             *   tabbable = true;
             *  }
             * }
             *
             * REASON: if an element isnt clickable it cant eliminate the possibility of it being tabbable
             *
             */
            // if (!DetectorClickable.detect(element)) {
            //   return false;
            // }
            /**
             * REMOVED:
             * if (!tabbable && ($el.matches("[data-aflw-role=button], [data-aflw-role=link]") || this.isFormField($el))) {
             *  tabbable = true;
             * }
             *
             * REASON: this is redundant since the `tabbableSelector` already checks for these tags, also `isFormField` is not doing anything because `data-aflw-group-input` is never set
             */
            /**
             * REMOVED:
             * if (tabbable && ($el.tagName === "AREA" || ($el.parentElement && $el.parentElement.closest("svg")))) {
             *   tabbable = false;
             * }
             *
             * REASON: there is no need to check for `area` if svg is already checked and found to be unfocusable - which is already checked by `tabbableSelector`
             */
            /**
             * REMOVED:
             * if (!tabbable && $el.closest('[data-aflw-hidden="true"], [data-aflw-clickable][data-aflw-tabbable]')) {
             * const $navigParent = $el.closest("[data-aflw-now-tabbable]");
             *
             * if ($navigParent && $navigParent.matches("[data-aflw-role=link]") && this.isButton($navigParent) && this.getStyle($el, "cursor") === "pointer" && this.getStyle($el, "pointer-events") !== "none") {
             *   const $hiddenChild = $navigParent.querySelector('[data-aflw-hidden="true"]');
             *
             *   if (($hiddenChild && $hiddenChild.contains($el) && $hiddenChild !== $el && this.getStyle($el, "cursor")) || $el.matches("[data-aflw-role=link]") || this.isButton($el)) {
             *     tabbable = true;
             *   }
             *  }
             * }
             *
             * REASON: if an element isnt tabbable according to previous conditons, it's not tabbable, and can't be considered tabbable if it's parent is.
             *
             * TODO: need to confirm this logic is actually redundant
             */
            return true;
        }
    }

    /**
     * A context that allows data to be passed between detectors and to be looked up or manipulated post-detection.
     * @template T The structured type of the context data.
     */
    class Context {
        classifier;
        /**
         * The context data for the current context.
         */
        data;
        /**
         * Gets the contextData by the type implemented by the Subclass.
         */
        get() {
            return this.data;
        }
        /**
         * Post-detection method that can be used to manipulate the context data.
         */
        postDetect;
        /**
         * Constructor for the context.
         */
        constructor(classifier) {
            this.classifier = classifier;
        }
    }

    class IntervalTreeNode {
        start;
        end;
        maxEnd;
        height;
        left = null;
        right = null;
        data;
        constructor(interval) {
            this.start = interval.start;
            this.end = interval.end;
            this.maxEnd = interval.end;
            this.data = interval.data;
            this.height = 1; // new node has height = 1
        }
    }
    /**
     * AVL Interval Tree implementation.
     * This data structure allows for efficient searching of intervals that overlap with a given interval.
     * It also supports insertion and deletion of intervals.
     * The tree is self-balancing, ensuring O(log n) time complexity for all operations.
     * The tree is augmented with a `maxEnd` field in each node, which stores the maximum end value in the subtree rooted at that node.
     * The tree also maintains an index of identifiers to intervals for quick access.
     * @see https://en.wikipedia.org/wiki/Interval_tree
     */
    class AVLIntervalTree {
        root = null;
        identifierIndex = new Map();
        /**
         * Insert a new interval into the tree.
         * @param interval - The interval to insert
         */
        insert(interval, identifier) {
            if (identifier)
                this.identifierIndex.set(identifier, interval);
            this.root = this.insertNode(this.root, interval);
        }
        /**
         * Delete the exact matching interval from the tree, if it exists.
         * @param interval - The interval to delete
         */
        delete(interval) {
            this.root = this.deleteNode(this.root, interval);
        }
        /**
         * Delete the interval with the given identifier from the tree, if it exists.
         * @param identifier - The identifier of the interval to delete
         * @returns - The new root of the tree after deletion
         */
        deleteByIdentifier(identifier) {
            const interval = this.identifierIndex.get(identifier);
            if (interval) {
                this.delete(interval);
                this.identifierIndex.delete(identifier);
            }
        }
        /**
         * Get the interval by its identifier.
         * @param identifier - The identifier of the interval
         * @returns - The interval with the given identifier, if it exists
         */
        getByIdentifier(identifier) {
            return this.identifierIndex.get(identifier);
        }
        /**
         * Find all intervals in the tree that overlap with [interval.start, interval.end].
         * @param interval - The interval to search for overlaps
         * @returns - All intervals that overlap with the given interval
         */
        searchOverlapping(interval) {
            const results = [];
            this.searchOverlappingNode(this.root, interval, results);
            return results;
        }
        /**
         * Inorder traversal (for debugging or testing).
         * @returns - All intervals in the tree, in sorted order of start values
         */
        inorderTraversal() {
            const result = [];
            this.inorder(this.root, result);
            return result;
        }
        // ---- PRIVATE HELPER METHODS ----
        /**
         * Finds the minimum node in the subtree rooted at `node`.
         * This is used for finding the inorder successor during deletion.
         * @param node - The root of the subtree
         * @returns - The node with the smallest start value in the subtree
         */
        getMinNode(node) {
            let current = node;
            while (current.left) {
                current = current.left;
            }
            return current;
        }
        /**
         * Recursively inserts a new interval in the subtree rooted at `node`.
         * Updates `height` and `maxEnd`. Balances the subtree if needed.
         * @param node - The root of the subtree
         * @param interval - The interval to insert
         * @returns - The new root of the subtree after insertion
         */
        insertNode(node, interval) {
            // 1. Standard BST insertion
            if (node === null) {
                return new IntervalTreeNode(interval);
            }
            if (interval.start < node.start) {
                node.left = this.insertNode(node.left, interval);
            }
            else {
                node.right = this.insertNode(node.right, interval);
            }
            // 2. Update height and maxEnd
            this.updateHeight(node);
            this.updateMaxEnd(node);
            // 3. Rebalance if needed
            return this.balance(node, interval);
        }
        /**
         * Balances the subtree using AVL rotations if necessary.
         * @param node - The root of the subtree to balance
         * @param interval - The interval that was inserted
         * @returns - The new root of the subtree after balancing
         */
        balance(node, interval) {
            const balanceFactor = this.getBalanceFactor(node);
            // Case A: Left-Left
            if (balanceFactor > 1 && interval.start < (node.left?.start ?? 0)) {
                return this.rotateRight(node);
            }
            // Case B: Right-Right
            if (balanceFactor < -1 && interval.start >= (node.right?.start ?? 0)) {
                return this.rotateLeft(node);
            }
            // Case C: Left-Right
            if (balanceFactor > 1 && interval.start >= (node.left?.start ?? 0)) {
                node.left = this.rotateLeft(node.left);
                return this.rotateRight(node);
            }
            // Case D: Right-Left
            if (balanceFactor < -1 && interval.start < (node.right?.start ?? 0)) {
                node.right = this.rotateRight(node.right);
                return this.rotateLeft(node);
            }
            // No balancing needed
            return node;
        }
        /**
         * Right rotation.
         * @param node - The root of the subtree to rotate
         * @returns - The new root of the subtree after rotation
         */
        rotateRight(node) {
            const leftChild = node.left;
            const t2 = leftChild.right;
            // Perform rotation
            leftChild.right = node;
            node.left = t2;
            // Update heights
            this.updateHeight(node);
            this.updateHeight(leftChild);
            // Update maxEnds
            this.updateMaxEnd(node);
            this.updateMaxEnd(leftChild);
            // Return the new root after rotation
            return leftChild;
        }
        /**
         * Left rotation.
         * @param node - The root of the subtree to rotate
         * @returns - The new root of the subtree after rotation
         */
        rotateLeft(node) {
            const rightChild = node.right;
            const t2 = rightChild.left;
            // Perform rotation
            rightChild.left = node;
            node.right = t2;
            // Update heights
            this.updateHeight(node);
            this.updateHeight(rightChild);
            // Update maxEnds
            this.updateMaxEnd(node);
            this.updateMaxEnd(rightChild);
            // Return the new root after rotation
            return rightChild;
        }
        /**
         * Get the height of a node, or 0 if the node is null.
         * @param node - The node to get the height of
         * @returns - The height of the node
         */
        getHeight(node) {
            return node ? node.height : 0;
        }
        /**
         * Update the height of a node based on its children.
         * @param node - The node to update
         */
        updateHeight(node) {
            node.height = 1 + Math.max(this.getHeight(node.left), this.getHeight(node.right));
        }
        /**
         * Get the balance factor of a node.
         * @param node - The node to get the balance factor of
         * @returns - The balance factor of the node
         */
        getBalanceFactor(node) {
            if (!node)
                return 0;
            return this.getHeight(node.left) - this.getHeight(node.right);
        }
        /**
         * Updates the node's maxEnd value based on its own interval and children.
         * @param node - The node to update
         * @returns - The new maxEnd value
         */
        updateMaxEnd(node) {
            let maxEnd = node.end;
            if (node.left) {
                maxEnd = Math.max(maxEnd, node.left.maxEnd);
            }
            if (node.right) {
                maxEnd = Math.max(maxEnd, node.right.maxEnd);
            }
            node.maxEnd = maxEnd;
        }
        /**
         * Recursive in-order traversal to collect intervals (by start order).
         * @param node - The root of the subtree to traverse
         * @param result - The array to store the intervals
         */
        inorder(node, result) {
            if (!node)
                return;
            this.inorder(node.left, result);
            result.push({ start: node.start, end: node.end, data: node.data });
            this.inorder(node.right, result);
        }
        /**
         * Search for overlapping intervals in the subtree rooted at `node`.
         * @param node - The root of the subtree to search
         * @param query - The interval to search for overlaps
         * @param results - The array to store the overlapping intervals
         * @returns - The array of overlapping intervals
         */
        searchOverlappingNode(node, query, results) {
            if (!node)
                return;
            // Check overlap
            if (this.doOverlap({ start: node.start, end: node.end, data: node.data }, query)) {
                results.push({ start: node.start, end: node.end, data: node.data });
            }
            // If left subtree might have intervals that overlap, visit it.
            if (node.left && node.left.maxEnd >= query.start) {
                this.searchOverlappingNode(node.left, query, results);
            }
            // If current node's start is <= query.end, right subtree might have overlaps
            if (node.right && node.start <= query.end) {
                this.searchOverlappingNode(node.right, query, results);
            }
        }
        /**
         * Check if two intervals overlap.
         * @param i1 - The first interval
         * @param i2 - The second interval
         * @returns - Whether the two intervals overlap
         */
        doOverlap(i1, i2) {
            return i1.start <= i2.end && i2.start <= i1.end;
        }
        /**
         * Delete a node (by interval) from the subtree rooted at `node`.
         * Returns the new root of the subtree after deletion.
         * @param node - The root of the subtree to delete from
         * @param target - The interval to delete
         * @returns - The new root of the subtree after deletion
         */
        deleteNode(node, target) {
            if (!node)
                return null;
            if (target.start < node.start) {
                node.left = this.deleteNode(node.left, target);
            }
            else if (target.start > node.start) {
                node.right = this.deleteNode(node.right, target);
            }
            else {
                // We found the node with the same (start, end)
                if (!node.left && !node.right) {
                    // No children
                    return null;
                }
                else if (!node.left) {
                    // One child (right)
                    node = node.right;
                }
                else if (!node.right) {
                    // One child (left)
                    node = node.left;
                }
                else {
                    // Two children: replace with inorder successor
                    const successor = this.getMinNode(node.right);
                    node.start = successor.start;
                    node.end = successor.end;
                    node.data = successor.data;
                    node.right = this.deleteNode(node.right, {
                        start: successor.start,
                        end: successor.end,
                        data: successor.data,
                    });
                }
            }
            this.updateHeight(node);
            this.updateMaxEnd(node);
            return this.balanceAfterDelete(node);
        }
        /**
         * Balancing after delete is slightly different:
         * We don't know which side the imbalance is on from a single key,
         * so we check the full balance factor and rotate accordingly.
         * @param node - The root of the subtree to balance
         * @returns - The new root of the subtree after balancing
         */
        balanceAfterDelete(node) {
            const balanceFactor = this.getBalanceFactor(node);
            // Left heavy
            if (balanceFactor > 1) {
                // Check if left subtree is left-heavy or right-heavy
                if (this.getBalanceFactor(node.left) >= 0) {
                    // Left-Left case
                    return this.rotateRight(node);
                }
                else {
                    // Left-Right case
                    node.left = this.rotateLeft(node.left);
                    return this.rotateRight(node);
                }
            }
            // Right heavy
            else if (balanceFactor < -1) {
                // Check if right subtree is right-heavy or left-heavy
                if (this.getBalanceFactor(node.right) <= 0) {
                    // Right-Right case
                    return this.rotateLeft(node);
                }
                else {
                    // Right-Left case
                    node.right = this.rotateRight(node.right);
                    return this.rotateLeft(node);
                }
            }
            // Balanced
            return node;
        }
    }

    /**
     * Detector whether the given element, any of its ancestors, or any of its direct children has a position of `fixed` or `sticky`.
     */
    class PerceivableTraitSticky extends PerceivableDetector {
        /** @inheritDoc */
        static id = "perceivable-trait-sticky";
        /** @inheritDoc */
        static subsetOf = [];
        /**
         * Checks if the given element has a position of `fixed` or `sticky`.
         */
        static isFixedOrSticky(element, classifier) {
            const position = classifier.getOperations(element).layoutInfo.position;
            if (position === "fixed" || position === "sticky") {
                return true;
            }
            return false;
        }
        /** @inheritDoc */
        static detect(element, classifier) {
            let currentElement = element;
            while (currentElement) {
                if (this.isFixedOrSticky(currentElement, classifier)) {
                    return true;
                }
                if (!isSvgOrHtmlElement(currentElement.offsetParent)) {
                    break;
                }
                currentElement = currentElement.offsetParent;
            }
            for (const child of element.children) {
                if (!isSvgOrHtmlElement(child)) {
                    continue;
                }
                if (this.isFixedOrSticky(child, classifier)) {
                    return true;
                }
            }
            return false;
        }
    }

    /**
     * Get the absolute rectangle of an element, accounting for scroll position and sticky positioning.
     * @param element - The element to get the absolute rectangle for
     * @param classifier - The classifier to use for better performance
     * @returns - The absolute rectangle of the element
     */
    function getAbsoluteRectFromElement(element, classifier) {
        const operations = classifier.getOperations(element);
        const absoluteRect = operations.layoutInfo.absoluteRect;
        if (classifier.getParent(element, PerceivableTraitSticky)) {
            return {
                ...absoluteRect,
                x: absoluteRect.left + window.scrollX,
                y: absoluteRect.top + window.scrollY,
                top: absoluteRect.top + window.scrollY,
                left: absoluteRect.left + window.scrollX,
                bottom: absoluteRect.top + window.scrollY,
                right: absoluteRect.right + window.scrollX,
            };
        }
        return absoluteRect;
    }
    /**
     * Check if two DOMRects are equal.
     * @param rect1 - The first DOMRect to compare
     * @param rect2 - The second DOMRect to compare
     * @returns - Whether the two DOMRects are equal
     */
    function areRectsEqual(rect1, rect2) {
        return ["x", "y", "width", "height", "top", "left", "bottom", "right"].every((key) => rect1[key] === rect2[key]);
    }

    /**
     * A spatial grid for elements, allowing for efficient querying of elements overlapping with a given element.
     */
    class ElementsSpatialGrid {
        static yAxisTree = new AVLIntervalTree();
        /**
         * Add an element to the spatial grid.
         * @param element - The element to add to the spatial grid
         * @param classifier - The classifier to use for better performance
         */
        static add(element, classifier) {
            const absoluteRect = getAbsoluteRectFromElement(element, classifier);
            const existingInterval = this.yAxisTree.getByIdentifier(element);
            if (existingInterval && !areRectsEqual(absoluteRect, existingInterval.data.rect)) {
                this.yAxisTree.deleteByIdentifier(element);
            }
            const data = { element, rect: absoluteRect };
            this.yAxisTree.insert({ start: absoluteRect.top, end: absoluteRect.top + absoluteRect.height, data }, element);
        }
        /**
         * Get all elements overlapping with a given element.
         * @param element - The element to get overlapping elements for
         * @param classifier - The classifier to use for better performance
         * @returns - All elements overlapping with the given element including the element itself
         */
        static getElementsOverlappingWithElement(element, classifier) {
            const rect = getAbsoluteRectFromElement(element, classifier);
            return this.getElementsOverlappingInRect(rect);
        }
        /**
         * Get all elements overlapping with a given rectangle.
         * @param rect - The rectangle to get overlapping elements for
         * @returns - All elements overlapping with the given rectangle
         */
        static getElementsOverlappingInRect(rect) {
            const foundElements = new Set();
            const inBothXAndYRanges = [];
            function inBetween(value, start, end) {
                return value >= start && value <= end;
            }
            const inYRange = this.yAxisTree.searchOverlapping({ start: rect.top, end: rect.top + rect.height });
            inYRange.forEach((node) => {
                if (foundElements.has(node.data.element))
                    return;
                const startX = node.data.rect.left;
                const endX = node.data.rect.left + node.data.rect.width;
                const rectInNodeXRange = inBetween(rect.left, startX, endX) || inBetween(rect.left + rect.width, startX, endX);
                const nodeInRectXRange = inBetween(startX, rect.left, rect.left + rect.width) || inBetween(endX, rect.left, rect.left + rect.width);
                if (rectInNodeXRange || nodeInRectXRange) {
                    foundElements.add(node.data.element);
                    inBothXAndYRanges.push(node.data.element);
                }
            });
            return inBothXAndYRanges;
        }
    }

    class VisibilityContext extends Context {
        /** @inheritDoc */
        data = {
            visibilitySpatialContextMap: new WeakMap(),
        };
        /** @inheritDoc */
        set({ element }) {
            const classifier = this.classifier; // this.classifier will be undefined inside the getter
            ElementsSpatialGrid.add(element, this.classifier);
            this.data.visibilitySpatialContextMap.set(element, {
                get overlappingElements() {
                    return ElementsSpatialGrid.getElementsOverlappingWithElement(element, classifier);
                },
            });
        }
    }

    function logicalXOR(a, b) {
        return Boolean(a) !== Boolean(b);
    }

    /**
     * Check if the overflow property is visible, scroll, or auto
     * @param overflow property
     * @returns true if the overflow property is visible, scroll, or auto, otherwise false
     */
    function isOverflowVisible(overflow) {
        return ["visible", "scroll", "auto"].includes(overflow);
    }

    /**
     * Returns true if the element has a clip property
     * @param elementComputedStyle - The computed style of the element
     */
    const elementHasClip = (elementComputedStyle) => {
        const clip = elementComputedStyle.clip;
        if (!clip || clip === "auto" || clip === "none") {
            return false;
        }
        //`clip` property only works on elements with `position:absolute` or `position:fixed`
        return ["absolute", "fixed"].includes(elementComputedStyle.position);
    };
    /**
     * Returns true if the element has a supported clip-path value
     */
    const hasSupportedClipPath = (elementComputedStyle) => {
        const clip = elementComputedStyle.clipPath;
        if (!clip || clip === "none" || clip === "auto")
            return false;
        const type = clip.split(/[(),]/)[0]?.trim();
        return !unsupportedClipPathTypes.includes(type);
    };
    /**
     * Extracts the clip values and calculates the width and height of the box that encloses the clipped area
     * @param elementComputedStyle - The computed style of the element
     */
    const getClipInfo = (elementComputedStyle) => {
        const clip = elementComputedStyle.clip;
        const matrix = clip.match(/rect\((.*)\)/)[1].split(/,\s?/);
        const [top, right, bottom, left] = matrix.map((v) => parseInt(v));
        /**
         * calculations applied as described: @see https://developer.mozilla.org/en-US/docs/Web/CSS/shape#values
         */
        const width = right - left;
        const height = bottom - top;
        return {
            height,
            width,
        };
    };
    /**
     * Extracts the circle values from the clip-path circle function and calculates the width and height of the box that encloses the clipped area
     */
    const getClipPathCircleInfo = (clip, boundingClientRect) => {
        let width, height, x, y;
        if (clip.includes("at")) {
            const position = clip
                .split(/at/)[1]
                .split(/\(|\)|,| +/)
                .slice(1);
            [x, y] = position.map((value) => parseInt(value)).filter((v) => typeof v === "number");
        }
        const radiusString = clip.split(/[(),]/)[1];
        if (radiusString.includes("%")) {
            width = boundingClientRect.width * (parseInt(radiusString) / 100);
            height = boundingClientRect.height * (parseInt(radiusString) / 100);
        }
        else {
            width = parseFloat(radiusString); // width of the box that encloses the circle
            height = parseFloat(radiusString); // height of the box that encloses the circle
        }
        return {
            width,
            height,
            x,
            y,
            top: 0,
            right: 0,
            bottom: 0,
            left: 0,
        };
    };
    /**
     * Extracts the ellipse values from the clip-path ellipse function and calculates the width and height of the box that encloses the clipped area
     */
    const getClipPathEllipseInfo = (clip, boundingClientRect) => {
        let x = 0;
        let y = 0;
        if (clip.includes("at")) {
            const position = clip
                .split(/at/)[1]
                .split(/\(|\)|,| +/)
                .slice(1);
            [x, y] = position.map((value) => parseInt(value)).filter((v) => typeof v === "number");
        }
        const computedStyleKey = ["width", "height"];
        const [height, width] = clip
            .split(/\(|\)|\s/)
            .slice(1)
            .map((value, index) => {
            if (value.endsWith("%")) {
                return parseInt(boundingClientRect[computedStyleKey[index]]) * (parseInt(value) / 100);
            }
            return parseInt(value);
        });
        return {
            width,
            height,
            x,
            y,
            top: 0,
            right: 0,
            bottom: 0,
            left: 0,
        };
    };
    /**
     * Extracts the inset values from the clip-path inset function and calculates the width and height of the box that encloses the clipped area
     */
    const getClipPathInsetInfo = (clip, boundingClientRect) => {
        const insetValuesString = clip.split(/\((.*?)\)/)[1];
        const insetValues = extractCssRectValues(insetValuesString);
        /**
         * TODO: we're not handling values such as em, rem, etc. since they are usually not used for hiding with clip-path. if needed, we can add support for them.
         */
        const insetComputedStyleKey = ["height", "width", "height", "width"];
        const [insetTop, insetRight, insetBottom, insetLeft] = insetValues.map((value, index) => {
            const computedValue = boundingClientRect[insetComputedStyleKey[index]];
            if (value.endsWith("%")) {
                return computedValue * (parseInt(value) / 100);
            }
            return parseInt(value);
        });
        const height = boundingClientRect.height - (insetTop + insetBottom);
        const width = boundingClientRect.width - (insetRight + insetLeft);
        return {
            width,
            height,
            top: insetTop,
            right: insetRight,
            bottom: insetBottom,
            x: 0,
            y: 0,
        };
    };
    /**
     * Extracts the clip-path values and calculates the width and height of the box that encloses the clipped area
     * @param elementComputedStyle - The computed style of the element
     * @param boundingClientRect - The bounding client rect of the element
     */
    const getClipPathInfo = (elementComputedStyle, boundingClientRect) => {
        const clip = elementComputedStyle.clipPath;
        const clipType = clip.split(/\(|\)|,/)[0];
        let clipInfo;
        switch (clipType) {
            case "circle":
                clipInfo = getClipPathCircleInfo(clip, boundingClientRect);
                break;
            case "ellipse":
                clipInfo = getClipPathEllipseInfo(clip, boundingClientRect);
                break;
            case "inset":
                clipInfo = getClipPathInsetInfo(clip, boundingClientRect);
                break;
            default:
                throw new Error(`Unsupported clip-path type: ${clipType}`);
            /**
             * TODO: some properties are not supported yet due to complexity or lack of use cases.
             *       we can add support for them if needed
             * @see unsupportedClipPathTypes
             */
        }
        return {
            type: clipType,
            ...clipInfo,
        };
    };
    /**
     * List of clip-path types that are not supported yet
     */
    const unsupportedClipPathTypes = ["polygon", "path", "url"];

    /**
     * Detects if an element is visually hidden by:
     * - checking if the element has 0 opacity
     * - checking if the element has 0 dimensions
     * - checking if the element is overflowing from the document and has visible dimensions
     * - checking if the element is totally hidden by clip/clipPath and has no visible dimensions
     */
    function isVisuallyHidden(element, classifier, boundingClientRect) {
        const { layoutInfo, visibilityInfo } = classifier.getOperations(element);
        if (visibilityInfo.opacity === "0") {
            return true;
        }
        const hasVisibleDimensions = boundingClientRect.width > 0 && boundingClientRect.height > 0;
        const isElementOverflowed = element.scrollHeight > element.clientHeight || element.scrollWidth > element.clientWidth;
        if (hasVisibleDimensions || (isElementOverflowed && layoutInfo.overflow !== "hidden")) {
            // checking that the element doesn't have 0 dimensions (which means it's parent is not display:none)
            if (layoutInfo.isOutsideDocumentAndViewport) {
                return true;
            }
        }
        if (!hasVisibleDimensions) {
            return false;
        }
        const clipInfo = visibilityInfo.clipInfo;
        if (clipInfo) {
            const { width, height } = clipInfo;
            if (width <= 0 || height <= 0) {
                return true;
            }
        }
        const clipPathInfo = visibilityInfo.clipPathInfo;
        if (clipPathInfo) {
            const { width, height } = clipPathInfo;
            if (width <= 0 || height <= 0) {
                return true;
            }
        }
        return false;
    }

    /**
     * Detector whether element is inert.
     */
    class CompliantTraitInert extends CompliantDetector {
        /** @inheritDoc */
        static id = "compliant-trait-inert";
        /** @inheritDoc */
        static subsetOf = [];
        /** @inheritDoc */
        static detect(element, classifier) {
            if (classifier.getParent(element, CompliantTraitInert)) {
                return true;
            }
            return element.matches("[inert]");
        }
    }

    // TODO: consider having getters for this constant instead of hard-coding it
    /**
     * Change log:
     * The following conditions were changed:
     *  isOverflowing - Consider elements as overflowing only if more than 50% of the element is overflowing
     * The following conditions were moved:
     *  $el.closest("svg, head") - Moved to TraitInteractable
     * The following conditions were removed:
     *  $el.getAttribute("data-acsb-force-hidden") === "true" - No mention for this attribute in the code
     *  $el.parentElement?.closest('[data-aflw-hidden="true"]') - No mention for this attribute in the code
     *  $el.getAttribute("data-acsb-force-visible") === "true" - No mention for this attribute in the code
     *
     *  Afterpay specific selector `afterpay-modal` was removed as it was not working due to shadowDom
     *  @see https://jsfiddle.net/afterpay/drpesqhz/
     *
     *
     *  TODO: Implement support for shadowDom (consider parent with display:none and visible children)
     */
    /**
     * Calculate the visibility information of an element
     * It will return the width, height, padding, margin of the element
     * as well as top and left  relative to each, viewport, and document
     *
     * @returns An object describing the visibility of the element
     */
    class VisibilityInfo extends Operation {
        element;
        classifier;
        /** @inheritdoc */
        static dependencies = [CompliantTraitInert, CompliantTraitGeneric, CompliantTraitInteractable];
        static MIN_ELEMENT_VISIBLE_SIZE = 3;
        static MIN_FONT_VISIBLE_SIZE = 0.5;
        /**
         * The visibility property of the element
         */
        get visibility() {
            return this.computedStyle.visibility;
        }
        /**
         * The display property of the element
         */
        get display() {
            return this.computedStyle.display;
        }
        /**
         * The opacity property of the element
         */
        get opacity() {
            return this.computedStyle.opacity;
        }
        /**
         * Determines whether the element has a clip property
         */
        get hasClip() {
            return elementHasClip(this.computedStyle);
        }
        /**
         * Determines whether the element has a clip-path property
         */
        get hasClipPath() {
            return hasSupportedClipPath(this.computedStyle);
        }
        /**
         * The clip information of the element
         */
        get clipInfo() {
            return this.hasClip ? getClipInfo(this.computedStyle) : null;
        }
        /**
         * The clip-path information of the element
         */
        get clipPathInfo() {
            return this.hasClipPath ? getClipPathInfo(this.computedStyle, this.boundingClientRect) : null;
        }
        /**
         * Determines whether the element and its children are hidden
         *
         * NOTE: we cant use checkVisibility({visibilityProperty: true}) here as it doesn't take into account the visibility of the children.
         * related test: src/operations/visibility-info/e2e/visibility-hidden--children-visible.html
         */
        get isElementAndChildrenHidden() {
            if (this.visibility !== "hidden") {
                return false;
            }
            const walker = document.createTreeWalker(this.element, NodeFilter.SHOW_ELEMENT);
            let current = walker.firstChild();
            while (current) {
                const { visibilityInfo: { visibility }, } = this.classifier.getOperations(current);
                if (visibility !== "hidden") {
                    return false; // found a visible child
                }
                current = walker.nextNode();
            }
            return true; // all children are hidden
        }
        /**
         * Determines whether the element is visually hidden
         */
        get isVisuallyHidden() {
            return isVisuallyHidden(this.element, this.classifier, this.boundingClientRect);
        }
        /**
         * Determines whether the element is hidden via details element.
         * An element is considered hidden via details if it is not a summary or details element and one of its ancestors is a details element that is not open.
         */
        get isHiddenViaDetails() {
            // this method is called only in isRenderedAndVisible when checkVisibility throws an error.. so why do we try it again here?
            try {
                return !this.element.checkVisibility();
            }
            catch {
                return !this.element.matches("summary, details") && !!this.element.closest("details:not([open])");
            }
        }
        /**
         * Determines whether the element is not rendered.
         * An element is considered not rendered if it has a display of none or if one of its ancestors has a display of none
         *
         * NOTE: we do not use offsetParent as it is not reliable in some cases (e.g. when the element is fixed; different responses in different browsers)
         */
        get isRendered() {
            // this method is called only in isRenderedAndVisible when checkVisibility throws an error.. so why do we try it again here?
            try {
                return this.element.checkVisibility();
            }
            catch {
                if (this.display === "none") {
                    return false;
                }
                for (const ancestor of getAncestors(this.element)) {
                    const { display } = this.classifier.getOperations(ancestor).visibilityInfo;
                    if (display === "none") {
                        return false;
                    }
                }
                return true;
            }
        }
        // TODO: reduce try/catch usage here (in isHiddenViaDetails and isRendered)
        get isRenderedAndVisible() {
            try {
                // why only visibilityProperty ?
                return this.element.checkVisibility({ visibilityProperty: true });
            }
            catch {
                return this.visibility !== "hidden" && !this.isHiddenViaDetails && this.isRendered;
            }
        }
        /**
         * Determines whether the element is hidden from screen readers
         */
        get isHiddenFromScreenReader() {
            /**
             * Elements supports `alt` attribute and it's `alt` value is empty string is not considered a compliant image as screen will consider them as hidden (decorative images).
             */
            if (this.element.getAttribute("alt") === "" && isAltElement(this.element)) {
                return true;
            }
            return this.isExplicitlyHiddenFromScreenReader || !this.isRenderedAndVisible;
        }
        /**
         * Determines whether the element is hidden only from screen readers (not visually)
         */
        get isExplicitlyHiddenFromScreenReader() {
            /**
             * map element ignores aria-hidden and role attributes affect
             */
            if (this.element.matches(`[aria-hidden='true']`)) {
                return true;
            }
            // it doesn't hide the content of the element from screen readers
            if (this.element.matches("[role='presentation'], [role='none']") && this.isAffectedByRolePresentation) {
                return true;
            }
            if (this.classifier.assert(this.element, CompliantTraitInert)) {
                return true;
            }
            return false;
        }
        /**
         * Determines whether the element is affected by role presentation.
         * If the element is focusable, then role presentation has no effect.
         * If the element has aria text, then role presentation does not hide it.
         * @param element - The HTML element to check.
         * @param classifier - The engine classifier to use for operations.
         * @return {boolean} - Returns true if the element is affected by role presentation, false otherwise.
         * @reference - https://www.w3.org/WAI/ARIA/apg/practices/hiding-semantics/
         */
        get isAffectedByRolePresentation() {
            // checks if the element is focusable
            if (this.classifier.assert(this.element, CompliantTraitInteractable) || this.element.getAttribute("tabindex")) {
                return false;
            }
            // a lot more aria attributes need to be checked (https://w3c.github.io/aria/#global_states)
            if (this.element.getAttribute("aria-label") || this.element.getAttribute("aria-description") || this.element.getAttribute("aria-labelledby") || this.element.getAttribute("aria-describedby")) {
                return false;
            }
            return true;
        }
        /**
         * the boundingClientRect of the element as exposed by the `resources` param
         */
        boundingClientRect;
        /**
         * the computedStyle of the element as exposed by the `resources` param
         */
        computedStyle;
        constructor(element, { boundingClientRect, computedStyle }, classifier) {
            super();
            this.element = element;
            this.classifier = classifier;
            this.boundingClientRect = boundingClientRect;
            this.computedStyle = computedStyle;
        }
    }

    class PerceivableTraitVisible extends PerceivableDetector {
        /** @inheritDoc */
        static id = "perceivable-trait-visible";
        static contextType = VisibilityContext;
        /**
         * there are cases where we can't skip children when the parent is hidden (visibleDimensions=false) such as when we have fixed/absolute positioned elements within a static positioned parent; e.g: (src/perceivable/traits/visible/atomic-tests/pass/fixed-element-within-non-fixed.html)
        ˝*/
        static skipChildrenWhen = (element, classifier) => {
            if (element.matches("[hidden]")) {
                return true;
            }
            const { visibilityInfo } = classifier.getOperations(element);
            if (visibilityInfo.display === "none") {
                return true;
            }
            if (visibilityInfo.opacity === "0") {
                return true;
            }
            return false;
        };
        /** @inheritDoc */
        static subsetOf = [PerceivableTraitRenderable];
        /** @inheritDoc */
        static detect(element, classifier, _, context) {
            /**
             * if the element is not visible via checkVisibility or the element is inside a closed details element then its not visible.
             * if checkVisibility is available and returns false then the element is not visible.
             */
            if ("checkVisibility" in element && !element.checkVisibility()) {
                return false;
            }
            /**
             * if checkVisibility is not available then we skip the check and continue with the other checks.
             */
            if (!element.matches("summary, details") && element.closest("details:not([open])")) {
                return false;
            }
            const { visibilityInfo, layoutInfo, typographyInfo } = classifier.getOperations(element);
            const MIN_ELEMENT_VISIBLE_SIZE = VisibilityInfo.MIN_ELEMENT_VISIBLE_SIZE;
            if (visibilityInfo.display === "none") {
                return false;
            }
            if (visibilityInfo.opacity === "0") {
                return false;
            }
            /*
              If the element has smaller dimensions than the minimum visible size, and is not overflowed then it's considered hidden
              If the element has smaller dimensions than the minimum visible size, is overflowed and has overflow: hidden then it's considered hidden
             */
            const isOneDimensionLessThanOrEqualToMinVisibleSize = layoutInfo.absoluteRect.width <= MIN_ELEMENT_VISIBLE_SIZE || layoutInfo.absoluteRect.height <= MIN_ELEMENT_VISIBLE_SIZE;
            if (isOneDimensionLessThanOrEqualToMinVisibleSize && (!isOverflowVisible(layoutInfo.overflow) || !isElementOverflowed(element)))
                return false;
            /**
             * Determines whether given element is clipped (using css clip property) that results in hidden dimensions.
             *
             * Important insights:
             * * `clip` property only works on elements with `position:absolute` or `position:fixed`
             * * `clip` property can be defined using shape of type `rect`
             * * `clip` property is deprecated
             *
             * @see https://developer.mozilla.org/en-US/docs/Web/CSS/clip
             * @param computedStyle
             *
             * TODO: since visiblity considers non-visible size to be 3 but sr-only considers it to be 0, we receive it as an argument here.
             * this makes the code a bit more complex, we should consider fixing this by extracting this logic to some place else and pass these values as required arguments.
             */
            const clipInfo = visibilityInfo.clipInfo;
            if (clipInfo) {
                const { width, height } = clipInfo;
                if (width <= MIN_ELEMENT_VISIBLE_SIZE || height <= MIN_ELEMENT_VISIBLE_SIZE) {
                    return false;
                }
            }
            /**
             * Determines whether given element is clipped (using css clip-path property) that results in hidden dimensions.
             *
             * @see https://developer.mozilla.org/en-US/docs/Web/CSS/clip-path
             */
            const clipPathInfo = visibilityInfo.clipPathInfo;
            if (clipPathInfo) {
                const { width, height } = clipPathInfo;
                if (width <= MIN_ELEMENT_VISIBLE_SIZE || height <= MIN_ELEMENT_VISIBLE_SIZE) {
                    return false;
                }
            }
            /**
             * Determines whether the given element has visible children when it's visibility is hidden.
             * If element has `visibility:hidden` and none of its children have `visibility:visible` then it's considered hidden.
             * `visibility` is being inherited from parent to children, if specific child has `visibility:visible` then it will be visible.
             *
             * @see https://developer.mozilla.org/en-US/docs/Web/CSS/visibility
             * //TODO: check for shadowDom?
             */
            if (visibilityInfo.isElementAndChildrenHidden) {
                return false;
            }
            /**
             * if the element is outside the document then it's considered hidden
             */
            if (layoutInfo.isOutsideDocumentVisibleRect)
                return false;
            // if an element has text overflowing from the document, and it has text-indent then it's considered hidden
            if (typographyInfo.textIndent) {
                const contentInfo = classifier.getOperations(element).contentInfo;
                /**
                 * text-indent value is only relevant when the element has text content, so we check for that as well
                 *
                 * see related test:
                 * - @see file://./atomic-tests/pass/element-text-indent--with-no-text-content.html
                 */
                if (contentInfo.hasTextContent && (layoutInfo.hasTextOutsideDocumentX || layoutInfo.hasTextOutsideDocumentY)) {
                    /**
                     * this check is required to handle cases where an element has text-indent but also has a background color or image
                     *
                     * see related tests:
                     * - @see file://./atomic-tests/pass/element-text-indent--with-visible-background-image.html
                     * - @see file://./atomic-tests/pass/element-text-indent--with-visible-background.html
                     */
                    const { backgroundColor, backgroundImage } = classifier.getOperations(element).colorInfo;
                    if (!backgroundImage.includes("url(") && backgroundColor === "rgba(0, 0, 0, 0)") {
                        return false;
                    }
                }
            }
            /**
             * if the element is completely outside its ancestors and
             * it's ancestors have `overflow:hidden` then it's considered hidden
             */
            if (layoutInfo.isOutsideAncestorsVisibleRect)
                return false;
            context?.set({ element });
            return true;
            //TODO: find a solution for that
            //if (TraitVisibility.Rules.isCoveredByOtherElement(element, boundingClientRect)) {
            //    return false;
            //}
            //TODO: the following can be used for non-fully-determenistic situations
            // const elementFromPoint = document.elementFromPoint(offsets.left, offsets.top);
            // if(elementFromPoint !== element && !element.contains(elementFromPoint)){
            //     return true;
            // }
            //TODO: is this check required? we are checking for width,height, offsetWidth, offsetHeight
            // if(computedStyle.display !== "inline" && computedStyle.maxHeight === "0px"){
            //     return true;
            // }
            //TODO: Do we need this?
            // this.getStyle($el, "animation").split(" ")[0] !== "0s"
            // It's used in the original code, because if it has animation it might become visible.
            // But we don't have an actual animation detection yet, so we can't use it.
        }
    }

    /**
     * Detector whether element is Hidden.
     * This is an inverse of PerceivableTraitVisible
     */
    class PerceivableTraitHidden extends PerceivableDetector {
        /** @inheritDoc */
        static id = "perceivable-trait-hidden";
        /** @inheritDoc */
        static skipChildrenWhen = "never";
        /** @inheritDoc */
        static dependencies = [PerceivableTraitVisible];
        /** @inheritDoc */
        static subsetOf = [];
        /** @inheritDoc */
        static detect(element, classifier) {
            return !classifier.assert(element, PerceivableTraitVisible);
        }
    }

    /**
     * Detector whether element is interactable.
     * Meaning the user can interact with it.
     */
    class CompliantTraitImplicitInteractable extends CompliantDetector {
        /** @inheritDoc */
        static id = "compliant-trait-implicit-interactable";
        /** @inheritDoc */
        static skipChildrenWhen = "positive";
        /** @inheritDoc */
        static subsetOf = [];
        /**
         * Selector for interactable elements
         */
        static interactableSelectors = ["a", "button", "input", "select", "textarea", '[contenteditable]:not([contenteditable="false"], [disabled], [aria-disabled="true"])', "audio[controls]", "video[controls]", "details", "[draggable]"].join(", ");
        /** @inheritDoc */
        static detect(element) {
            return element.matches(this.interactableSelectors);
        }
    }

    /**
     * Detector for clickable elements.
     */
    class PerceivableTraitClickable extends PerceivableDetector {
        /** @inheritDoc */
        static id = "perceivable-trait-clickable";
        /** @inheritDoc */
        static skipChildrenWhen = "positive";
        /** @inheritDoc */
        static subsetOf = [PerceivableTraitRenderable];
        static dependencies = [PerceivableTraitVisible, CompliantTraitImplicitInteractable];
        /**
         * Selector for common clickable elements.
         */
        static clickableElementSelector = `a, button, summary`;
        /**
         * Minimum size thresholds for clickability
         */
        static MAX_TEXT_LENGTH = 450;
        static MAX_CHILD_COUNT = 10;
        static MAX_HEIGHT = 550; // max height threshold in px
        /**
         * Determines whether the given element is clickable.
         */
        static detect(element, classifier) {
            const { resources, contentInfo, layoutInfo } = classifier.getOperations(element);
            const style = resources.computedStyle;
            /**
             If pointer events are disabled and the element is not visible, the element is not clickable
             (Related Test: src/perceivable/traits/clickable/atomic-tests/pass/coralogix-nav-submenu-link.html)
             */
            if (style.pointerEvents === "none" && classifier.assert(element, PerceivableTraitVisible)) {
                return false;
            }
            // Check if the element matches standard clickable elements or button-like inputs
            if (element.matches(this.clickableElementSelector) || isButtonLikeInput(element)) {
                return true;
            }
            const { rect } = layoutInfo;
            // Check size-based heuristics
            if (!this.isSizeClickable(rect)) {
                return false;
            }
            // Check the length of the text contained within the element
            if (!this.isTextLengthClickable(contentInfo)) {
                return false;
            }
            if (this.hasOnClickEvent(element)) {
                return true;
            }
            // Check the number of child elements
            if (!this.hasFewChildren(element)) {
                return false;
            }
            if (style.cursor !== "pointer") {
                /**
                 * Commented out due to serious performance issues on some of our clients.
                 * This scenario is not common and can be ignored for now.
                 * A ticket will be created to investigate this further, and apply a fix if necessary.
                 */
                // const pseudoClassStyle = getPseudoClassStyle(element, ":hover", "cursor");
                // if (pseudoClassStyle?.cursor !== "pointer") {
                //   return false;
                // }
                return false;
            }
            /**
             * Having `ImplicitInteractable` and `Visible` children is a strong indicator that the element is not clickable.
             */
            if (element.localName !== "label" && classifier.getMatched([CompliantTraitImplicitInteractable], element).length > 0) {
                return false;
            }
            // If all heuristics pass, the element is considered clickable
            return true;
            // TODO: need to check what are the scenarios where this is relevant
            // if (element.tagName === "LABEL" && element.closest("form")) {
            //   return false;
            // }
            //TODO: This is old code, it doesn't make much sense, it's probably just generally true.
            // if(element.querySelectorAll("*:not(svg)").length > 7){
            //     return false;
            // }
        }
        /**
         * Determines if an element has a meaningful `onClick` event.
         *
         * This function checks:
         * - The `onclick` property for inline or directly assigned click handlers.
         * - Non-standard `getEventListeners` (available in devtools or browser automation tools like Puppeteer)
         *   to detect registered `click` event listeners.
         *
         * Additionally, it verifies that the `onclick` function body is non-empty to avoid false positives
         * caused by empty or no-op handlers.
         *
         * NOTE: `getEventListeners` is a non-standard feature and works only in debugging environments or
         *       tools like Puppeteer.
         *
         * TODO: Assess if we need to include checks for additional interaction events like `touchstart`,
         *       `pointerdown`, and `mousedown` that may indicate user interaction behavior.
         */
        static hasOnClickEvent(element) {
            // We're checking the attribute first in order to avoid potential parsing errors like found on https://www.quiksilver.com/ and can be seen in the atomic test: div-onclick-window-location
            const onClick = element.getAttribute("onclick");
            if (onClick) {
                return !this.isFunctionBodyEmpty(onClick);
            }
            if (!this.isFunctionBodyEmpty(element.onclick?.toString())) {
                return true;
            }
            /**
             * Below code is commented out because getEventListeners is available only when the devtools are open
             * this creates discrepancies between dev/qa and real-world usage.
             * **/
            // Check event listeners if the browser supports it
            // if (typeof (window as any).getEventListeners === "function") {
            //   const clickListeners = (window as any).getEventListeners(element)["click"];
            //
            //   if (clickListeners?.length > 0) {
            //     const someFunctionHasValidBody = clickListeners.some((listener: { listener: () => void }) => {
            //       if (listener.listener && listener.listener.toString) {
            //         const listenerStr = listener.listener.toString();
            //         return !this.isFunctionBodyEmpty(listenerStr);
            //       }
            //     });
            //
            //     return someFunctionHasValidBody;
            //   }
            // }
            return false;
        }
        /**
         *  Checks if the function body (as string) of the given function is empty.
         * */
        static isFunctionBodyEmpty(funcStr = "") {
            const functionBody = funcStr.slice(funcStr.indexOf("{") + 1, funcStr.lastIndexOf("}")).trim();
            return functionBody.length === 0;
        }
        /**
         * Determines if the size of the element suggests it is clickable.
         * Only height is checked, width is ignored (block elements).
         */
        static isSizeClickable(rect) {
            return rect.height <= this.MAX_HEIGHT;
        }
        /**
         * Determines if the element's text length is appropriate for a clickable element.
         */
        static isTextLengthClickable(contentInfo) {
            // Clickable elements typically have shorter text, e.g., links and buttons
            return isTextLengthInRange(contentInfo.textContentGenerator, { max: this.MAX_TEXT_LENGTH });
        }
        /**
         * Checks if the element has few child elements, which suggests it might be clickable.
         */
        static hasFewChildren(element) {
            const totalDescendants = this.getTotalDescendantCount(element);
            // If there are more than MAX_CHILD_COUNT descendants, it's less likely to be a simple clickable element
            return totalDescendants <= this.MAX_CHILD_COUNT;
        }
        /**
         * Recursive function to count all descendants, excluding certain non-clickable or decorative elements.
         *
         * The excluded elements list includes:
         * - <svg>: Commonly used for icons or graphics, unlikely to be clickable by itself.
         * - <script> and <style>: These elements contain code and styling, not visible content, so they are irrelevant to clickability.
         * - <template>: Contains markup that is not rendered directly on the page and is therefore non-clickable.
         */
        static getTotalDescendantCount(el) {
            let count = 0;
            const excludedElements = ["svg", "script", "style", "template", "code"]; // Elements to exclude from clickability count
            for (const child of el.children) {
                // Skip counting and traversing excluded elements and their descendants
                if (!excludedElements.includes(child.nodeName.toLowerCase())) {
                    count++;
                    count += this.getTotalDescendantCount(child);
                }
            }
            return count;
        }
    }

    /**
     * Checks whether the given element has discernible text - meaning that it has text that is visible to a screen reader.
     * based on rules from:
     * - @see https://dequeuniversity.com/rules/axe/4.8/link-name
     * - @see https://dequeuniversity.com/rules/axe/4.8/button-name
     * - @see https://dequeuniversity.com/rules/axe/4.8/empty-heading
     */
    class PerceivableTraitDiscernibleText extends PerceivableDetector {
        /** @inheritDoc */
        static id = "perceivable-trait-discernible-text";
        /** @inheritDoc */
        static skipChildrenWhen = "never";
        /** @inheritDoc */
        static subsetOf = [CompliantTraitVisible];
        static detect(element, classifier) {
            const { contentInfo } = classifier.getOperations(element);
            return Boolean(contentInfo.srVisibleText);
        }
    }

    /**
     * Detects whether the given element has direct `TextNodes` that are not empty, line breaks, or spaces.
     *
     * TODO: DirectText should be Visible Direct text? an additional trait?
     * TODO: how can we cache opperations like TypographyInfo?
     * TODO: what if the text is transparent?
     */
    class PerceivableTraitDirectText extends PerceivableDetector {
        /** @inheritDoc */
        static id = "perceivable-trait-direct-text";
        /** @inheritDoc */
        static skipChildrenWhen = "never";
        /** @inheritDoc */
        static subsetOf = [PerceivableTraitRenderable];
        /** @inheritDoc */
        static detect(element) {
            const childNodes = element.childNodes;
            for (let i = 0; i < childNodes.length; i++) {
                const node = childNodes[i];
                if (node.nodeType === Node.TEXT_NODE && node.nodeValue && node.nodeValue.trim()) {
                    return true;
                }
            }
            return false;
        }
    }

    const DISPLAYS_THAT_DO_NOT_CROSS_OUT = ["inline-flex", "inline-block", "inline-grid", "inline-table", "ruby-text", "-webkit-inline-box", "-webkit-inline-flex"];
    /**
     * The detector for elements with crossed out texts
     */
    class CompliantTraitCrossedOutText extends CompliantDetector {
        /** @inheritDoc */
        static id = "compliant-trait-crossed-out-text";
        /** @inheritDoc */
        static skipChildrenWhen = "never";
        /** @inheritDoc */
        static subsetOf = [PerceivableTraitVisible];
        static detect(element, classifier) {
            const { visibilityInfo, contentInfo } = classifier.getOperations(element);
            if (!contentInfo.hasTextContent) {
                return false;
            }
            const hasCrossedOutParent = classifier.getParent(element, this);
            if (!["DEL", "S", "STRIKE"].includes(element.tagName) && !hasCrossedOutParent) {
                return false;
            }
            const display = visibilityInfo.display;
            //display: contents is a special case where the element is rendered as if it were a child of its parent
            if (display === "contents") {
                return false;
            }
            // Check if the element is crossed out by a parent, certain displays cancel out the crossed out effect even if the parent is crossed out
            if (hasCrossedOutParent && DISPLAYS_THAT_DO_NOT_CROSS_OUT.includes(display)) {
                return false;
            }
            return true;
        }
    }

    /**
     * The detector for elements with crossed out texts
     */
    class PerceivableTraitCrossedOutText extends PerceivableDetector {
        /** @inheritDoc */
        static id = "perceivable-trait-crossed-out-text";
        /** @inheritDoc */
        static skipChildrenWhen = "never";
        /** @inheritDoc */
        static subsetOf = [PerceivableTraitVisible];
        static detect(element, classifier) {
            const { visibilityInfo, typographyInfo, layoutInfo, contentInfo } = classifier.getOperations(element);
            if (!contentInfo.hasTextContent) {
                return false;
            }
            const display = visibilityInfo.display;
            const position = layoutInfo.position;
            const isDisplayContents = display === "contents";
            if (typographyInfo.textDecoration.line === "line-through" && !isDisplayContents) {
                return true;
            }
            if (position !== "static") {
                if (this.hasPseudoElementStrikeTrough(element)) {
                    return true;
                }
                if (this.isHrCrossedOut(element, classifier)) {
                    return true;
                }
            }
            // Check if the element is crossed out by a parent, certain displays cancel out the crossed out effect even if the parent is crossed out
            const isCrossedOutByParent = Boolean(classifier.getParent(element, this)) && !DISPLAYS_THAT_DO_NOT_CROSS_OUT.includes(display);
            return isCrossedOutByParent;
        }
        /**
         *  Check if the element is crossed out by a <hr> element
         * */
        static isHrCrossedOut(element, classifier) {
            const hr = element.querySelector("hr");
            if (hr) {
                const { layoutInfo: hrLayoutInfo } = classifier.getOperations(hr);
                const { layoutInfo: elementLayoutInfo } = classifier.getOperations(element);
                const hasEnoughWidth = hrLayoutInfo.renderedWidth >= elementLayoutInfo.renderedWidth * 0.9;
                const notTooHigh = hrLayoutInfo.renderedHeight <= elementLayoutInfo.renderedHeight * 0.25;
                const isCentered = Math.round(elementLayoutInfo.height / hrLayoutInfo.topRelative) === 2;
                return hasEnoughWidth && notTooHigh && isCentered;
            }
            return false;
        }
        /**
         *  Check if the element is crossed out by a pseudo element
         * */
        static hasPseudoElementStrikeTrough(element) {
            //TODO: Move to operations
            const after = window.getComputedStyle(element, "::after");
            const before = window.getComputedStyle(element, "::before");
            const hasBorder = before.borderWidth !== "0px" || after.borderWidth !== "0px";
            const isAbsolute = before.position === "absolute" || after.position === "absolute";
            const hasTop = before.top !== "0px" || after.top !== "0px";
            return hasBorder && isAbsolute && hasTop;
        }
    }

    class ClickableRepetitiveStructureContext extends Context {
        /** @inheritDoc */
        data = {
            elementStore: new WeakMap(),
        };
        /**
         * Sets the data for the given element.
         * @param element - The element to set the data to.
         * @param data - The structural data of the element.
         */
        set({ element, data }) {
            this.data.elementStore.set(element, { ...this.data.elementStore.get(element), ...data });
        }
    }

    /**
     * Notice there is no reference to visibility - this is because there are cases where we want to detect this structure while the element is not visible.
     * A hidden menu, toggle by the menu-trigger (like in dropdowns) is a good example.
     */
    class PerceivableTraitClickableRepetitiveStructure extends PerceivableDetector {
        /** @inheritDoc */
        static id = "perceivable-trait-clickable-repetitive-structure";
        /** @inheritDoc */
        static skipChildrenWhen = "never";
        /** @inheritDoc */
        static subsetOf = [PerceivableTraitRenderable];
        /** @inheritDoc */
        static dependencies = [PerceivableTraitTabbable, PerceivableTraitClickable];
        /** @inheritDoc */
        static notSubsetOf = [
            /**
             * if the container itself is clickable, then it's not a clickable repetitive structure
             */
            PerceivableTraitClickable,
        ];
        /** @inheritDoc */
        static contextType = ClickableRepetitiveStructureContext;
        /** @inheritDoc */
        static classifier;
        /**
         * given an element, gets all the visible clickable elements inside it
         * TODO: consider removing PerceivableTraitVisible check to support carousels with hidden items
         */
        static getElementClickables(element) {
            return this.classifier.getMatchedInclusive([PerceivableTraitClickable], element);
        }
        /**
         * the list items are always the level that's before the last level - one before the container of the breadcrumb
         */
        static getRepetitiveItemsFromLevels(levels) {
            return [...new Set(levels[levels.length - 2] || [])];
        }
        /**
         * gets all the clickable elements from the levels (the first level is always the clickable elements)
         */
        static getClickablesFromLevels(levels) {
            return [...new Set(levels[0])];
        }
        /**
         *  checks if the element is a list menu by checking if it contains clickable elements with a repetitive path
         *
         * TODO:
         * - might want to check that the clickable element also has some sort of content
         */
        static isRepetitiveStructure(element) {
            const clickablePathOccurrences = getRepetitivePathOccurrences(element, this.getElementClickables(element));
            for (const [_, paths] of clickablePathOccurrences) {
                const levels = transposeMatrix([...paths]);
                const repetitiveItems = this.getRepetitiveItemsFromLevels(levels);
                if (repetitiveItems.length > 1 && allElementsAreSiblings(repetitiveItems)) {
                    const clickables = this.getClickablesFromLevels(levels);
                    return { result: true, data: { repetitiveItems, clickables } };
                }
            }
            return { result: false };
        }
        /** @inheritDoc */
        static detect(element, classifier, _, context) {
            this.classifier = classifier;
            const { result, data } = this.isRepetitiveStructure(element);
            if (!result) {
                return false;
            }
            context.set({ element, data });
            return true;
        }
    }

    /**
     * Detects if an element is a perceivable form field component.
     */
    class CompliantComponentFormField extends CompliantDetector {
        /** @inheritDoc */
        static id = "compliant-component-form-field";
        /** @inheritDoc */
        static skipChildrenWhen = "positive";
        /** @inheritDoc */
        static subsetOf = [CompliantTraitInteractable];
        /** @inheritDoc */
        static detect(element) {
            return element.matches(this.formFieldSelectors);
        }
        /**
         * Selector for form field elements
         */
        static formFieldSelectors = ["input:not([type=hidden])", "select", "textarea", "[type=submit]", "[type=reset]", "fieldset", "label", "legend", "[role=checkbox]", "[role=radio]", "[role=switch]", "[role=combobox]", "[role=listbox]", "[role=option]", "[role=slider]", "[role=spinbutton]", "[role=textbox]", "[role=searchbox]"].join(", ");
    }

    /**
     * Detector whether screen-reader will consider only the given `element` (content not included) as exposed to the screen reader.
     */
    class CompliantTraitExposed extends CompliantDetector {
        /** @inheritDoc */
        static id = "compliant-trait-exposed";
        /** @inheritDoc */
        static skipChildrenWhen = "never";
        /** @inheritDoc */
        static subsetOf = [CompliantTraitVisible];
        /** @inheritDoc */
        static dependencies = [CompliantTraitInteractable, CompliantTraitGeneric, PerceivableTraitDirectText];
        /** @inheritDoc */
        static detect(element, classifier) {
            const { isRenderedAndVisible } = classifier.getOperations(element).visibilityInfo;
            if (!isRenderedAndVisible) {
                return false;
            }
            const { isAffectedByRolePresentation } = classifier.getOperations(element).visibilityInfo;
            // Empty alt is equivalent to role='presentation' for images.
            if (isAltElement(element) && element.hasAttribute("alt") && element.getAttribute("alt") === "") {
                if (isAffectedByRolePresentation) {
                    return false;
                }
            }
            // SVG element with no children is equivalent to role='presentation'.
            if (element.matches("svg") && element.children.length === 0) {
                if (isAffectedByRolePresentation) {
                    return false;
                }
            }
            if (element.matches("[role='presentation'], [role='none']") && isAffectedByRolePresentation) {
                return false;
            }
            if (classifier.assert(element, CompliantTraitGeneric) && !classifier.assert(element, PerceivableTraitDirectText) && isAffectedByRolePresentation) {
                return false;
            }
            return true;
        }
    }

    /**
     * Responsible for finding perceivable labels for compliant inputs.
     * This is used to apply a perceivable label text to an input that doesn't have accessible name.
     * TODO: consider adding logic to find contextually relevant labels via their attributes (i.e: class, ids etc. that have 'label' in them)
     */
    class InputLabelContext extends Context {
        /** @inheritDoc */
        data = {
            inputLabelPairs: new Map(),
        };
        /**
         * TODO: consider also looking for native associated labels via `getAssociatedLabels` method because we might want this context to return an appropriate result regardless of where it's used.
         */
        set({ element }) {
            const label = InputLabelContext.findLabel(element, this.classifier);
            if (label) {
                this.data.inputLabelPairs.set(element, label);
            }
        }
        /**
         * Finds possible label for a given input element.
         * Traverses the DOM up from the input element and collects all elements that could be perceivable labels.
         */
        static findLabel(input, classifier) {
            let parent = input;
            while (parent && parent !== parent.ownerDocument.body && parent.parentElement) {
                for (const sibling of parent.parentElement.children) {
                    /**
                     * skip the input element subtree
                     */
                    if (sibling === parent) {
                        continue;
                    }
                    const treeWalker = document.createTreeWalker(sibling, NodeFilter.SHOW_ELEMENT);
                    do {
                        const currentNode = treeWalker.currentNode;
                        if (!isSvgOrHtmlElement(currentNode)) {
                            continue;
                        }
                        /**
                         * if the label has a `for` attribute and the element with the id exists, then it's already connected to another input.
                         * we also break the loop because we do not want to get results from eleemnts within the label.
                         * see test: src/contexts/input-label/e2e/label-already-associated-with-another-field.html
                         */
                        if (this.inputAlreadyHasLabel(input, currentNode)) {
                            break;
                        }
                        if (!this.isLabel(input, currentNode, classifier)) {
                            continue;
                        }
                        return currentNode;
                    } while (treeWalker.nextNode());
                }
                parent = parent.parentElement;
            }
        }
        /**
         * Checks if the candidate element is a perceivable label for the input element.
         */
        static isLabel(input, candidate, classifier) {
            /**
             * if the candidate is an input-like element (i.e: button, select, input), then it's not a perceivable label.
             */
            if ("labels" in candidate && isHTMLLabelElementList(candidate.labels)) {
                return false;
            }
            /**
             * if a candidate label is not visible to a sighted user, then it's not a perceivable label.
             */
            if (!classifier.assert(candidate, PerceivableTraitVisible)) {
                return false;
            }
            /**
             * if an element has no direct text and it's not a native label with discernible text (because it's likely it is the intended label), then it's not a perceivable label.
             */
            const hasDirectText = classifier.assert(candidate, PerceivableTraitDirectText);
            const disernibleLabel = isInstanceOf(candidate, HTMLLabelElement) && classifier.assert(candidate, PerceivableTraitDiscernibleText);
            if (!hasDirectText && !disernibleLabel) {
                return false;
            }
            /**
             * if the input is a checkbox or radio, then the label should be positioned after the input
             * otherwise, the label should be positioned above, below, or before the input
             * @see https://www.w3.org/WAI/tutorials/forms/labels/#visual-position-of-label-text
             */
            if (isInstanceOf(input, HTMLInputElement) && ["checkbox", "radio"].includes(input.type)) {
                if (!this.isPositionedLikeLabelForCheckboxOrRadio(input, candidate, classifier)) {
                    return false;
                }
            }
            else {
                if (!this.isPositionedLikeLabel(input, candidate, classifier)) {
                    return false;
                }
            }
            return true;
        }
        /**
         * Checks if the input element is already associated with a label, to prevent false-positives such as country selectors for phone number fields.
         */
        static inputAlreadyHasLabel(input, candidate) {
            if (isInstanceOf(candidate, HTMLLabelElement)) {
                const associatedInput = candidate.htmlFor && candidate.ownerDocument.getElementById(`${candidate.htmlFor}`);
                if (isSvgOrHtmlElement(associatedInput)) {
                    const associatedLabels = getAssociatedLabels(associatedInput);
                    /**
                     * there are instances where there are multiple inputs with the same id and more than one label is associated with them.
                     * in that case we shouldn't break the loop because the label is relevent to the input.
                     * see test: src/contexts/perceivable-label/e2e/label-for-duplicate-ids.html
                     */
                    if (associatedLabels.length === 1) {
                        return true;
                    }
                }
            }
        }
        /**
         * Checks if the label is positioned after or above the input element and not too far away from it (as usual for checkbox or radio label).
         */
        static isPositionedLikeLabelForCheckboxOrRadio(input, label, classifier) {
            const inputRect = classifier.getOperations(input).layoutInfo.rect;
            const currentNodeRect = classifier.getOperations(label).layoutInfo.rect;
            const { x, y } = getElementProximity(inputRect, currentNodeRect);
            if (x > 100 || y > 100) {
                return false;
            }
            const isLabelPositionedAfterInput = input.compareDocumentPosition(label) === Node.DOCUMENT_POSITION_FOLLOWING;
            const visuallyAbove = this.isVisuallyAbove(inputRect, currentNodeRect);
            return isLabelPositionedAfterInput || visuallyAbove;
        }
        /**
         * Checks if the label is positioned above, below, or before the input element and not too far away from it (as usual for text input label).
         */
        static isPositionedLikeLabel(input, label, classifier) {
            const inputRect = classifier.getOperations(input).layoutInfo.rect;
            const currentNodeRect = classifier.getOperations(label).layoutInfo.rect;
            const visuallyAbove = this.isVisuallyAbove(inputRect, currentNodeRect);
            const isLabelPositionedBeforeInput = input.compareDocumentPosition(label) === Node.DOCUMENT_POSITION_PRECEDING;
            const labelWithinInput = isWithinBoundsByCoords(currentNodeRect, inputRect);
            const { x, y } = getElementProximity(inputRect, currentNodeRect);
            if (x > 20 || y > 20) {
                return false;
            }
            if (visuallyAbove || isLabelPositionedBeforeInput || labelWithinInput) {
                return true;
            }
            return false;
        }
        /**
         * Checks if the label is visually above the input element.
         */
        static isVisuallyAbove(inputRect, aboveinputRect) {
            // the element shouldn't overflow in the y-axis (with a deviation of 5px)
            if (Math.abs(inputRect.left - aboveinputRect.left) > 5) {
                return false;
            }
            const distanceY = inputRect.top - aboveinputRect.bottom;
            return distanceY > 3 && distanceY < 20;
        }
    }

    /**
     * Detector whether screen-reader will consider given `element` as an input.
     */
    class CompliantComponentInput extends CompliantDetector {
        /** @inheritDoc */
        static id = "compliant-component-input";
        /** @inheritDoc */
        static subsetOf = [CompliantTraitExposed];
        static dependencies = [PerceivableTraitDirectText, PerceivableTraitVisible, PerceivableTraitDiscernibleText];
        static contextType = InputLabelContext;
        /** @inheritDoc */
        static detect(element, _, __, context) {
            const isMatch = element.matches("input:not([role]:not([role=''])), select:not([role]:not([role=''])), textarea:not([role]:not([role=''])), [contenteditable]:not([contenteditable='false']), [role='input'], [role='textbox'], [role='combobox'], [role='searchbox'], [role='spinbutton'], [role='slider'], [role='radio'], [role='tree']");
            const result = isMatch && !isButtonLikeInput(element);
            if (result) {
                context.set({ element });
                return true;
            }
            return false;
        }
    }

    /**
     * Detector whether screen-reader will consider given `element` as a link.
     */
    class CompliantComponentLink extends CompliantDetector {
        /** @inheritDoc */
        static id = "compliant-component-link";
        /** @inheritDoc */
        static subsetOf = [CompliantTraitExposed];
        /** @inheritDoc */
        static detect(element) {
            return element.matches("a[href]:not([role]:not([role=''])), [role=link]");
        }
    }

    /**
     * Detector whether screen-reader will consider given `element` as a button.
     */
    class CompliantComponentButton extends CompliantDetector {
        /** @inheritDoc */
        static id = "compliant-component-button";
        /** @inheritDoc */
        static subsetOf = [CompliantTraitExposed];
        /** @inheritDoc */
        static detect(element) {
            return element.matches("button:not([role]:not([role=''])), button[role=presentation], button[role=none], [role=button], input[type=button]:not([role]:not([role=''])), input[type=button][role=presentation], input[type=button][role=none], input[type=submit]:not([role]:not([role=''])), input[type=submit][role=presentation], input[type=submit][role=none], input[type=image]:not([role]:not([role=''])), input[type=image][role=presentation], input[type=image][role=none], input[type=reset]:not([role]:not([role=''])), input[type=reset][role=presentation], input[type=reset][role=none]");
        }
    }

    /**
     * Detector whether screen-reader will consider given `element` as a heading.
     */
    class CompliantComponentHeading extends CompliantDetector {
        /** @inheritDoc */
        static id = "compliant-component-heading";
        /** @inheritDoc */
        static subsetOf = [CompliantTraitExposed];
        static selectors = [
            //H1-H6 without any role or aria-level attribute is sufficient
            `h1:not([role]:not([role=''])), h2:not([role]:not([role=''])), h3:not([role]:not([role=''])), h4:not([role]:not([role=''])), h5:not([role]:not([role=''])), h6:not([role]:not([role='']))`,
            //Any element with role=heading
            `[role="heading"]`,
        ];
        /** @inheritDoc */
        static detect(element) {
            return element.matches(CompliantComponentHeading.selectors.join(" ,"));
        }
    }

    /**
     * Detector whether screen-reader will consider given `element` as a figure.
     */
    class CompliantComponentFigure extends CompliantDetector {
        /** @inheritDoc */
        static id = "compliant-component-figure";
        /** @inheritDoc */
        static subsetOf = [CompliantTraitExposed];
        /** @inheritDoc */
        static detect(element) {
            return element.matches("figure:not([role]:not([role=''])), [role=figure]");
        }
    }

    /**
     * Detector for elements that naming them (an accessible name) is prohibited.
     * @see https://www.w3.org/TR/wai-aria-1.3/#namefromprohibited
     * @see https://www.w3.org/TR/accname-1.2/#dfn-accessible-name
     * @see https://www.w3.org/TR/accname-1.2/#mapping_additional_nd_name
     */
    class CompliantTraitNameProhibited extends CompliantDetector {
        /** @inheritDoc */
        static id = "compliant-trait-name-prohibited";
        /** @inheritDoc */
        static subsetOf = [];
        /** @inheritDoc */
        static detect(element) {
            const prohibitedRoles = ["caption", "code", "definition", "deletion", "emphasis", "generic", "insertion", "mark", "none", "paragraph", "strong", "subscript", "suggestion", "superscript", "term", "time"];
            const tagsWithImplicitProhibitedRole = ["A", "AREA", "B", "BDI", "BDO", "BODY", "CAPTION", "CODE", "DATA", "DEL", "DFN", "DIV", "EM", "I", "INS", "P", "PRE", "Q", "S", "SAMP", "SMALL", "SPAN", "STRONG", "SUB", "SUP", "TIME", "U"];
            /* the first check is for custom elements @see https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_custom_elements#registering_a_custom_element */
            if (element.tagName.includes("-")) {
                return true;
            }
            const elementHasImplicitProhibitedRole = tagsWithImplicitProhibitedRole.includes(element.tagName);
            if (elementHasImplicitProhibitedRole && !element.getAttribute("role")) {
                return true;
            }
            if (element.getAttribute("role") && prohibitedRoles.includes(element.getAttribute("role"))) {
                return true;
            }
            return false;
        }
    }

    /**
     * Detector whether a given `element` is explicitly hidden from screen-reader.
     */
    class CompliantTraitExplicitlyHidden extends CompliantDetector {
        /** @inheritDoc */
        static id = "compliant-trait-explicitly-hidden";
        /** @inheritDoc */
        static subsetOf = [];
        /** @inheritDoc */
        static detect(element, classifier) {
            const hasAriaHidden = element.getAttribute("aria-hidden") === "true";
            const isHidden = element.hasAttribute("hidden");
            if (hasAriaHidden || isHidden) {
                return true;
            }
            const { visibilityInfo } = classifier.getOperations(element);
            return visibilityInfo.display === "none" || visibilityInfo.visibility === "hidden";
        }
    }

    /**
     * Detector whether screen-reader will consider given `element` as an image.
     */
    class CompliantComponentImage extends CompliantDetector {
        /** @inheritDoc */
        static id = "compliant-component-image";
        /** @inheritDoc */
        static subsetOf = [CompliantTraitExposed];
        /** @inheritDoc */
        static detect(element) {
            return element.matches("img:not([role]:not([role=''])), [role=img]");
        }
    }

    /**
     * Detector whether screen-reader will consider given `element` as a search landmark.
     */
    class CompliantComponentSearch extends CompliantDetector {
        /** @inheritDoc */
        static id = "compliant-component-search";
        /** @inheritDoc */
        static subsetOf = [PerceivableTraitRenderable];
        /** @inheritDoc */
        static detect(element) {
            return element.matches("search:not([role]:not([role=''])), [role=search]");
        }
    }

    /**
     * Detector whether screen-reader will consider given `element` as a form.
     */
    class CompliantComponentForm extends CompliantDetector {
        /** @inheritDoc */
        static id = "compliant-component-form";
        /** @inheritDoc */
        static subsetOf = [CompliantTraitExposed];
        static dependencies = [CompliantComponentSearch];
        /** @inheritDoc */
        static detect(element, classifier) {
            /**
             * If the element is a form it can also be a search landmark.
             */
            if (element.matches("form") && classifier.assert(element, CompliantComponentSearch)) {
                return true;
            }
            return element.matches("form:not([role]:not([role=''])), [role=form]");
        }
    }

    /**
     * Detector whether screen-reader will consider given `element` as a table.
     */
    class CompliantComponentTable extends CompliantDetector {
        /** @inheritDoc */
        static id = "compliant-component-table";
        /** @inheritDoc */
        static subsetOf = [CompliantTraitExposed];
        /** @inheritDoc */
        static detect(element) {
            return element.matches("table:not([role]:not([role=''])), [role=table]");
        }
    }

    /**
     * Detector whether screen-reader will consider given `element` as a table-row.
     */
    class CompliantComponentTableRow extends CompliantDetector {
        /** @inheritDoc */
        static id = "compliant-component-table-row";
        /** @inheritDoc */
        static subsetOf = [CompliantTraitExposed];
        /** @inheritDoc */
        static detect(element) {
            return element.matches("tr:not([role]:not([role=''])), [role=row]");
        }
    }

    /**
     * Detector whether screen-reader will consider given `element` as the page footer.
     */
    class CompliantComponentFooter extends CompliantDetector {
        /** @inheritDoc */
        static id = "compliant-component-footer";
        /** @inheritDoc */
        static subsetOf = [CompliantTraitExposed];
        /** @inheritDoc */
        static detect(element) {
            return element.matches("footer:not([role]:not([role=''])), [role='contentinfo']");
        }
    }

    /**
     * Detector whether screen-reader will consider given `element` as a header.
     */
    class CompliantComponentHeader extends CompliantDetector {
        /** @inheritDoc */
        static id = "compliant-component-header";
        /** @inheritDoc */
        static subsetOf = [CompliantTraitExposed];
        /** @inheritDoc */
        static detect(element) {
            return element.matches("header:not([role]:not([role=''])), [role=banner]");
        }
    }

    /**
     * Detector whether screen-reader will consider given `element` as the page main content.
     */
    class CompliantComponentMainContent extends CompliantDetector {
        /** @inheritDoc */
        static id = "compliant-component-main-content";
        /** @inheritDoc */
        static subsetOf = [CompliantTraitExposed];
        /** @inheritDoc */
        static detect(element) {
            return element.matches("main:not([role]:not([role=''])), [role='main']");
        }
    }

    /**
     * Detector whether screen-reader will consider given `element` as a list.
     */
    class CompliantComponentList extends CompliantDetector {
        /** @inheritDoc */
        static id = "compliant-component-list";
        /** @inheritDoc */
        static subsetOf = [CompliantTraitExposed];
        /** @inheritDoc */
        static detect(element) {
            return element.matches("ol:not([role]),ol[role=''],ol[role='region'],ul:not([role]),ul[role=''],ul[role='region'],[role='list']");
        }
    }

    /**
     * Detector whether screen-reader will consider given `element` as a list item.
     */
    class CompliantComponentListItem extends CompliantDetector {
        /** @inheritDoc */
        static id = "compliant-component-list-item";
        /** @inheritDoc */
        static subsetOf = [CompliantTraitExposed];
        /** @inheritDoc */
        static detect(element) {
            return element.matches("li:not([role]:not([role=''])), [role=listitem]");
        }
    }

    /**
     * Detector whether screen-reader will consider given `element` as navigation.
     */
    class CompliantComponentNavigation extends CompliantDetector {
        /** @inheritDoc */
        static id = "compliant-component-navigation";
        /** @inheritDoc */
        static subsetOf = [CompliantTraitExposed];
        /** @inheritDoc */
        static detect(element) {
            return element.matches("nav:not([role]), [role=navigation]");
        }
    }

    /**
     * Detector whether screen-reader will consider given `element` as an article.
     * docs:  https://www.w3.org/WAI/GL/wiki/Using_HTML5_article_element
     *        https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/article_role
     */
    class CompliantComponentArticle extends CompliantDetector {
        /** @inheritDoc */
        static id = "compliant-component-article";
        /** @inheritDoc */
        static subsetOf = [CompliantTraitExposed];
        /** @inheritDoc */
        static detect(element) {
            return element.matches("article:not([role]):not([role='']), [role=article]");
        }
    }

    /**
     * Detector whether the given `element` is a compliant table column header.
     */
    class CompliantComponentTableColumnHeader extends CompliantDetector {
        /** @inheritDoc */
        static id = "compliant-component-table-column-header";
        /** @inheritDoc */
        static subsetOf = [CompliantTraitExposed];
        /** @inheritDoc */
        static detect(element) {
            return element.matches("th:not([scope]:not([scope=''])), th[scope=col], [role=columnheader]");
        }
    }

    /**
     * Detector whether screen-reader will consider given `element` as a table-row-header.
     */
    class CompliantComponentTableRowHeader extends CompliantDetector {
        /** @inheritDoc */
        static id = "compliant-component-table-row-header";
        /** @inheritDoc */
        static subsetOf = [CompliantTraitExposed];
        /** @inheritDoc */
        static detect(element) {
            /**
             * https://www.w3.org/WAI/WCAG21/Techniques/html/H63
             * Quote: "For simple tables that have the headers in the first row or column then it is sufficient to simply use the TH elements without scope."
             * So if the <th> is the only header element in the row, and it has at least one <td> sibling, it is ok to assume the <th> is a row header.
             */
            const isThElement = element.tagName === "TH";
            // Sometimes rows can contain elements like <caption> that are not <td> or <th>, yet still have a <th> as the first cell right after.
            const isFirstCell = !element.previousElementSibling || !["TD", "TH"].includes(element.previousElementSibling.tagName);
            const isNextCellTD = element.nextElementSibling?.tagName === "TD";
            const isThElementAndPlacedLikeRowHeader = isThElement && isFirstCell && isNextCellTD;
            if (isThElementAndPlacedLikeRowHeader && !element.hasAttribute("scope") && !element.hasAttribute("role")) {
                return true;
            }
            return element.matches("th[scope=row], [role=rowheader]");
        }
    }

    /**
     * Detector whether the given `element` is a compliant menu item component.
     * NOTE: <menuitem> is not supported in HTML5 and is deprecated.
     * For historical reasons, we will still match it as a compliant menu item.
     * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/menuitem
     */
    class CompliantComponentMenuItem extends CompliantDetector {
        /** @inheritDoc */
        static id = "compliant-component-menu-item";
        /** @inheritDoc */
        static subsetOf = [CompliantTraitExposed];
        /** @inheritDoc */
        static detect(element) {
            return element.matches("menuitem:not([role]:not([role=''])), [role='menuitem']");
        }
    }

    /**
     * Detector whether screen-reader will consider given `element` as the page main content.
     */
    class CompliantComponentMenubar extends CompliantDetector {
        /** @inheritDoc */
        static id = "compliant-component-menubar";
        /** @inheritDoc */
        static subsetOf = [CompliantTraitExposed];
        /** @inheritDoc */
        static detect(element) {
            return element.matches("[role='menubar']");
        }
    }

    /**
     * Detector given element is a compliant menu component.
     */
    class CompliantComponentMenu extends CompliantDetector {
        /** @inheritDoc */
        static id = "compliant-component-menu";
        /** @inheritDoc */
        static subsetOf = [CompliantTraitExposed];
        /** @inheritDoc */
        static detect(element) {
            return element.matches("menu:not([role]:not([role=''])), [role='menu']");
        }
    }

    /**
     * Detector whether screen-reader will consider given `element` as a dialog.
     */
    class CompliantComponentDialogModal extends CompliantDetector {
        /** @inheritDoc */
        static id = "compliant-component-dialog-modal";
        /** @inheritDoc */
        static subsetOf = [CompliantTraitExposed];
        /** @inheritDoc */
        static detect(element) {
            const validSelectors = ["dialog[open]:not([role]:not([role='']))", "dialog[role='dialog']", "dialog[role='alertdialog']", "[role='dialog'][aria-modal='true']", "[role='alertdialog'][aria-modal='true']"];
            return element.matches(validSelectors.join(", "));
        }
    }

    /**
     * Detector whether the given `element` is a compliant breadcrumb component.
     */
    class CompliantComponentBreadcrumb extends CompliantDetector {
        /** @inheritDoc */
        static id = "compliant-component-breadcrumb";
        /** @inheritDoc */
        static subsetOf = [CompliantTraitExposed];
        /** @inheritDoc */
        static detect(element, classifier) {
            const operations = classifier.getOperations(element);
            const { ariaText } = operations.contentInfo;
            return distExports.textContainsWord(ariaText, "breadcrumb") || distExports.textContainsWord(ariaText, "breadcrumbs");
        }
    }

    /**
     * Detector whether screen-reader will consider given `element` as an iframe.
     */
    class CompliantComponentIframe extends CompliantDetector {
        /** @inheritDoc */
        static id = "compliant-component-iframe";
        /** @inheritDoc */
        static subsetOf = [CompliantTraitExposed];
        /** @inheritDoc */
        static detect(element) {
            return element.matches("iframe:not([role]:not([role='']))");
        }
    }

    /**
     * Detector whether screen-reader will consider given `element` as a paragraph.
     */
    class CompliantComponentParagraph extends CompliantDetector {
        /** @inheritDoc */
        static id = "compliant-component-paragraph";
        /** @inheritDoc */
        static subsetOf = [CompliantTraitExposed];
        /** @inheritDoc */
        static detect(element) {
            return element.matches("p:not([role]:not([role='']))");
        }
    }

    /**
     * Detector whether screen-reader will consider given `element` as a radio button.
     */
    class CompliantComponentRadioButton extends CompliantDetector {
        /** @inheritDoc */
        static id = "compliant-component-radio-button";
        /** @inheritDoc */
        static subsetOf = [CompliantTraitExposed];
        /** @inheritDoc */
        static detect(element) {
            return element.matches("input[type=radio]:not([role]:not([role=''])), [role=radio]");
        }
    }

    /**
     * Detector whether screen-reader will consider given `element` as a checkbox.
     */
    class CompliantComponentCheckbox extends CompliantDetector {
        /** @inheritDoc */
        static id = "compliant-component-checkbox";
        /** @inheritDoc */
        static subsetOf = [CompliantTraitExposed];
        /** @inheritDoc */
        static detect(element) {
            return element.matches("input[type=checkbox]:not([role]:not([role=''])), [role=checkbox]");
        }
    }

    /**
     * Detector whether screen-reader will consider given `element` as a table-data-cell.
     */
    class CompliantComponentTableDataCell extends CompliantDetector {
        /** @inheritDoc */
        static id = "compliant-component-table-data-cell";
        /** @inheritDoc */
        static subsetOf = [CompliantTraitExposed];
        /** @inheritDoc */
        static notSubsetOf = [CompliantComponentTable];
        /** @inheritDoc */
        static detect(element, classifier) {
            // We need to check if the element is a child of a table to exclude grid cells
            if (!classifier.getParent(element, CompliantComponentTable)) {
                return false;
            }
            return element.matches("td:not([role]:not([role=''])), [role=cell]");
        }
    }

    /**
     * Detector whether the given `element` is a compliant submenu controller component.
     * NOTE: <menuitem> is not supported in HTML5 and is deprecated.
     * For historical reasons, we will still match it as a compliant menu item.
     * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/menuitem
     * @see https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-expanded#menu
     * @see https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-haspopup
     */
    class CompliantComponentMenuTrigger extends CompliantDetector {
        /** @inheritDoc */
        static id = "compliant-component-menu-trigger";
        /** @inheritDoc */
        static subsetOf = [CompliantTraitExposed];
        /** @inheritDoc */
        static dependencies = [CompliantComponentListItem, CompliantComponentMenuItem];
        /** @inheritDoc */
        static detect(element) {
            /**
             * TODO: temporarility comented due to it causing issues with menu-trigger-mismatch rule, in siutations where the menu-trigger is not a child of list-item or menu-item.
             * this happens in clases where for example the parent is a button that is neither a list-item nor a menu-item, and we don't have list-item-mismatch or menu-item-mismatch rules to "repair" the situation.
             */
            // const hasListItemParent = classifier.getParent(element, CompliantComponentListItem);
            // const hasMenuItemParent = classifier.getParent(element, CompliantComponentMenuItem);
            // if (!hasListItemParent && !hasMenuItemParent) {
            //   return false;
            // }
            const ariaExpanded = element.getAttribute("aria-expanded");
            const ariaHasPopup = element.getAttribute("aria-haspopup");
            return !!ariaExpanded && (ariaHasPopup === "menu" || ariaHasPopup === "true");
        }
    }

    /**
     * Detector whether the provided element is a compliant table-header.
     */
    class CompliantComponentTableHeader extends CompliantDetector {
        /** @inheritDoc */
        static id = "compliant-component-table-header";
        /** @inheritDoc */
        static subsetOf = [CompliantTraitExposed];
        /** @inheritDoc */
        static detect(element) {
            return element.matches("thead");
        }
    }

    /**
     * Detector whether the provided element is a compliant table-body.
     */
    class CompliantComponentTableBody extends CompliantDetector {
        /** @inheritDoc */
        static id = "compliant-component-table-body";
        /** @inheritDoc */
        static subsetOf = [CompliantTraitExposed];
        /** @inheritDoc */
        static detect(element) {
            return element.matches("tbody");
        }
    }

    /**
     * Detector whether screen-reader will consider given `element` as a table-row.
     */
    class CompliantComponentTableFooter extends CompliantDetector {
        /** @inheritDoc */
        static id = "compliant-component-table-footer";
        /** @inheritDoc */
        static subsetOf = [CompliantTraitExposed];
        /** @inheritDoc */
        static detect(element) {
            return element.matches("tfoot");
        }
    }

    /**
     * Detector whether screen-reader will consider given `element` as a tab.
     */
    class CompliantComponentTab extends CompliantDetector {
        /** @inheritDoc */
        static id = "compliant-component-tab";
        /** @inheritDoc */
        static subsetOf = [CompliantTraitExposed];
        /** @inheritDoc */
        static detect(element) {
            return element.matches("[role=tab]");
        }
    }

    /**
     * Responsible for associating input elements with their respective forms
     */
    class FormInputsContext extends Context {
        /** @inheritDoc */
        data = {
            formInputs: new Map(),
        };
        set({ input, form }) {
            const inputs = new Set(this.data.formInputs.get(form) || []);
            inputs.add(input);
            this.data.formInputs.set(form, inputs);
        }
    }

    /**
     * Detector if an element is a compliant form submit button
     */
    class CompliantComponentFormSubmitButton extends CompliantDetector {
        /** @inheritDoc */
        static id = "compliant-component-form-submit-button";
        /** @inheritDoc */
        static subsetOf = [CompliantTraitExposed];
        /** @inheritDoc */
        static dependencies = [CompliantComponentForm];
        static contextType = FormInputsContext;
        /** @inheritDoc */
        static classifier;
        /**
         * detect if an element is a submit button
         */
        static isSubmitButton(element) {
            if (element.matches("input[type=submit], button[type=submit]")) {
                return true;
            }
            /**
             * as noted in WCAG docs, image buttons are also considered submit buttons
             * @see https://www.w3.org/WAI/WCAG22/Techniques/html/H32
             *
             * TODO: need to check if this is always the case or if there should be a context of submit for an image button: @see https://www.w3.org/WAI/WCAG22/Techniques/html/H36
             */
            if (isImageButton(element)) {
                return true;
            }
            // Check sr only content for submit dictionary match
            const srVisibleText = this.classifier.getOperations(element).contentInfo.srVisibleText;
            if (distExports.textContainsWord(srVisibleText, "submit")) {
                return true;
            }
            return false;
        }
        /** @inheritDoc */
        static detect(element, classifier, __, context) {
            this.classifier = classifier;
            const form = classifier.getParent(element, CompliantComponentForm);
            if (form) {
                return this.isSubmitButton(element);
            }
            const associatedFormId = element.getAttribute("form");
            if (associatedFormId) {
                const associatedForm = element.ownerDocument.getElementById(associatedFormId);
                /**
                 * NOTE: we check if it's an instance of HTMLFormElement and not asserting against `CompliantComponentForm` because:
                 * 1. this is only correct for native form elements and `CompliantComponentForm` returns true for elements with role="form" which is wrong to use here
                 * 2. the association is relevant even if the form is hidden, and `CompliantComponentForm` checks for visibility
                 */
                if (isInstanceOf(associatedForm, HTMLFormElement)) {
                    context.set({ input: element, form: associatedForm });
                    return this.isSubmitButton(element);
                }
            }
            return false;
        }
    }

    /**
     * Detector whether screen-reader will consider given `element` as a select option.
     */
    class CompliantComponentSelectOption extends CompliantDetector {
        /** @inheritDoc */
        static id = "compliant-component-select-option";
        /** @inheritDoc */
        static subsetOf = [];
        /** @inheritDoc */
        static detect(element) {
            return element.matches("option:not([role]:not([role=''])), [role=option]");
        }
    }

    /**
     * Detector whether screen-reader will consider given `element` as a switch (toggle).
     * TODO: Implement rule in Auditor to check if the switch has the attribute `aria-checked` set to `true` or `false`. The role `switch` requires the attribute `aria-checked` to be set to `true` or `false` to indicate the current state of the switch.
     * @see https://www.w3.org/WAI/ARIA/apg/patterns/switch/
     */
    class CompliantComponentSwitch extends CompliantDetector {
        /** @inheritDoc */
        static id = "compliant-component-switch";
        /** @inheritDoc */
        static subsetOf = [CompliantTraitExposed];
        /** @inheritDoc */
        static detect(element) {
            return element.matches("[role=switch]");
        }
    }

    /**
     * Detects superscript elements
     */
    class CompliantComponentSuperscript extends CompliantDetector {
        /** @inheritDoc */
        static id = "compliant-component-superscript";
        /** @inheritDoc */
        static subsetOf = [CompliantTraitExposed];
        static dependencies = [];
        /** @inheritDoc */
        static detect(element) {
            return element.matches("sup:not([role]):not([role='']), [role=superscript]");
        }
    }

    /**
     * Detects subscript elements
     */
    class CompliantComponentSubscript extends CompliantDetector {
        /** @inheritDoc */
        static id = "compliant-component-subscript";
        /** @inheritDoc */
        static subsetOf = [CompliantTraitExposed];
        static dependencies = [];
        /** @inheritDoc */
        static detect(element) {
            return element.matches("sub:not([role]):not([role='']), [role=subscript]");
        }
    }

    class ContentInfo extends Operation {
        element;
        resources;
        classifier;
        /**
         * @inheritdoc
         */
        static dependencies = [
            PerceivableTraitTabbable,
            PerceivableTraitVisible,
            CompliantComponentButton,
            CompliantComponentCheckbox,
            CompliantComponentHeading,
            CompliantComponentLink,
            CompliantComponentMenuItem,
            CompliantComponentRadioButton,
            CompliantComponentTab,
            CompliantComponentTableColumnHeader,
            CompliantComponentTableDataCell,
            CompliantComponentTableRow,
            CompliantComponentTableRowHeader,
        ];
        /**
         * returns the direct text content of an element.
         */
        static getDirectText(element) {
            let text = "";
            for (const child of element.childNodes) {
                if (child.nodeType === Node.TEXT_NODE) {
                    text += child.nodeValue;
                }
            }
            return text;
        }
        /**
         * A generator that returns the visible text content of the specified node and its descendants recursively.
         * @param element The root element to get the visible text content from.
         * @param classifier The classifier to use for assertions.
         * @param reverse Whether to iterate over the children in reverse order.
         */
        static *visibleTextGenerator(element, classifier, reverse = false) {
            if (!classifier.assert(element, PerceivableTraitVisible) || classifier.getOperations(element).typographyInfo.fontSize <= VisibilityInfo.MIN_FONT_VISIBLE_SIZE) {
                return;
            }
            if (isButtonLikeInput(element)) {
                // inputs don't have children, so we need to check only the value attribute
                const inputValue = this.getInputValue(element);
                if (inputValue) {
                    yield inputValue;
                }
                return;
            }
            const children = reverse ? Array.from(element.childNodes).reverse() : element.childNodes;
            for (const child of children) {
                if (isInstanceOf(child, Text)) {
                    const nodeContent = ContentInfo.normalizeText(child.nodeValue);
                    if (nodeContent && VisibleTextUtils.isTextNodeVisible(child, classifier)) {
                        yield ContentInfo.removeExtraWhitespace(child.nodeValue);
                    }
                }
                else if (isSvgOrHtmlElement(child)) {
                    yield* this.visibleTextGenerator(child, classifier, reverse);
                }
            }
        }
        /**
         * A generator that returns the text content of the specified node and its descendants in reverse order.
         * @param element
         * @param classifier
         */
        static *textContentGenerator(element, classifier) {
            for (const child of element.childNodes) {
                if (isInstanceOf(child, Text)) {
                    const nodeContent = ContentInfo.normalizeText(child.nodeValue);
                    if (nodeContent) {
                        yield ContentInfo.removeExtraWhitespace(child.nodeValue);
                    }
                }
                else if (isSvgOrHtmlElement(child)) {
                    yield* this.textContentGenerator(child, classifier);
                }
            }
        }
        /**
         * determines if the given element has a role that according to WAI ARIA's Accessible Name and Description Computation, should be named by its child content.
         * "Elements having one of the following roles are, by default, named by a string calculated from their descendant content"
         * @see https://www.w3.org/WAI/ARIA/apg/practices/names-and-descriptions/#namingtechniques
         * @see https://www.w3.org/TR/wai-aria-1.1/#namefromcontent
         *
         * NOTE: 'rowgroup' and 'tree' appear in the spec but do not generate a name out of their children, so they are not included here (also, in the links above, they appear in the second link but not in the first)
         */
        static namedByChildContent(element, classifier) {
            const roles = ["gridcell", "menuitemcheckbox", "menuitemradio", "option", "switch", "tooltip", "treeitem"]; // TODO: to be deleted when the roles are implemented as compliant detectors
            const compliantDetectors = [
                CompliantComponentButton,
                CompliantComponentTableDataCell,
                CompliantComponentTableColumnHeader,
                CompliantComponentCheckbox,
                // TODO: CompliantGridCell,
                CompliantComponentHeading,
                CompliantComponentLink,
                CompliantComponentMenuItem,
                // TODO: CompliantComponentMenuitemcheckbox,
                // TODO: CompliantComponentMenuitemradio,
                // TODO: CompliantComponentOption,
                CompliantComponentRadioButton,
                CompliantComponentTableRow,
                CompliantComponentTableRowHeader,
                // TODO: CompliantComponentSwitch,
                CompliantComponentTab,
                // TODO: CompliantComponentTooltip,
                // TODO: CompliantComponentTreeitem,
            ];
            return compliantDetectors.some((detector) => classifier.assert(element, detector)) || roles.includes(element.getAttribute("role"));
        }
        /**
         * iterates over the labels that are associated with the element and aggregates their text content.
         */
        static getLabelContent(element, classifier, visited = new Set()) {
            const labelTexts = [];
            for (const label of getAssociatedLabels(element)) {
                /**
                 * TODO: would be better to have this check already done inside `getAggregatedTextContent` method instead of doing this twice.
                 * same for other instanes in this file.
                 */
                if (this.isNodeHiddenFromScreenReader(label, classifier)) {
                    continue;
                }
                const res = this.getAggregatedTextContent(label, classifier, {
                    visited,
                    skipCb: (node) => {
                        if (this.isNodeHiddenFromScreenReader(node, classifier)) {
                            return true;
                        }
                        /**
                         * if an element already has related label content (as a parent of the element), we need to ignore the text content of the element itself.
                         * related e2e test: "src/operations/content-info/e2e/button-with-label-parent.html"
                         */
                        if (element === node) {
                            return true;
                        }
                    },
                });
                if (res) {
                    labelTexts.push(res);
                }
            }
            return this.normalizeText(labelTexts.join(" "));
        }
        /**
         * returns the text content with extra whitespace removed and trimmed.
         */
        static normalizeText(text) {
            return this.removeExtraWhitespace(text).trim();
        }
        /**
         * removes extra whitespace from the text content.
         */
        static removeExtraWhitespace(text) {
            return text.replace(/\s+/g, " ");
        }
        static getAriaContent(element, classifier, visited = new Set()) {
            /**
             * The aria-label attribute is used to define a string that labels the current element.
             * It is used to provide a more accessible name for the element.
             */
            const ariaLabel = element.getAttribute("aria-label") ?? "";
            const ariaLabelledbyText = this.getAriaText(element, "aria-labelledby", classifier, visited);
            const ariaDescribedbyText = this.getAriaText(element, "aria-describedby", classifier, visited);
            return {
                ariaLabel,
                ariaLabelledbyText,
                ariaDescribedbyText,
            };
        }
        /**
         * The aria-labelledby and aria-describedby attributes are used to indicate the IDs of the elements that are the labels and description for the current element.
         * The elements might not be visible to the user, but are read by screen readers.
         * This gets all the elements that are referenced by the an aria attribute and aggregates their text content.
         */
        static getAriaText(element, attribute, classifier, visited = new Set()) {
            if (visited.has(element)) {
                return "";
            }
            const ariaElements = getAriaElements(element, attribute);
            return ariaElements
                .map((el) => {
                visited.add(el);
                return this.getAggregatedTextContent(el, classifier, {
                    visited,
                    skipCb: (node) => {
                        /**
                         * stops the recursion if the node is a parent of the element
                         * related e2e test: @see file://./e2e/element-labelled-by-parent.html
                         * related unit test: "getAriaText => should return the text content of an aria-labelledby element that is a child of the element"
                         */
                        return node.contains(element);
                    },
                });
            })
                .join(" ");
        }
        /**
         * returns the alt text of an image element or an input type=image element.
         */
        static getImageAltText(node) {
            if (!isAltElement(node)) {
                return "";
            }
            const alt = node.getAttribute("alt") ?? "";
            return alt.trim();
        }
        /**
         * checks if a node or it's element parent is hidden and invisible to screen readers.
         * NOTE: we are checking for parentElement instead of returning 'false' because we want to get results of a given text node for example.
         */
        static isNodeHiddenFromScreenReader(node, classifier) {
            if (isSvgOrHtmlElement(node)) {
                return classifier.getOperations(node).visibilityInfo.isHiddenFromScreenReader;
            }
            const element = node.parentElement;
            return classifier.getOperations(element).visibilityInfo.isHiddenFromScreenReader;
        }
        /**
         * returns the value of an input element.
         */
        static getInputValue(node) {
            if (isInstanceOf(node, HTMLInputElement) || isInstanceOf(node, HTMLTextAreaElement)) {
                return node.getAttribute("value") ?? "";
            }
        }
        /**
         * returns the placeholder of an input/textarea element.
         */
        static getInputPlaceholder(node) {
            if (isInstanceOf(node, HTMLInputElement) || isInstanceOf(node, HTMLTextAreaElement)) {
                return node.getAttribute("placeholder") ?? "";
            }
        }
        /**
         * returns the content of the pseudo-element ::before
         */
        static getBeforeContent(node, classifier) {
            const pseudoBefore = classifier.getOperations(node).resources.computedPseudoBeforeStyle.content;
            return this.normalizePseudoContent(pseudoBefore);
        }
        /**
         * returns the content of the pseudo-element ::after
         */
        static getAfterContent(node, classifier) {
            const pseudoAfter = classifier.getOperations(node).resources.computedPseudoAfterStyle.content;
            return this.normalizePseudoContent(pseudoAfter);
        }
        /**
         * returns the normalized content of a pseudo-element; excludes default values and removes quotes.
         */
        static normalizePseudoContent(content) {
            if (!content || content === "none" || content === "-moz-alt-content") {
                // -moz-alt-content is a default value for elements with alt text that don't have content in Firefox and needs to be ignored as well
                return "";
            }
            return content.replace(/(^"|"$)/g, "").trim();
        }
        /**
         * removes private use characters from the content.
         * Private use characters are characters in the range U+E000 to U+F8FF, which are not assigned to any character in the Unicode standard.
         */
        static removePrivateUseChars(content) {
            return content.replace(/\p{Private_Use}/gu, "").trim();
        }
        /**
         * aggregates the text content of an element and its children while skipping certain nodes based on the skipCb callback.
         */
        static getAggregatedTextContent(node, classifier, { skipCb, visited = new Set(), } = {}) {
            let content = "";
            if (!isSvgOrHtmlElement(node)) {
                return content;
            }
            const beforeContent = this.removePrivateUseChars(this.getBeforeContent(node, classifier));
            if (beforeContent) {
                content += beforeContent;
            }
            const ariaLabelAndDescription = this.getAriaLabelAndDescription(node, classifier, visited);
            if (ariaLabelAndDescription) {
                content += ` ${ariaLabelAndDescription} `;
            }
            if (isInstanceOf(node, HTMLInputElement) && isButtonLikeInput(node)) {
                const inputValue = this.getInputValue(node);
                if (inputValue) {
                    content += ` ${inputValue} `;
                }
            }
            const inputPlaceholder = this.getInputPlaceholder(node);
            if (inputPlaceholder) {
                content += ` ${inputPlaceholder} `;
            }
            for (const child of node.childNodes) {
                if (child.nodeType === Node.TEXT_NODE) {
                    const textContent = child.nodeValue;
                    if (textContent) {
                        content += textContent;
                    }
                }
                else if (child.nodeType === Node.ELEMENT_NODE) {
                    const shouldSkip = skipCb?.(child);
                    if (shouldSkip) {
                        continue;
                    }
                    content += this.getAggregatedTextContent(child, classifier, { skipCb, visited });
                }
            }
            const afterContent = this.removePrivateUseChars(this.getAfterContent(node, classifier));
            if (afterContent) {
                content += afterContent;
            }
            return this.removeExtraWhitespace(content);
        }
        static getSrVisibleText(element, classifier) {
            const isTabbable = classifier.assert(element, PerceivableTraitTabbable);
            if (isTabbable || this.namedByChildContent(element, classifier)) {
                const text = this.getAggregatedTextContent(element, classifier, { skipCb: (node) => this.isNodeHiddenFromScreenReader(node, classifier) });
                return this.normalizeText(text);
            }
            /**
             * return the sr visible text of the element if it's not tabbable.
             */
            const text = this.getAggregatedTextContent(element, classifier, {
                skipCb: (node) => {
                    /**
                     * if the node is hidden from screen readers, we skip it.
                     */
                    if (this.isNodeHiddenFromScreenReader(node, classifier)) {
                        return true;
                    }
                    /**
                     * if the node is an image, we skip it. this is how the accessibility tree works in this scenario.
                     * related e2e test: src/operations/content-info/e2e/div-text-content-and-image.html"
                     */
                    if (isInstanceOf(node, HTMLImageElement)) {
                        return true;
                    }
                    if (isSvgOrHtmlElement(node)) {
                        const { display } = classifier.getOperations(node).resources.computedStyle;
                        /**
                         * if the node is not an inline element, we skip it. this is how the accessibility tree works in this scenario.
                         * related e2e tests:
                         * - src/operations/content-info/e2e/generic-element-without-direct-text.html
                         * - src/operations/content-info/e2e/div-inside-span.html
                         */
                        if (display !== "inline") {
                            return true;
                        }
                        /**
                         * if the node is tabbable, we skip it. this is how the accessibility tree works in this scenario.
                         * related e2e test: src/operations/content-info/e2e/div-text-content-and-input.html
                         */
                        const isTabbable = classifier.assert(node, PerceivableTraitTabbable);
                        if (isTabbable) {
                            return true;
                        }
                    }
                    return false;
                },
            });
            return this.normalizeText(text);
        }
        static getAriaDescribedbyText(element, classifier, visited = new Set()) {
            const { ariaDescribedbyText } = ContentInfo.getAriaContent(element, classifier, visited);
            return ContentInfo.normalizeText(ariaDescribedbyText);
        }
        static getAccessibleName(element, classifier, visited = new Set()) {
            const { ariaLabel, ariaLabelledbyText } = ContentInfo.getAriaContent(element, classifier, visited);
            const alt = ContentInfo.getImageAltText(element);
            /**
             * aria-labelledby takes precedence over aria-label, while aria-label takes precedence over an associated label, then alt, last one is title.
             */
            return ContentInfo.normalizeText(ariaLabelledbyText || ariaLabel || this.getLabelContent(element, classifier, visited) || alt || (element.getAttribute("title") ?? ""));
        }
        static getTitle(element) {
            return ContentInfo.normalizeText(element.getAttribute("title") ?? "");
        }
        static getAriaLabelAndDescription(element, classifier, visited = new Set()) {
            /**
             * TODO: check where 'title' should be, is it considered as 'name' or 'description'?
             * e.g:
             * - with HTMLButtonElement the title is considered the aria-label
             * - with HTMLSpanElement the title is considered the aria-description
             */
            const ariaContent = [ContentInfo.getAccessibleName(element, classifier, visited), ContentInfo.getAriaDescribedbyText(element, classifier, visited) || ContentInfo.getTitle(element)].join(" ").trim();
            return ContentInfo.normalizeText(ariaContent);
        }
        constructor(element, resources, classifier) {
            super();
            this.element = element;
            this.resources = resources;
            this.classifier = classifier;
        }
        /**
         * The visibleText property returns the text content of the specified node, and all its descendants that are visible to the user.
         */
        get visibleText() {
            return ContentInfo.normalizeText(Array.from(this.visibleTextGenerator).join(""));
        }
        /**
         * A generator that returns the visible text content of the specified node and its descendants.
         */
        get visibleTextGenerator() {
            return ContentInfo.visibleTextGenerator(this.element, this.classifier);
        }
        /**
         * A generator that returns the visible text content of the specified node and its descendants in reverse order.
         */
        get visibleTextGeneratorReverse() {
            return ContentInfo.visibleTextGenerator(this.element, this.classifier, true);
        }
        /**
         * A boolean value indicating whether the specified node has any visible text content.
         */
        get hasVisibleText() {
            for (const text of this.visibleTextGenerator) {
                if (text) {
                    return true;
                }
            }
            return false;
        }
        /**
         * The visibleText property returns the text content of the specified node, and all its descendants that are visible to the user.
         */
        get textContent() {
            return ContentInfo.normalizeText(Array.from(this.textContentGenerator).join(""));
        }
        /**
         * A generator that returns the text content of the specified node.
         */
        get textContentGenerator() {
            return ContentInfo.textContentGenerator(this.element, this.classifier);
        }
        /**
         * A boolean value indicating whether the specified node has any text content.
         */
        get hasTextContent() {
            for (const text of this.textContentGenerator) {
                if (text) {
                    return true;
                }
            }
            return false;
        }
        /**
         * All the text content associated with this element, meaning visible inner text and related via labels and aria attributes
         * TODO: currently allText, takes `isNodeHiddenFromScreenReader` into account when it shouldnt. labelText for example is returning content without hidden elements.
         */
        get allText() {
            const text = ContentInfo.getAggregatedTextContent(this.element, this.classifier);
            return ContentInfo.normalizeText(text);
        }
        /**
         * The directText property returns the text content of the specified node, excluding the text content of its descendants.
         */
        get directText() {
            return ContentInfo.normalizeText(ContentInfo.getDirectText(this.element));
        }
        /**
         * the label element's text that's associated with the given element via label[for] or parent label.
         */
        get labelText() {
            return ContentInfo.normalizeText(ContentInfo.getLabelContent(this.element, this.classifier));
        }
        /**
         * The relatedText property returns the text content that is associated with the element via the label element or aria attributes.
         *  TODO: relatedText is redundant, remove it and use srVisibleText instead
         */
        get relatedText() {
            return this.srVisibleText;
        }
        /**
         * The text content that is discernible to a screen reader.
         * the priority of the accessiblity tree is given to aria text, then label text, and then aggregated text content (from text nodes).
         */
        get srVisibleText() {
            if (ContentInfo.isNodeHiddenFromScreenReader(this.element, this.classifier)) {
                return "";
            }
            if (this.ariaText) {
                return this.ariaText;
            }
            return ContentInfo.normalizeText(ContentInfo.getSrVisibleText(this.element, this.classifier));
        }
        /**
         * The title property returns the title attribute of the specified node.
         */
        get title() {
            return ContentInfo.getTitle(this.element);
        }
        /**
         * The element's "Name" representation in the accessibility tree.
         */
        get accessibleName() {
            return ContentInfo.getAccessibleName(this.element, this.classifier);
        }
        /**
         * The element's aria-label and aria-labelledby text representation in the accessibility tree.
         */
        get ariaLabelText() {
            const { ariaLabel, ariaLabelledbyText } = ContentInfo.getAriaContent(this.element, this.classifier);
            /**
             * aria-labelledby takes precedence over aria-label, while aria-label takes precedence over an associated label.
             */
            return ContentInfo.normalizeText(ariaLabelledbyText || ariaLabel);
        }
        /**
         * The element's "Description" representation in the accessibility tree.
         */
        get ariaDescribedbyText() {
            return ContentInfo.getAriaDescribedbyText(this.element, this.classifier);
        }
        /**
         * The text content that is discernible to the screen reader user via aria.
         */
        get ariaText() {
            return ContentInfo.getAriaLabelAndDescription(this.element, this.classifier);
        }
        /**
         * Content Info of the pseudo-element ::before
         */
        get pseudoBefore() {
            const self = this;
            return {
                /**
                 * The text content of the pseudo-element ::before
                 */
                get content() {
                    return ContentInfo.normalizePseudoContent(self.resources.computedPseudoBeforeStyle.content);
                },
            };
        }
        /**
         * Content Info of the pseudo-element ::after
         */
        get pseudoAfter() {
            const self = this;
            return {
                /**
                 * The text content of the pseudo-element ::after
                 */
                get content() {
                    return ContentInfo.normalizePseudoContent(self.resources.computedPseudoAfterStyle.content);
                },
            };
        }
    }

    const SOCIAL_DOMAIN_TO_NAME_MAP = {
        "facebook.com": "facebook",
        "yahoo.com": "yahoo",
        "yandex.com": "yandex",
        "xing.com": "xing",
        "medium.com": "medium",
        "linkedin.com": "linkedin",
        "dribbble.com": "dribbble",
        "github.com": "github",
        "snapchat.com": "snapchat",
        "instagram.com": "instagram",
        "twitter.com": "twitter",
        "x.com": "x",
        "tripadvisor.com": "trip-advisor",
        "yelp.com": "yelp",
        "tiktok.com": "tiktok",
        "whatsapp.com": "whatsapp",
        "whatsapp://": "whatsapp",
        "youtube.com": "youtube",
        "reddit.com": "reddit",
        "tumblr.com": "tumblr",
        "flickr.com": "flickr",
        "pinterest.com": "pinterest",
        "maps.google.com": "google-maps",
    };
    const PAGES_TYPE_TO_ALIASES_MAP = {
        feed: ["rss"],
        search: ["find"],
        favorites: ["wishlist", "saves"],
        contact: ["quote", "offer", "proposal"],
        cart: ["basket", "basket", "bag", "checkout"],
        locations: ["stores", "locator", "locate", "shops"],
        account: ["register", "join", "user", "signup", "profile", "sign-up", "login", "log-in", "sign-up", "log-in"],
    };

    const SHORT_TEXT_THRESHOLD = 3;
    const WORDS_COUNT_THRESHOLD = 4;
    /**
     * Checks whether a given text string is considered ambiguous — meaning it's likely
     * too vague or generic to provide meaningful context on its own.
     *
     * This is commonly used to detect low-context phrases in UI elements like buttons or links,
     * especially in the context of accessibility validation.
     *
     * The text is normalized by:
     * - Lowercasing the entire string
     * - Removing digits
     * - Stripping punctuation and special characters (while keeping spaces)
     * - Splitting the cleaned string into individual words
     *
     * Ambiguity is determined based on:
     * - Texts shorter than `SHORT_TEXT_THRESHOLD` are immediately considered ambiguous
     * - Texts that contain no words after cleanup are considered ambiguous
     * - Texts with `WORDS_COUNT_THRESHOLD` or more words are considered descriptive enough
     * - For shorter texts, if any word matches an entry in `AMBIGUOUS_WORDS` (across all languages),
     *   the text is flagged as ambiguous
     *
     * @param {string} text - The input string to analyze (e.g., a label or link text).
     * @returns {boolean} `true` if the text is likely ambiguous; otherwise, `false`.
     */
    function isTextAmbiguous(text) {
        if (!text) {
            return false;
        }
        if (text.length < SHORT_TEXT_THRESHOLD) {
            return true;
        }
        const words = text
            .toLowerCase()
            .replace(/\d+/g, "")
            .replace(/[^\p{L}\p{N}\s]+/gu, "") // Remove punctuation and special characters, but keep letters and numbers from all languages
            .trim()
            .split(" ")
            .filter(Boolean);
        if (!words.length) {
            return true;
        }
        if (words.length >= WORDS_COUNT_THRESHOLD) {
            return false;
        }
        let isMatchingAmbiguousWord = false;
        // should use?: const lang = LanguageService.locales; instead of looping over all the languages?
        // TODO: Check only for the correct page language
        langLoop: for (const lang in AMBIGUOUS_WORDS) {
            for (const word of AMBIGUOUS_WORDS[lang]) {
                if (words.includes(word)) {
                    isMatchingAmbiguousWord = true;
                    break langLoop;
                }
            }
        }
        return isMatchingAmbiguousWord;
    }
    // TODO: Replace with dictionary if and when created and implemented
    const AMBIGUOUS_WORDS = {
        en: ["more", "here", "see", "show", "learn", "read", "view", "now"],
        he: ["קראו", "קרא", "צפה", "כאן", "לקריאה", "עכשיו"],
        es: ["más", "here", "aquí", "show", "aprender", "leer", "ahora"],
        it: ["di più", "qui", "vedere", "spettacolo", "imparare", "leggere", "adesso"],
        de: ["mehr", "hier", "sehen", "show", "lernen", "lesen", "jetzt"],
        nl: ["meer", "hier", "zien", "tonen", "leren", "lezen", "nu"],
        ru: ["более", "здесь", "видеть", "шоу", "учиться", "читать", "сейчас"],
        pt: ["mais", "aqui", "vejo", "mostrar", "aprender", "leitura", "agora"],
        ja: ["もっと", "ここに", "見る", "公演", "学ぶ", "読んだ", "今"],
        tw: ["更多的", "這裡", "看", "展示", "學", "讀", "現在"],
        za: ["更多的", "這裡", "看", "展示", "學", "讀", "現在"],
        ua: ["أكثر", "هنا", "نرى", "تبين", "يتعلم", "اقرأ", "الآن"],
        ar: ["أكثر", "هنا", "نرى", "تبين", "يتعلم", "اقرأ", "الآن"],
    };

    /**
     * Validates whether a URL string is valid for use with the URL constructor.
     *
     * Supports both absolute and relative URLs when a base is provided.
     *
     * @param {string} urlStr - The URL string to validate.
     * @param {string} base - Base URL for resolving relative URLs.
     * @returns {boolean} - True if the URL is valid, false otherwise.
     */
    function isParsableURL(urlStr, base = window.location.href) {
        // Reject non-string or empty inputs
        if (typeof urlStr !== "string" || urlStr.trim() === "")
            return false;
        // Use URL.canParse if available (modern browsers)
        if (typeof URL.canParse === "function") {
            return URL.canParse(urlStr, base);
        }
        // Fallback: attempt to construct the URL
        try {
            new URL(urlStr, base);
            return true;
        }
        catch {
            return false;
        }
    }

    var Validators = /*#__PURE__*/Object.freeze({
        __proto__: null,
        isIteratorLike: isIteratorLike,
        isParsableURL: isParsableURL,
        isTextAmbiguous: isTextAmbiguous
    });

    /**
     * Get the context info for an element, currently only supports buttons and links
     */
    class ContextInfo extends Operation {
        element;
        /**
         * @inheritdoc
         */
        static dependencies = [];
        static DEFAULT_DESTINATION_TYPE = "none";
        /**
         * A strings generator representing context of the element created with the elements classes, tag name, id and attributes
         */
        get elementContexts() {
            return extractElementContexts(this.element);
        }
        /**
         * The type of the destination of the link (internal, external, anchor, social, page)
         */
        get destinationType() {
            const destination = this.element.getAttribute("href") ?? "";
            return ContextInfo.getDestinationType(destination, this.contentInfo);
        }
        /**
         * If the link is considered ambiguous
         */
        get isAmbiguous() {
            return ContextInfo.getIsLinkAmbiguous(this.contentInfo);
        }
        /**
         * If the link is considered to have enough text to provide context for the link
         */
        get hasContextualText() {
            return ContextInfo.hasContextualText(this.contentInfo.visibleText) || ContextInfo.hasContextualText(this.contentInfo.relatedText);
        }
        contentInfo;
        constructor(element, resources, classifier) {
            super();
            this.element = element;
            const { contentInfo } = classifier.getOperations(element);
            this.contentInfo = contentInfo;
        }
        /**
         * Understanding the elements destination.
         * The destination type is determined by the following rules:
         * - If the link is an anchor link it's classified as anchor - i.e #details
         * - If the link is external (not on the same domain) it's classified as external (might be overridden by a more specific classification)
         * - If the link contains a social media link it's classified as social.{type} - i.e social.facebook
         * - If the link contains a page link it's classified as page.{type} - i.e page.account
         * - If the link is an internal link it's classified as internal (but not found in the pages) - i.e /custom-page
         * - If none of the above, or if the destination is empty - will return a default value
         *
         * @param destination The link to which this link will redirect. Basically the href attribute of the anchor element
         * @param contentInfo Content object that has information about the links text contents
         * @returns A string representing the destination type of the link (internal, external, anchor, social, page)
         */
        static getDestinationType(destination, contentInfo) {
            if (!destination) {
                return ContextInfo.DEFAULT_DESTINATION_TYPE;
            }
            // Anchor is quick and easy to discern
            let destinationType = this.getIsAnchor(destination);
            if (destinationType) {
                return destinationType;
            }
            const allText = contentInfo.allText.toLowerCase();
            /**
             * Link can be either:
             * - An external link, and then maybe also social media link
             * - An internal link, and then maybe one of the common pages
             */
            const externalDestinationType = this.getIsExternal(destination);
            if (externalDestinationType) {
                destinationType = this.getSocialType(destination, allText) ?? externalDestinationType;
            }
            else {
                destinationType = this.getPageType(destination, allText) ?? this.getIsInternal(destination);
            }
            return destinationType ?? ContextInfo.DEFAULT_DESTINATION_TYPE;
        }
        /**
         * Checking if the provided text has a textual context.
         *
         * This is done by first clearing out spaces, numbers and symbols from the text, and then checking for the length of the remainder.
         * If the text is too short, it is considered to not have a textual context.
         *
         * @param text The text for which to check for textual context
         * @returns boolean indicating whether the text has a textual context
         */
        static hasContextualText(text) {
            text = text
                .replaceAll(" ", "")
                .replace(/\d+/g, "")
                .replace(/[\W_]+/g, "")
                .trim();
            // False - If the clean text of link is too short (i.e. "Go")
            const isTooShort = !text || text.length < 3;
            return !isTooShort;
        }
        /**
         * Checking if the element is ambiguous.
         * Will return false for element without any text - as it has to be discernible before it can be ambiguous.
         *
         * @param contentInfo Content object that has information about the links text contents
         * @returns Whether the link is ambiguous or not based on the textual contents
         */
        static getIsLinkAmbiguous(contentInfo) {
            return isTextAmbiguous(contentInfo.srVisibleText);
        }
        /**
         * Checking whether the destination of the link is to some external website
         *
         * @param destination The link to which this link will redirect. Basically the href attribute of the anchor element
         * @returns a string indicating this link is an external link, null otherwise
         */
        static getIsExternal(destination) {
            // eslint-disable-next-line security/detect-non-literal-regexp
            const regExp = new RegExp("//" + location.host + "($|/)");
            const isExternal = destination.substring(0, 4) === "http" && !regExp.test(destination);
            if (isExternal) {
                return "external";
            }
            return null;
        }
        /**
         * Checking whether the destination of the link is to some internal page
         *
         * @param destination The link to which this link will redirect. Basically the href attribute of the anchor element
         * @returns a string indicating this link is an internal link, without specifics, null otherwise
         */
        static getIsInternal(destination) {
            if (destination.startsWith("/")) {
                return "internal";
            }
            return null;
        }
        /**
         * Checking whether the destination of the link is to an anchor in the current page
         *
         * @param destination The link to which this link will redirect. Basically the href attribute of the anchor element
         * @returns a string indicating this link is an anchor link, null otherwise
         */
        static getIsAnchor(destination) {
            if (destination.startsWith("#")) {
                return "anchor";
            }
            return null;
        }
        /**
         * Checking whether the destination of the link is to an external page that is a social media site
         *
         * @param destination The link to which this link will redirect. Basically the href attribute of the anchor element
         * @param textContent All the text content associated with the link
         * @returns a string indicating this link is a link to an external social media site, and what social media site - social.{type}, null otherwise
         */
        static getSocialType(destination, textContent) {
            for (const link in SOCIAL_DOMAIN_TO_NAME_MAP) {
                if (destination.includes(link) || textContent.includes(link)) {
                    const linkType = SOCIAL_DOMAIN_TO_NAME_MAP[link];
                    return `social.${linkType}`;
                }
            }
            return null;
        }
        /**
         * Checking whether the destination of the link is to an internal page that is defined in our constants. Like a login page
         *
         * @param destination The link to which this link will redirect. Basically the href attribute of the anchor element
         * @param textContent All the text content associated with the link
         * @returns a string indicating this link is a link to an internal page, and what page - page.{type}, null otherwise
         */
        static getPageType(destination, textContent) {
            for (const page in PAGES_TYPE_TO_ALIASES_MAP) {
                const pageAliases = PAGES_TYPE_TO_ALIASES_MAP[page];
                for (const alias of pageAliases) {
                    if (destination.includes(alias) || destination.includes(page) || textContent.includes(alias) || textContent.includes(page)) {
                        return `page.${page}`;
                    }
                }
            }
            return null;
        }
    }

    /*
     * Calculate the layout information of an element
     * It will return the width, height, padding, margin of the element
     * as well as top and left  relative to each, viewport, and document
     */
    class LayoutInfo extends Operation {
        element;
        classifier;
        static dependencies = [];
        get width() {
            return LayoutInfo.roundUpToNearestTenth(this.boundingClientRect.width);
        }
        get renderedWidth() {
            return this.boundingClientRect.width;
        }
        get scrollWidth() {
            return this.element.scrollWidth;
        }
        get height() {
            return LayoutInfo.roundUpToNearestTenth(this.boundingClientRect.height);
        }
        get renderedHeight() {
            return this.boundingClientRect.height;
        }
        get scrollHeight() {
            return this.element.scrollHeight;
        }
        get top() {
            return this.boundingClientRect.top;
        }
        get bottom() {
            return this.boundingClientRect.bottom;
        }
        get left() {
            return this.boundingClientRect.left;
        }
        get topViewport() {
            return this.boundingClientRect.top + window.scrollY;
        }
        get leftViewport() {
            return this.boundingClientRect.left + window.scrollX;
        }
        // Get the position property of the element: https://developer.mozilla.org/en-US/docs/Web/CSS/position
        get position() {
            return this.computedStyle.position;
        }
        // Get the overflow property of the element: https://developer.mozilla.org/en-US/docs/Web/CSS/overflow
        get overflow() {
            return this.computedStyle.overflow;
        }
        // Get the overflow-x property of the element: https://developer.mozilla.org/en-US/docs/Web/CSS/overflow-x
        get overflowX() {
            return this.computedStyle.overflowX;
        }
        // Get the overflow-y property of the element: https://developer.mozilla.org/en-US/docs/Web/CSS/overflow-y
        get overflowY() {
            return this.computedStyle.overflowY;
        }
        /**
         * The rect of the element after it has been transformed.
         * If the element has no transform, it will return null.
         *
         * NOTE: this is not the same thing as the boundingClientRect or absoluteRect —
         * those represent the element's position in the viewport without accounting for CSS transforms.
         * This returns the rectangle *after* applying the CSS `transform` matrix to the element.
         *
         * @returns {{
         *   x1: number, y1: number,
         *   x2: number, y2: number,
         *   x3: number, y3: number,
         *   x4: number, y4: number
         * } | null}
         */
        get transformedRect() {
            const transform = this.computedStyle.transform;
            // If there's no matrix transform, exit early
            if (!transform.startsWith("matrix("))
                return null;
            // Extract the numeric matrix components from the transform string
            const matrixMatch = transform.match(/matrix\(([^)]+)\)/);
            const matrixValues = matrixMatch[1].split(",").map((v) => parseFloat(v.trim()));
            // Destructure the matrix components: a, b, c, d, e, f
            const [a, b, c, d, e, f] = matrixValues;
            // Cache commonly reused coordinates from the original rect
            const { x, y, right, bottom } = this.absoluteRect;
            // Apply the 2D transform matrix to each of the 4 corners of the rect
            return {
                x1: x * a + y * c + e,
                y1: x * b + y * d + f,
                x2: x * a + bottom * c + e,
                y2: x * b + bottom * d + f,
                x3: right * a + y * c + e,
                y3: right * b + y * d + f,
                x4: right * a + bottom * c + e,
                y4: right * b + bottom * d + f,
            };
        }
        /**
         * The closest non-static positioned parent of the element.
         * If the element has no parent, or if the element is the body element, it will return null.
         *
         * @returns {HTMLElement | null} - The closest non-static positioned parent of the element.
         */
        get getClosestNonStaticPositionedParent() {
            const parentLayoutInfo = this.parentLayoutInfo;
            if (!parentLayoutInfo)
                return null;
            if (parentLayoutInfo.position !== "static")
                return parentLayoutInfo.element;
            return parentLayoutInfo.getClosestNonStaticPositionedParent;
        }
        /**
         * Browsers typically render the <body> as at least as large as the viewport, regardless of it's width and height.
         * Unless the html element has overflow that is not visible, the body element will not have overflow when it's content is inside the viewport.
         * @see file://./../../perceivable/traits/visible/atomic-tests/pass/visible-div-overflows-from-body.html
         * @see file://./../../perceivable/traits/visible/atomic-tests/fail/hidden-div-overflows-from-body.html
         * @see https://www.w3.org/TR/CSS22/visufx.html#propdef-overflow
         * @see https://stackoverflow.com/questions/41506456/why-body-overflow-not-working#answer-41507857
         */
        isBodyOverflowSpecialCase() {
            return [this.element.parentElement.tagName, this.element.tagName].includes("BODY") && !["hidden", "scroll", "auto", "overlay"].includes(this.classifier.getOperations(document.documentElement).layoutInfo.overflow);
        }
        /**
         * if the z-index is auto or the position is static, it will return undefined, otherwise it will return the z-index value as a number
         * `position: static` and `z-index: auto` are not creating a stacking context, so the z-index value is not relevant
         */
        get zIndex() {
            const style = this.computedStyle;
            const z = style.zIndex;
            return z === "auto" || style.position === "static" ? undefined : parseInt(z);
        }
        get padding() {
            const style = this.computedStyle;
            return {
                top: parseFloat(style.paddingTop),
                right: parseFloat(style.paddingRight),
                bottom: parseFloat(style.paddingBottom),
                left: parseFloat(style.paddingLeft),
            };
        }
        get margin() {
            const style = this.computedStyle;
            return {
                top: parseFloat(style.marginTop),
                right: parseFloat(style.marginRight),
                bottom: parseFloat(style.marginBottom),
                left: parseFloat(style.marginLeft),
            };
        }
        get rect() {
            return this.boundingClientRect;
        }
        get absoluteRect() {
            return this.absoluteBoundingClientRect;
        }
        /**
         * If the element is within the visible area of the document, it will return true, otherwise it will return false
         *
         * @returns {boolean} - Whether the element is within the visible area of the document.
         */
        get isOutsideDocumentVisibleRect() {
            const bodyLayoutInfo = this.classifier.getOperations(document.body).layoutInfo;
            if (!isOverflowVisible(bodyLayoutInfo.overflowX) && this.isOutsideDocumentRightAndViewport)
                return true;
            if (!isOverflowVisible(bodyLayoutInfo.overflowY) && this.isOutsideDocumentBottomAndViewport)
                return true;
            if (this.isOutsideDocumentTopAndViewport || this.isOutsideDocumentLeftAndViewport)
                return true;
            return false;
        }
        /**
         * If the element is completely overflowing from the document, it will return true, otherwise it will return false
         * If the element is completely overflowing from the document from the bottom, top, right, or left, it will return true
         *
         * @returns {boolean} - Whether the element is outside both the document and the viewport.
         */
        get isOutsideDocumentAndViewport() {
            return this.isOutsideDocumentBottomAndViewport || this.isOutsideDocumentTopAndViewport || this.isOutsideDocumentRightAndViewport || this.isOutsideDocumentLeftAndViewport;
        }
        /**
         * If the element is completely overflowing from the bottom of the document, it will return true, otherwise it will return false
         *
         * @returns {boolean} - Whether the element is outside the document from the bottom and viewport.
         */
        get isOutsideDocumentBottomAndViewport() {
            return this.absoluteRect.top - VisibilityInfo.MIN_ELEMENT_VISIBLE_SIZE >= this.classifier.getOperations(document.documentElement).layoutInfo.absoluteRect.bottom;
        }
        /**
         * If the element is completely overflowing from the top of the document, it will return true, otherwise it will return false
         *
         * @returns {boolean} - Whether the element is outside the document from the top and viewport.
         */
        get isOutsideDocumentTopAndViewport() {
            return this.absoluteRect.bottom - VisibilityInfo.MIN_ELEMENT_VISIBLE_SIZE <= this.classifier.getOperations(document.documentElement).layoutInfo.absoluteRect.top;
        }
        /**
         * If the element is completely overflowing from the right of the document, it will return true, otherwise it will return false
         *
         * @returns {boolean} - Whether the element is outside the document from the right and viewport.
         */
        get isOutsideDocumentRightAndViewport() {
            return this.absoluteRect.left - VisibilityInfo.MIN_ELEMENT_VISIBLE_SIZE >= this.classifier.getOperations(document.documentElement).layoutInfo.absoluteRect.right;
        }
        /**
         * If the element is completely overflowing from the left of the document, it will return true, otherwise it will return false
         *
         * @returns {boolean} - Whether the element is outside the document from the left and viewport.
         */
        get isOutsideDocumentLeftAndViewport() {
            return this.absoluteRect.right - VisibilityInfo.MIN_ELEMENT_VISIBLE_SIZE <= this.classifier.getOperations(document.documentElement).layoutInfo.absoluteRect.left;
        }
        /**
         * The rect of the text nodes inside the element.
         * If the element has no text nodes, it will return null.
         *
         * @returns {DOMRect | null} - The rect of the text nodes inside the element.
         */
        get textRect() {
            const nodeRects = new NodeRects(this.element);
            return nodeRects.nodeContentsBoundingClientRect;
        }
        /**
         * If the text inside the element is completely overflowing from the right or left, it will return true, otherwise it will return false
         *
         * @returns {boolean} - Whether the text inside the element is completely overflowing from the right or left.
         */
        get hasTextOutsideXAxis() {
            const textRect = this.textRect;
            if (!textRect)
                return false;
            const { right, left } = this.absoluteRect;
            return logicalXOR(textRect.left >= right, textRect.right <= left);
        }
        /**
         * If the text inside the element is completely overflowing from the top or bottom, it will return true, otherwise it will return false
         *
         * @returns {boolean} - Whether the text inside the element is completely overflowing from the top or bottom.
         */
        get hasTextOutsideYAxis() {
            const textRect = this.textRect;
            if (!textRect)
                return false;
            const { top, bottom } = this.absoluteRect;
            return logicalXOR(textRect.bottom <= top, textRect.top >= bottom);
        }
        /**
         * If the text inside the element is completely overflowing from the document's right or left, it will return true, otherwise it will return false
         *
         * @returns {boolean} - Whether the text inside the element is completely overflowing from the document's right or left.
         */
        get hasTextOutsideDocumentX() {
            const textRect = this.textRect;
            if (!textRect)
                return false;
            const { left, right } = this.classifier.getOperations(document.documentElement).layoutInfo.absoluteRect;
            return logicalXOR(textRect.left >= right, textRect.right <= left);
        }
        /**
         * If the text inside the element is completely overflowing from the document's top or bottom, it will return true, otherwise it will return false
         *
         * @returns {boolean} - Whether the text inside the element is completely overflowing from the document's top or bottom.
         */
        get hasTextOutsideDocumentY() {
            const textRect = this.textRect;
            if (!textRect)
                return false;
            const { bottom, top } = this.classifier.getOperations(document.documentElement).layoutInfo.absoluteRect;
            return logicalXOR(textRect.bottom <= top, textRect.top >= bottom);
        }
        /**
         * If the text inside the element is completely overflowing from the document's top, it will return true, otherwise it will return false
         *
         * @returns {boolean} - Whether the text inside the element is completely overflowing from the document's top.
         */
        get hasTextOutsideDocumentTop() {
            const textRect = this.textRect;
            if (!textRect)
                return false;
            const { top } = this.classifier.getOperations(document.documentElement).layoutInfo.absoluteRect;
            return textRect.bottom <= top;
        }
        /**
         * If the text inside the element is completely overflowing from the document's left, it will return true, otherwise it will return false
         *
         * @returns {boolean} - Whether the text inside the element is completely overflowing from the document's left.
         */
        get hasTextOutsideDocumentLeft() {
            const textRect = this.textRect;
            if (!textRect)
                return false;
            const { left } = this.classifier.getOperations(document.documentElement).layoutInfo.absoluteRect;
            return textRect.right <= left;
        }
        /**
         * The layout information of the parent element.
         * If the element has no parent, it will return null.
         *
         * @returns {ILayoutInfo | null} - The layout information of the parent element.
         */
        get parentLayoutInfo() {
            if (!this.element.parentElement)
                return null;
            return this.classifier.getOperations(this.element.parentElement).layoutInfo;
        }
        /**
         * The maximum visible left of the ancestors of the element.
         * This function is useful if you want to know the left most visible point in the element's hierarchy, anything to the left of this point is not visible.
         *
         * @returns {number} - The minimum visible left of the ancestors of the element.
         */
        get ancestorsMinVisibleLeft() {
            // Exit condition #1: Fixed position is not affected by any parent, not even fixed positioned parent
            const position = this.position;
            const left = this.absoluteRect.left;
            if (position === "fixed")
                return left;
            // If the element is position: absolute or sticky, it's affected by any non-static positioned parent; otherwise it's affected by any parent
            let nextParent = ["absolute", "sticky"].includes(position) ? this.getClosestNonStaticPositionedParent : this.element.parentElement;
            // Exit condition #2: If the element has no parent, we've reached the top of the hierarchy so we return this element's absolute left
            if (!nextParent)
                return left;
            nextParent = this.classifier.getOperations(nextParent).layoutInfo;
            // Exit condition #3: If the element is the body element, or it's parent is the body elementm we need to consider the body's overflow special case
            if (this.isBodyOverflowSpecialCase()) {
                return Math.min(this.classifier.getOperations(document.documentElement).layoutInfo.absoluteRect.left, left, this.parentLayoutInfo.absoluteRect.left);
            }
            // Exit condition #4: If the parent's overflow-x is not visible, we return the parent's absolute left
            if (!isOverflowVisible(nextParent.overflowX))
                return nextParent.absoluteRect.left;
            // Recursively call the function to get the maximum visible left of the ancestors
            return Math.min(left, nextParent.ancestorsMinVisibleLeft);
        }
        /**
         * The maximum visible top of the ancestors of the element.
         * This function is useful if you want to know the top most visible point of in the element's hierarchy, anything above this point is not visible.
         *
         * @returns {number} - The maximum visible top of the ancestors of the element.
         */
        get ancestorsMinVisibleTop() {
            // Exit condition #1: Fixed position is not affected by any parent, not even fixed positioned parent
            const position = this.position;
            const top = this.absoluteRect.top;
            if (position === "fixed")
                return top;
            // If the element is position: absolute or sticky, it's affected by any non-static positioned parent; otherwise it's affected by any parent
            let nextParent = ["absolute", "sticky"].includes(position) ? this.getClosestNonStaticPositionedParent : this.element.parentElement;
            // Exit condition #2: If the element has no parent, we've reached the top of the hierarchy, so we return this element's absolute top
            if (!nextParent)
                return top;
            nextParent = this.classifier.getOperations(nextParent).layoutInfo;
            // Exit condition #3: If the element is the body element, or its parent is the body element, we need to consider the body's overflow special case
            if (this.isBodyOverflowSpecialCase()) {
                return Math.min(this.classifier.getOperations(document.documentElement).layoutInfo.absoluteRect.top, top, this.parentLayoutInfo.absoluteRect.top);
            }
            // Exit condition #4: If the parent's overflow-y is not visible, we return the parent's absolute top
            if (!isOverflowVisible(nextParent.overflowY)) {
                return nextParent.absoluteRect.top;
            }
            // Recursively call the function to get the maximum visible top of the ancestors
            return Math.min(top, nextParent.ancestorsMinVisibleTop);
        }
        /**
         * The maximum visible right of the ancestors of the element.
         * This function is useful if you want to know the right most visible point in the element's hierarchy, anything to the right of this point is not visible.
         *
         * @returns {number} - The maximum visible right of the ancestors of the element.
         */
        get ancestorsMaxVisibleRight() {
            // Exit condition #1: Fixed position is not affected by any parent, not even fixed positioned parent
            const position = this.position;
            const right = this.absoluteRect.right;
            if (position === "fixed")
                return right;
            // If the element is position: absolute or sticky, its affected by any non-static positioned parent; otherwise it's affected by any parent
            let nextParent = ["absolute", "sticky"].includes(position) ? this.getClosestNonStaticPositionedParent : this.element.parentElement;
            // Exit condition #2: If the element has no parent, we've reached the top of the hierarchy so we return this element's absolute right
            if (!nextParent)
                return right;
            nextParent = this.classifier.getOperations(nextParent).layoutInfo;
            // Exit condition #3: If the element is the body element, or its parent is the body element, we need to consider the body's overflow special case
            if (this.isBodyOverflowSpecialCase())
                return Math.max(this.classifier.getOperations(document.documentElement).layoutInfo.absoluteRect.right, right, this.parentLayoutInfo.absoluteRect.right);
            // Exit condition #4: If the parent's overflow-x is not visible, we return the parent's absolute right
            if (!isOverflowVisible(nextParent.overflowX))
                return nextParent.absoluteRect.right;
            // Recursively call the function to get the maximum visible right of the ancestors
            return Math.max(right, nextParent.ancestorsMaxVisibleRight);
        }
        /**
         * The maximum visible bottom of the ancestors of the element.
         * This function is useful if you want to know the bottom most visible point in the element's hierarchy, anything below this point is not visible.
         *
         * @returns {number} - The maximum visible bottom of the ancestors of the element.
         */
        get ancestorsMaxVisibleBottom() {
            // Exit condition #1: Fixed position is not affected by any parent, not even fixed positioned parent
            const position = this.position;
            const bottom = this.absoluteRect.bottom;
            if (position === "fixed")
                return bottom;
            // If the element is position: absolute or sticky, its affected by any non-static positioned parent; otherwise it's affected by any parent
            let nextParent = ["absolute", "sticky"].includes(position) ? this.getClosestNonStaticPositionedParent : this.element.parentElement;
            // Exit condition #2: If the element has no parent, we've reached the top of the hierarchy so we return this element's absolute bottom
            if (!nextParent)
                return bottom;
            nextParent = this.classifier.getOperations(nextParent).layoutInfo;
            // Exit condition #3: If the element is the body element, or its parent is the body element, we need to consider the body's overflow special case
            if (this.isBodyOverflowSpecialCase())
                return Math.max(this.classifier.getOperations(document.documentElement).layoutInfo.absoluteRect.bottom, bottom, this.parentLayoutInfo.absoluteRect.bottom);
            // Exit condition #4: If the parent's overflow-y is not visible, we return the parent's absolute bottom
            if (!isOverflowVisible(nextParent.overflowY))
                return nextParent.absoluteRect.bottom;
            // Recursively call the function to get the maximum visible bottom of the ancestors
            return Math.max(bottom, nextParent.ancestorsMaxVisibleBottom);
        }
        /**
         * Determines whether the element is outside of its ancestors' visible area on the Y axis.
         * If the element is completely outside of the top or bottom of its ancestors' visible area, it is considered outside.
         * If the element is partially outside of the top or bottom of its ancestors' visible area, it is considered inside.
         *
         * @returns {boolean} - Whether the element is outside of its ancestors' visible area on the Y axis.
         */
        get isOutsideAncestorsVisibleY() {
            const { bottom, top } = this.absoluteRect;
            return logicalXOR(bottom - VisibilityInfo.MIN_ELEMENT_VISIBLE_SIZE <= this.ancestorsMinVisibleTop, top + VisibilityInfo.MIN_ELEMENT_VISIBLE_SIZE >= this.ancestorsMaxVisibleBottom);
        }
        /**
         * Determines whether the element is outside its ancestors' visible area on the X axis.
         * If the element is completely outside the left or right of its ancestors' visible area, it is considered outside.
         * If the element is partially outside the left or right of its ancestors' visible area, it is considered inside.
         *
         * @returns {boolean} - Whether the element is outside its ancestors' visible area on the X axis.
         */
        get isOutsideAncestorsVisibleX() {
            const { right, left } = this.absoluteRect;
            return logicalXOR(right - VisibilityInfo.MIN_ELEMENT_VISIBLE_SIZE <= this.ancestorsMinVisibleLeft, left + VisibilityInfo.MIN_ELEMENT_VISIBLE_SIZE >= this.ancestorsMaxVisibleRight);
        }
        /**
         * Determines whether the element is outside its ancestors' visible area.
         * If the element is completely outside the top, bottom, left, or right of its ancestors' visible area, it is considered outside.
         *
         * @returns {boolean} - Whether the element is outside its ancestors' visible area.
         */
        get isOutsideAncestorsVisibleRect() {
            return this.isOutsideAncestorsVisibleX || this.isOutsideAncestorsVisibleY;
        }
        get aspectRatio() {
            const { width, height } = this.boundingClientRect;
            return width / height;
        }
        get hasVisibleBorder() {
            return LayoutInfo.hasVisibleBorder(this.computedStyle);
        }
        get firstScrollableParent() {
            let currentElement = this.element;
            while (currentElement && currentElement !== document.body) {
                const overflowY = this.classifier.getOperations(currentElement).resources.computedStyle.overflowY;
                const isScrollable = overflowY === "auto" || overflowY === "scroll";
                if (isScrollable && currentElement.scrollHeight > currentElement.clientHeight) {
                    return currentElement;
                }
                currentElement = currentElement.parentElement;
            }
            return document.documentElement;
        }
        get scrollPaddingBottom() {
            return LayoutInfo.calculateScrollPadding(this.computedStyle.scrollPaddingBottom, this.element);
        }
        get scrollPaddingTop() {
            return LayoutInfo.calculateScrollPadding(this.computedStyle.scrollPaddingTop, this.element);
        }
        /**
         * The top position of the element relative to the nearest positioned ancestor
         * if the element is HTMLElement, it will return the offsetTop
         * if the element is not HTMLElement, it will return the offset of the element from its nearest positioned ancestor (the subtraction)
         * if there is no positioned ancestor, it will return the top of the boundingClientRect
         *
         * related tests:
         * - src/operations/layout-info/e2e/nested-span-inside-positioned-div.html
         * - src/operations/layout-info/e2e/nested-svg-inside-positioned-div.html
         */
        get topRelative() {
            if (isInstanceOf(this.element, HTMLElement)) {
                return this.element.offsetTop;
            }
            const positionedAncestor = this.getClosestNonStaticPositionedParent;
            if (positionedAncestor) {
                const { layoutInfo: { top: positionedAncestorTop }, } = this.classifier.getOperations(positionedAncestor);
                return this.top - positionedAncestorTop;
            }
            return this.boundingClientRect.top;
        }
        /**
         * The left position of the element relative to the nearest positioned ancestor
         * if the element is HTMLElement, it will return the offsetLeft
         * if the element is not HTMLElement, it will return the offset of the element from it's nearest positioned ancestor (the subtraction)
         * if there is no positioned ancestor, it will return the left of the boundingClientRect
         *
         * related tests:
         * - src/operations/layout-info/e2e/nested-span-inside-positioned-div.html
         * - src/operations/layout-info/e2e/nested-svg-inside-positioned-div.html
         */
        get leftRelative() {
            if (isInstanceOf(this.element, HTMLElement)) {
                return this.element.offsetLeft;
            }
            const positionedAncestor = this.getClosestNonStaticPositionedParent;
            if (positionedAncestor) {
                const { layoutInfo: { left: positionedAncestorLeft }, } = this.classifier.getOperations(positionedAncestor);
                return this.left - positionedAncestorLeft;
            }
            return this.boundingClientRect.left;
        }
        /**
         * Calculates the scroll padding value based on the given padding value.
         * @param {string} paddingValue - The padding value to calculate.
         * @param {HTMLElement} element - The element to use for percentage calculations.
         * @returns {number} - The calculated scroll padding value in pixels.
         */
        static calculateScrollPadding(paddingValue, element) {
            if (paddingValue === "auto") {
                return 0;
            }
            if (paddingValue.endsWith("px")) {
                return parseFloat(paddingValue);
            }
            if (paddingValue.endsWith("%")) {
                const parentElement = element.parentElement;
                if (parentElement) {
                    return (parseFloat(paddingValue) / 100) * element.clientHeight;
                }
            }
            return 0;
        }
        /**
         * Rounds a number up to the nearest tenth.
         *
         * This function ensures that any value is rounded up to the nearest tenth (one decimal place).
         * It uses Math.ceil to round up, ensuring that values like 56.45001220703125 and 56.44999694824219
         * both round to 56.5.
         *
         * @param {number} value - The number to be rounded.
         * @returns {number} - The rounded number, up to the nearest tenth.
         */
        static roundUpToNearestTenth(value) {
            return Math.ceil(value * 10) / 10;
        }
        /**
         * the computedStyle of the element as exposed by the `resources` param
         */
        computedStyle;
        /**
         * the boundingClientRect of the element as exposed by the `resources` param
         */
        boundingClientRect;
        /**
         * the absolute rect of the element, the x, y, top, left are absolute in every scroll position
         */
        absoluteBoundingClientRect;
        constructor(element, { computedStyle, boundingClientRect, absoluteBoundingClientRect }, classifier) {
            super();
            this.element = element;
            this.classifier = classifier;
            this.computedStyle = computedStyle;
            this.boundingClientRect = boundingClientRect;
            this.absoluteBoundingClientRect = absoluteBoundingClientRect;
        }
        /**
         * Runs on the computed style of an element to determine if it has at least one side with a visible border.
         * @param style
         */
        static hasVisibleBorder(style) {
            const sides = ["top", "right", "bottom", "left"];
            for (const side of sides) {
                const width = parseFloat(style[`border-${side}-width`]);
                const styleValue = style[`border-${side}-style`];
                const color = style[`border-${side}-color`];
                if (width > 0 && !["none", "hidden"].includes(styleValue) && !isTransparent(color)) {
                    return true;
                }
            }
            return false;
        }
    }

    /**
     * Predefined style properties to check for focus style.
     * These are the most common style properties that are changed when an element is focused.
     */
    const FOCUS_STYLE_PROPERTIES = ["outline", "background-color", "color", "border", "box-shadow"];
    /**
     * Returns style information about the provided element
     *
     * Important: this function might cause a loss of the current active element.
     * You should cache the active element and the scroll position before calling this function.
     * Pass the cached active element and scroll position to the cleanup function to restore the state.
     */
    class StateStyleInfo extends Operation {
        element;
        classifier;
        /**
         * @inheritdoc
         */
        static dependencies = [];
        /**
         * Returns whether the provided element has focus style or not
         *
         * @param element The element to get for focus style
         * @returns Whether the element has focus style or not
         */
        static getElementHasFocusStyle(element) {
            // Making sure the element is not focused
            element.blur();
            // Getting the predefined computed style properties of the element
            const style = getComputedStyle(element);
            const preFocusStyle = {};
            for (const prop of FOCUS_STYLE_PROPERTIES) {
                preFocusStyle[prop] = style.getPropertyValue(prop);
            }
            // Focusing the element to get the computed style properties after focus
            element.focus();
            const focusStyle = {};
            const postFocusStyle = getComputedStyle(element);
            // Checking for differences in the computed style properties before and after focus
            for (const prop of FOCUS_STYLE_PROPERTIES) {
                const preFocusPropValue = preFocusStyle[prop];
                const postFocusPropValue = postFocusStyle.getPropertyValue(prop);
                if (preFocusPropValue !== postFocusPropValue) {
                    focusStyle[prop] = postFocusPropValue;
                    break;
                }
            }
            // Clearing the focus
            element.blur();
            return focusStyle;
        }
        /**
         * Cleanup function to reset operations side effects
         * StateStyleInfo might cause a loss of the current active element.
         * If there was a cached active element, we should restore as active by refocusing it.
         *
         * It there was no active element, we should scroll to the top of the page, as focusing elements might affect the scroll position.
         *
         * @param cachedActiveElement The element that was focused before the operation
         * @param cachedWindowScroll The scroll position of the window before the operation
         *
         * TODO: this should be a static method, and accessing it from the auditor should be done through the class (or changed entirely).
         */
        cleanup(cachedActiveElement, cachedWindowScroll) {
            /**
             * StateStyleInfo might cause a loss of the current active element.
             * If there was an active element, we should restore as active by refocusing it.
             * It there was no active element, we should scroll to the top of the page, as focusing elements might affect the scroll position.
             */
            if (cachedActiveElement) {
                cachedActiveElement.focus();
            }
            else if (cachedWindowScroll && cachedWindowScroll.length === 2) {
                const [x, y] = cachedWindowScroll;
                window.scrollTo(x, y);
            }
        }
        /**
         * The focus style of the provided element, if any.
         * If the element has no focus style, the object will be empty.
         * Otherwise it will either of the keys from {FOCUS_STYLE_PROPERTIES}.
         */
        get focusStyle() {
            return StateStyleInfo.getElementHasFocusStyle(this.element);
        }
        constructor(element, resources, classifier) {
            super();
            this.element = element;
            this.classifier = classifier;
        }
    }

    /**
     * Calculate the typography information of an element
     * It will return the font family, font size, font weight, font style, color, text alignment, letter spacing, word spacing, and line height of the element
     */
    class TypographyInfo extends Operation {
        element;
        resources;
        classifier;
        /**
         * @inheritdoc
         */
        static dependencies = [];
        /**
         * The font family of the element (e.g. Arial, Helvetica, sans-serif)
         * @reference https://developer.mozilla.org/en-US/docs/Web/CSS/font-family
         */
        get fontFamily() {
            return this.resources.computedStyle.fontFamily;
        }
        /**
         * The word spacing of the element in pixels, default is 0px
         * @default "normal"
         * @reference https://developer.mozilla.org/en-US/docs/Web/CSS/word-spacing
         */
        get wordSpacing() {
            return this.resources.computedStyle.wordSpacing === "normal" ? 0 : parseFloat(this.resources.computedStyle.wordSpacing);
        }
        /**
         * The font size of the element in pixels
         * @reference https://developer.mozilla.org/en-US/docs/Web/CSS/font-size
         */
        get fontSize() {
            return parseFloat(this.resources.computedStyle.fontSize);
        }
        /**
         * The font weight of the element (100, 200, 300, 400, 500, 600, 700, 800, 900)
         * @reference https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight
         */
        get fontWeight() {
            return parseFloat(this.resources.computedStyle.fontWeight);
        }
        /**
         * The font style of the element (normal, italic, oblique, oblique <angle>)
         * @reference https://developer.mozilla.org/en-US/docs/Web/CSS/font-style
         */
        get fontStyle() {
            return this.resources.computedStyle.fontStyle;
        }
        get textAlign() {
            return this.resources.computedStyle.textAlign;
        }
        /**
         * The color of the element in rgb or rgba format
         * @reference https://developer.mozilla.org/en-US/docs/Web/CSS/color_value
         */
        get color() {
            return this.resources.computedStyle.color;
        }
        /**
         * The line height of the element in pixels, default is 120% of the font size
         * @reference https://developer.mozilla.org/en-US/docs/Web/CSS/line-height
         */
        get lineHeight() {
            return this.resources.computedStyle.lineHeight === "normal" ? parseFloat(this.resources.computedStyle.fontSize) * 1.2 : parseFloat(this.resources.computedStyle.lineHeight);
        }
        /**
         * The letter spacing of the element in pixels, default is 0px
         * @reference https://developer.mozilla.org/en-US/docs/Web/CSS/letter-spacing
         */
        get letterSpacing() {
            return this.resources.computedStyle.letterSpacing === "normal" ? 0 : parseFloat(this.resources.computedStyle.letterSpacing);
        }
        /**
         * The text decoration of the element, default is 'none solid rgb(R, G, B)
         * @reference https://developer.mozilla.org/en-US/docs/Web/CSS/text-decoration
         */
        get textDecoration() {
            const textDecorationLine = this.resources.computedStyle.textDecorationLine;
            const textDecorationThickness = this.resources.computedStyle.textDecorationThickness;
            const textDecorationStyle = this.resources.computedStyle.textDecorationStyle;
            const textDecorationColor = this.resources.computedStyle.textDecorationColor;
            const textDecorationString = `${textDecorationLine} ${textDecorationThickness} ${textDecorationStyle} ${textDecorationColor}`;
            const textDecorationThicknessNumber = parseFloat(this.resources.computedStyle.textDecorationThickness.split("px")[0]);
            /**  Unsupported textDecoration properties
             * const textDecorationSkipInk = computedStyle.textDecorationSkipInk;
             * const webkitTextDecorationsInEffect = computedStyle.webkitTextDecorationsInEffect;
             **/
            return {
                textDecorationString,
                line: textDecorationLine,
                thickness: textDecorationThicknessNumber,
                style: textDecorationStyle,
                color: textDecorationColor,
            };
        }
        /**
         * The text indent of the element in pixels, default is 0px
         * @reference https://developer.mozilla.org/en-US/docs/Web/CSS/text-indent
         */
        get textIndent() {
            return parseFloat(this.resources.computedStyle.textIndent) || 0;
        }
        /**
         * The typography info of the pseudo-element ::before
         * @reference https://developer.mozilla.org/en-US/docs/Web/CSS/::before
         */
        get pseudoBefore() {
            const self = this;
            return {
                /**
                 * The text color of the pseudo-element ::before
                 */
                get color() {
                    /**
                     * The text color of the pseudo-element ::after
                     */
                    return self.resources.computedPseudoBeforeStyle.color;
                },
            };
        }
        /**
         * The typography info of the pseudo-element ::after
         * @reference https://developer.mozilla.org/en-US/docs/Web/CSS/::after
         */
        get pseudoAfter() {
            const self = this;
            return {
                get color() {
                    return self.resources.computedPseudoAfterStyle.color;
                },
            };
        }
        /**
         *  The text transform of the element (none, capitalize, uppercase, lowercase)
         *  @reference https://developer.mozilla.org/en-US/docs/Web/CSS/text-transform
         * */
        get textTransform() {
            return this.resources.computedStyle.textTransform;
        }
        constructor(element, resources, classifier) {
            super();
            this.element = element;
            this.resources = resources;
            this.classifier = classifier;
        }
    }

    /**
     * Get the information of the element's current window/context
     */
    class WindowInfo extends Operation {
        element;
        /**
         * Width of the viewport - including scrollbar.
         */
        get width() {
            return this.context.innerWidth;
        }
        /**
         * Height of the viewport - including scrollbar.
         */
        get height() {
            return this.context.innerHeight;
        }
        /**
         * Width of the content area - excluding scrollbar.
         */
        get contentWidth() {
            return this.context.document.body.clientWidth;
        }
        /**
         * Height of the content area - excluding scrollbar.
         */
        get contentHeight() {
            return this.context.document.body.clientHeight;
        }
        /**
         * Number of pixels currently scrolled horizontally.
         */
        get scrollX() {
            return this.context.scrollX;
        }
        /**
         * Number of pixels currently scrolled vertically.
         */
        get scrollY() {
            return this.context.scrollY;
        }
        /**
         * The context of the element, which is the window object.
         */
        get context() {
            return getOwnerWindow(this.element);
        }
        /**
         * the iframe element of a current element's context
         */
        get frameElement() {
            return this.context.frameElement;
        }
        /**
         * The domain name of the current page as a sentence
         */
        get domainNameSentence() {
            let hostname = this.context.location.hostname;
            //Clean up the hostname
            hostname = hostname.replace(/^www\./, ""); // Remove 'www.'
            hostname = hostname.replace(/[-_]/, " "); // Replace '-' with ' '
            //Split on '.' and remove the last two segments from the end if they are 3 characters or less
            const segments = hostname.split(".");
            //remove the last segment
            segments.pop();
            if (segments.length > 1) {
                const secondLastSegment = segments[segments.length - 1];
                // If the second last segment is 3 characters or less, remove it
                if (secondLastSegment.length <= 3) {
                    segments.pop();
                }
            }
            // Capitalize the first letter of each segment
            const capitalizedSegments = segments.map((segment) => segment[0].toUpperCase() + segment.slice(1));
            // Join the segments with ' | '
            return capitalizedSegments.join(" | ");
        }
        /**
         * @inheritdoc
         */
        static dependencies = [];
        constructor(element) {
            super();
            this.element = element;
        }
    }

    /**
     * Get the information of the element's shadow dom
     */
    class ShadowDomInfo extends Operation {
        element;
        classifier;
        get shadowRoot() {
            const rootNode = this.element.getRootNode();
            if (isInstanceOf(rootNode, ShadowRoot)) {
                return rootNode;
            }
            return this.element.shadowRoot;
        }
        /**
         * @inheritdoc
         */
        static dependencies = [];
        constructor(element, classifier) {
            super();
            this.element = element;
            this.classifier = classifier;
        }
    }

    var operations = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ColorInfo: ColorInfo,
        ComponentMatch: ComponentMatch,
        ContentInfo: ContentInfo,
        ContextInfo: ContextInfo,
        LayoutInfo: LayoutInfo,
        ShadowDomInfo: ShadowDomInfo,
        StateStyleInfo: StateStyleInfo,
        TypographyInfo: TypographyInfo,
        VisibilityInfo: VisibilityInfo,
        WindowInfo: WindowInfo
    });

    /**
     * provides a set of operations to extract information from an SvgOrHtmlElement in a cached manner
     */
    class OperationService {
        element;
        classifier;
        cache = {};
        // Cache map to store Operations instances per SvgOrHtmlElement
        static globalCache = new WeakMap();
        static removeElementFromCache(element) {
            this.globalCache.delete(element);
        }
        static clearCache() {
            this.globalCache = new WeakMap();
        }
        /**
         * List of dependencies aggregated from all operations and required for them to work, to be used in the EngineClassifier graph initialization
         */
        static dependencies = Object.values(operations).flatMap((item) => item.dependencies);
        resources;
        constructor(element, classifier) {
            this.element = element;
            this.classifier = classifier;
            if (OperationService.globalCache.has(element))
                return OperationService.globalCache.get(element);
            this.resources = {
                get computedStyle() {
                    return window.getComputedStyle(element);
                },
                get boundingClientRect() {
                    return element.getBoundingClientRect();
                },
                get absoluteBoundingClientRect() {
                    const rect = element.getBoundingClientRect();
                    /**
                     * NOTE: this logic is to handle the case where the body/documentElement size is smaller than the viewport size (in chrome it returns 100% of the viewport, but in firefox it returns the body size, which is the biggest element in the page)
                     *
                     * the Math.min against window.innerWidth/Height is to ensure that the right/bottom values do not exceed the viewport size.
                     * related test: @see file://../perceivable/traits/visible/atomic-tests/fail/visible-div-overflows-from-body-x.html
                     */
                    const { innerHeight, innerWidth, scrollY, scrollX } = getOwnerWindow(element);
                    let right = rect.left + scrollX + rect.width; // rect.right === rect.left + rect.width
                    let bottom = rect.top + scrollY + rect.height; // rect.bottom === rect.top + rect.height
                    // Special handling for <body> and <html> elements:
                    // Clamp the right/bottom edges so they don’t exceed the document’s scroll size,
                    // but ensure they are never smaller than the viewport dimensions.
                    if (isInstanceOf(element, HTMLBodyElement) || isInstanceOf(element, HTMLHtmlElement)) {
                        right = Math.max(Math.min(right, element.ownerDocument.body.scrollWidth), innerWidth);
                        bottom = Math.max(Math.min(bottom, element.ownerDocument.body.scrollHeight), innerHeight);
                    }
                    return {
                        x: rect.left + scrollX,
                        y: rect.top + scrollY,
                        left: rect.left + scrollX,
                        top: rect.top + scrollY,
                        right,
                        bottom,
                        width: Math.abs(rect.width),
                        height: Math.abs(rect.height),
                        toJSON: rect.toJSON,
                    };
                },
                get computedPseudoBeforeStyle() {
                    return window.getComputedStyle(element, "::before");
                },
                get computedPseudoAfterStyle() {
                    return window.getComputedStyle(element, "::after");
                },
            };
            this.resources = new Proxy(this.resources, {
                get: (target, prop, receiver) => this.getCached(prop, () => Reflect.get(target, prop, receiver)),
            });
            // Apply Proxy to handle caching for all properties (resources and methods)
            const instance = new Proxy(this, {
                get: (target, prop, receiver) => this.getCached(prop, () => Reflect.get(target, prop, receiver)),
            });
            OperationService.globalCache.set(element, instance);
            return instance;
        }
        getCached(key, compute) {
            if (!(key in this.cache)) {
                this.cache[key] = compute();
            }
            return this.cache[key];
        }
        get colorInfo() {
            return new ColorInfo(this.element, this.resources, this.classifier);
        }
        get contentInfo() {
            return new ContentInfo(this.element, this.resources, this.classifier);
        }
        get contextInfo() {
            return new ContextInfo(this.element, this.resources, this.classifier);
        }
        get componentMatch() {
            return new ComponentMatch(this.element, this.resources, this.classifier);
        }
        get typographyInfo() {
            return new TypographyInfo(this.element, this.resources, this.classifier);
        }
        get layoutInfo() {
            return new LayoutInfo(this.element, this.resources, this.classifier);
        }
        get stateStyleInfo() {
            return new StateStyleInfo(this.element, this.resources, this.classifier);
        }
        get visibilityInfo() {
            return new VisibilityInfo(this.element, this.resources, this.classifier);
        }
        get windowInfo() {
            return new WindowInfo(this.element);
        }
        get shadowDomInfo() {
            return new ShadowDomInfo(this.element, this.classifier);
        }
    }

    /**
     * @class
     * @classdesc A basic, strictly-typed Event emitter  (both event types and their payload)
     * allows to add, remove and emit events
     */
    class EventEmitter {
        /** a html `HTMLSpanElement` Used as event bus for handling events in the class **/
        eventBus = document.createElement("span");
        listeners = new Map();
        /** Triggers/Emits a custom event with given `type` on the `eventBus` element */
        emit(event, ...args) {
            this.eventBus.dispatchEvent(new CustomEvent(event.toString(), { detail: args }));
        }
        /** Removes an event listener for given `type` from the `eventBus` element **/
        off(event, listener, options) {
            const storedListener = this.listeners.get(listener);
            this.eventBus.removeEventListener(event.toString(), storedListener, options);
        }
        /** Adds an event listener for given `type` from the `eventBus` element **/
        on(event, listener, options) {
            const boundedListener = (event) => listener(...event.detail);
            this.listeners.set(listener, boundedListener);
            this.eventBus.addEventListener(event.toString(), boundedListener, options);
        }
    }

    class Stats {
        static measurements = [];
        static createMeasure(name, metadata) {
            const measurement = {
                name,
                start: performance.now(),
                metadata,
            };
            Stats.measurements.push(measurement);
            return {
                end: function (metadata) {
                    measurement.end = performance.now();
                    measurement.duration = measurement.end - measurement.start;
                    measurement.metadata = metadata;
                },
            };
        }
    }

    /**
     * @classdesc Represents a Dependency Graph for tracking dependencies between Detector classes.
     */
    class DependencyGraph {
        /**
         * Constructs a new DependencyGraph.
         */
        graph = new Map();
        sortedDetectors;
        constructor(detectors) {
            this.initialsDependencyGraph(detectors);
            this.sortedDetectors = this.topologicalSort();
        }
        /**
         * @classdesc Adds a Detector class to the graph if it doesn't already exist.
         *
         * @param {typeof Detector} detector - The Detector class to add.
         */
        addDetector(detector) {
            if (!this.graph.has(detector)) {
                this.graph.set(detector, { dependencies: new Set(), visited: false });
            }
        }
        /**
         * @classdesc Adds a dependency relationship between two Detector classes in the graph.
         *
         * @param {typeof Detector} detector - The Detector class to which the dependency is added.
         * @param {typeof Detector} dependencyClass - The class that is a dependency of the Detector class.
         */
        addDependency(detector, dependencyClass) {
            this.addDetector(detector);
            this.addDetector(dependencyClass);
            this.graph.get(detector).dependencies.add(dependencyClass);
        }
        /**
         * @classdesc Performs a topological sort on the graph and returns the sorted classes.
         *
         * @returns {Array<typeof Detector>} - The array of Detector classes in topologically sorted order.
         */
        topologicalSort() {
            const result = [];
            const stack = [];
            /**
             * @param {typeof Detector} traitClass - The current Detector class being visited.
             */
            const dfs = (traitClass) => {
                this.graph.get(traitClass).visited = true;
                for (const dependencyClass of this.graph.get(traitClass).dependencies) {
                    if (!this.graph.get(dependencyClass).visited) {
                        dfs(dependencyClass);
                    }
                }
                stack.push(traitClass);
            };
            for (const traitClass of this.graph.keys()) {
                if (!this.graph.get(traitClass).visited) {
                    dfs(traitClass);
                }
            }
            while (stack.length > 0) {
                result.push(stack.pop());
            }
            return result.reverse();
        }
        initialsDependencyGraph(detectors) {
            for (const detector of detectors) {
                this.addDetector(detector);
                const subsetDetectors = [...detector.subsetOf, ...detector.notSubsetOf, ...detector.dependencies, ...detector.notChildOf];
                for (const subsetDetector of subsetDetectors) {
                    this.addDependency(detector, subsetDetector);
                    if (subsetDetectors.length > 0) {
                        this.initialsDependencyGraph([subsetDetector]);
                    }
                }
            }
        }
    }

    /**
     * provides a unified way to access the state of the detections and nodes
     *
     */
    class State {
        /**
         * Lists all of the root elements that have been processed
         */
        processedRoots = new Set();
        /**
         * The state of all the elements and the detectors they are detected by
         */
        nodeToDetectors = new Map();
        /**
         * The state of all the detectors and the elements they are detected on
         */
        detectorToNodes = new Map();
        /**
         * set the state of a detector on an element within the two states
         */
        set(element, detector, detected) {
            if (!this.detectorToNodes.has(detector)) {
                this.detectorToNodes.set(detector, new Set());
            }
            if (detected) {
                this.detectorToNodes.get(detector).add(element);
            }
            else {
                this.detectorToNodes.get(detector).delete(element);
            }
            if (!this.nodeToDetectors.has(element)) {
                this.nodeToDetectors.set(element, {});
            }
            this.nodeToDetectors.get(element)[detector.id] = detected;
        }
        /**
         * get all the elements that are detected by a given detector via `detectorToNodes` map
         * @param detector
         */
        getByDetector(detector) {
            return this.detectorToNodes.get(detector) || new Set();
        }
        /**
         * get the state of a given element and detector via `nodeToDetectors`
         */
        getByNode(detector, element) {
            return this.nodeToDetectors.get(element)?.[detector.id];
        }
        /**
         * clear the state of all the detectors and elements
         */
        clear() {
            this.detectorToNodes.clear();
            this.nodeToDetectors.clear();
        }
        /**
         * remove specific element from the state
         */
        removeNodeFromState(element) {
            this.nodeToDetectors.delete(element);
            this.detectorToNodes.forEach((nodes) => {
                nodes.delete(element);
            });
        }
        /**
         * remove specific detectors for a given element from the state
         * @param element the element to remove the detectors from
         * @param detectors the detectors to remove
         */
        removeNodeFromStateByDetectors(element, detectors) {
            for (const detector of detectors) {
                if (this.detectorToNodes.has(detector)) {
                    const detectorNodes = this.detectorToNodes.get(detector);
                    detectorNodes.delete(element);
                }
            }
            const nodeDetectors = this.nodeToDetectors.get(element);
            if (!nodeDetectors) {
                return;
            }
            const detectorsNames = detectors.map((detector) => detector.id);
            const newState = Object.fromEntries(Object.entries(nodeDetectors).filter(([detectorName]) => !detectorsNames.includes(detectorName)));
            this.nodeToDetectors.set(element, newState);
        }
    }

    /**
     * @class Debounce
     * @classdesc Debounces a function to run on the leading edge with a specified delay.
     * @param delay The delay in milliseconds
     * @example
     * const debouncer = new Debounce(2000);
     * debouncer.execute(() => {
     *   console.log('Executed!');
     * });
     */
    class Debounce {
        delay;
        accumulatedMutations = [];
        /* By setting lastInvocation to Infinity, we make sure the callback is not executed until resetLastInvocation is run for the first time*/
        lastInvocation = Infinity;
        executionLocked = false;
        executionTimer;
        /**
         * @constructor
         * @param delay The delay in milliseconds
         */
        constructor(delay) {
            this.delay = delay;
            this.delay = delay;
        }
        /**
         * Executes the provided callback function with debouncing.
         * @param callback The function to be debounced
         * @param mutations The mutations to accumulate
         * @param tail Whether to execute the callback at the end of the delay period
         */
        execute(callback, mutations, { tail } = {}) {
            this.accumulatedMutations.push(...mutations);
            const now = Date.now();
            const elapsed = now - this.lastInvocation;
            clearTimeout(this.executionTimer);
            if (elapsed >= this.delay) {
                this.runCallback(callback);
            }
            else if (tail) {
                this.executionTimer = setTimeout(() => {
                    this.runCallback(callback);
                }, this.delay - elapsed);
            }
        }
        /**
         * Runs the provided callback with the accumulated mutations and then resets.
         * @param callback
         * @private
         */
        runCallback(callback) {
            if (this.executionLocked) {
                return;
            }
            callback(this.accumulatedMutations);
            this.resetAccumulatedMutations();
            this.resetLastInvocation();
        }
        /**
         * Resets the last invocation time to the current time.
         */
        resetLastInvocation() {
            this.lastInvocation = Date.now();
        }
        /**
         * Resets the accumulated mutations.
         */
        resetAccumulatedMutations() {
            this.accumulatedMutations = [];
        }
        /**
         * Disables the execution of the debounced callback.
         */
        disableExecution() {
            this.executionLocked = true;
        }
        /**
         * Enables the execution of the debounced callback and resets the last invocation time.
         * This ensures that the next execution will occur only after the full delay period.
         */
        enableExecution() {
            this.executionLocked = false;
            this.resetLastInvocation();
        }
    }

    /**
     * The service that manages all the context instances
     */
    class ContextService {
        contexts = new WeakMap();
        /**
         * Initializes and adds the context of the given detector to the classifier
         * @param detector
         * @param context
         */
        addContext(detector, context) {
            this.contexts.set(detector.contextType, context);
        }
        /**
         * Returns the context of the given detector
         * @param detector
         */
        getContext(detector) {
            if (this.contexts.has(detector.contextType)) {
                return this.contexts.get(detector.contextType);
            }
        }
    }

    /**
     * Responsible for managing modifications to the DOM.
     * Made to allow the `process` method in the `index.ts` easy way of getting the modifications
     * This class is used to set and get modifications that should applied to the DOM.
     * It manages of querying the DOM and finding the elements that match the modifications as well as
     * encapsulating the filter/query logic.
     */
    let ModificationsService$1 = class ModificationsService {
        rootElement;
        constructor(rootElement) {
            this.rootElement = rootElement;
        }
        modifications = [];
        /**
         * Updates the modifications with the given array of Modification objects.
         * @param modifications - An array of Modification objects.
         * @returns A Set of all modified elements, either removed or added.
         */
        setModifications(modifications) {
            this.modifications = modifications;
        }
        /**
         * Returns a Set of HTMLElements that are affected by updating the modifications with the given array of Modification objects.
         * Meaning, the elements that are either removed or added.
         * @param modifications
         */
        getEffectedElements(modifications) {
            const modificationsPrev = new ModificationList(this.rootElement, this.modifications);
            const modificationsNew = new ModificationList(this.rootElement, modifications);
            return new Set([...modificationsPrev.getElements(), ...modificationsNew.getElements()]);
        }
        /**
         * Return a ModificationList instance that contains the modifications and their corresponding elements.
         * This to allow the `process` method in the `index.ts` easy way of getting the modifications
         * @returns A ModificationList instance.
         */
        getModifications() {
            return new ModificationList(this.rootElement, this.modifications);
        }
        /**
         * Returns the modification for the given locator id.
         * @param locatorId
         */
        getModificationByLocatorId(locatorId) {
            return this.modifications.find((modification) => modification.type === "locating" && modification.locatorId === locatorId);
        }
    };
    /**
     * A class that represents a list of modifications and their corresponding elements.
     * It is responsible for querying the DOM and finding the elements that match the modifications.
     */
    class ModificationList {
        modificationToElement = new Map();
        ignoredDetectors = new Set();
        /**
         * Creates a new ModificationList.
         * @param rootElement - The root element to query.
         * @param modifications - An array of Modification objects.
         */
        constructor(rootElement, modifications) {
            for (const modification of modifications) {
                if (modification.type === "ignore-detector") {
                    this.ignoredDetectors.add(modification.detectorId);
                    continue;
                }
                const { selector, selectorMethod } = modification;
                const matchedElements = rootElement.querySelectorAll(selector);
                const elements = selectorMethod ? selectorMethod(rootElement, selector) : Array.from(matchedElements);
                for (const el of elements) {
                    if (!isSvgOrHtmlElement(el)) {
                        continue;
                    }
                    this.modificationToElement.set(modification, el);
                }
            }
        }
        /**
         * Returns the modifications for the given element.
         * @param target - The target element to get modifications for.
         * @param type - The type of modification to get.
         * @returns An array of modifications for the given element and type.
         */
        getByElement(target, type) {
            const modifications = [];
            for (const [modification, element] of this.modificationToElement.entries()) {
                if (modification.type !== type) {
                    continue;
                }
                if (target === element) {
                    modifications.push(modification);
                }
            }
            return modifications;
        }
        /**
         * Returns all elements that have been modified.
         * @returns A Set of all modified elements.
         */
        getElements() {
            const elements = new Set();
            for (const element of this.modificationToElement.values()) {
                elements.add(element);
            }
            return elements;
        }
        /**
         * Checks if a detector is ignored.
         * @param detectorId - The ID of the detector to check.
         * @returns True if the detector is ignored, false otherwise.
         */
        isDetectorIgnored(detectorId) {
            return this.ignoredDetectors.has(detectorId);
        }
    }

    var wordsDictionary = {
        Hebrew: {
            Home: "ראשי|בית|דף הבית",
            About: "אודות|עלינו|אודותנו",
            Services: "שירותים|שירות",
            Products: "מוצרים|מוצר",
            Contact: "צור קשר|צור-קשר|צור קשר איתנו",
            Blog: "בלוג",
            Shop: "חנות|חנות מזון|חנות-מזון",
            FAQ: "שאלות נפוצות|שאלות נפוצות|שאלות-נפוצות",
            Careers: "קריירה|משרות|משרה",
            News: "חדשות",
            Testimonials: "ביקורות|ביקורת",
            Portfolio: "Portfolios|פורטפוליו",
            Support: "תמיכה|עזרה",
            Events: "אירועים|אירוע",
            Gallery: "גלריה",
            Team: "צוות|צוות העובדים",
            Pricing: "מחירון|מחירים",
            Copyright: "זכויות יוצרים|זכויות-יוצרים",
            Tel: "טלפון|טל",
            Address: "כתובת",
            TermsAndCondition: "תנאים והגבלות|תנאים-והגבלות|תנאים",
            PrivacyPolicy: "מדיניות פרטיות|מדיניות-פרטיות|פרטיות",
            Powered: "מופעל על ידי|מופעל-על-ידי",
            Search: "חיפוש|חפש",
            All_rights_reserved: "כל הזכויות שמורות|כל-הזכויות-שמורות",
            login: "כניסה|התחברות|כנס|כניסה למערכת|התחבר",
            logout: "התנתקות|התנתק|התנתקות מהמערכת|התנתק מהמערכת",
            call: "התקשר|התקשר אלינו|התקשר-אלינו",
            register: "הרשמה|הרשמה כעת|הרשמה-כעת|הירשם|הירשם כעת|הירשם-כעת",
        },
        English: {
            Home: "Home|Main|Homepage",
            About: "About|About us|About-us",
            Services: "Services|Service",
            Products: "Products|Product",
            Contact: "Contact|Contact us|Contact-us",
            Blog: "Blog",
            Shop: "Shop|Store",
            FAQ: "FAQ|Frequently Asked Questions|Frequently-Asked-Questions",
            Careers: "Careers|Career",
            News: "News",
            Testimonials: "Testimonials",
            Portfolio: "Portfolio",
            Support: "Support|Help",
            Events: "Events|Event",
            Gallery: "Gallery",
            Team: "Team",
            Pricing: "Pricing",
            Copyright: "Copyright",
            Tel: "Tel",
            Address: "Address",
            TermsAndCondition: "Terms and conditions|terms & conditions|terms-and-conditions|terms|conditions",
            PrivacyPolicy: "Privacy policy| privacy-policy| policy",
            Powered: "Powered by|Powered-by",
            Search: "Search",
            All_rights_reserved: "All rights reserved|all-rights-reserved",
            login: "login|log in|log-in|signin|sign-in",
            logout: "logout|log out|log-out|signout|sign-out",
            call: "call|call us|call-us",
            register: "register|register now|register-now|sign-up|signup|sign up",
        },
        //Create a Russian version of the "English" object
        Russian: {
            Home: "Главная|Домашняя|Главная страница",
            About: "О нас|О компании|О нас справка",
            Services: "Услуги|Сервис",
            Products: "Продукты|Продукция",
            Contact: "Контакты|Свяжитесь с нами|Свяжитесь-с-нами",
            Blog: "Блог",
            Shop: "Магазин|Магазин товаров",
            FAQ: "Часто задаваемые вопросы|Часто-задаваемые-вопросы",
            Careers: "Карьера|Вакансии|Карьерные возможности",
            News: "Новости",
            Testimonials: "Отзывы|Отзыв",
            Portfolio: "Портфолио",
            Support: "Поддержка|Помощь",
            Events: "События|Событие",
            Gallery: "Галерея",
            Team: "Команда|Наша команда",
            Pricing: "Цены|Стоимость",
            Copyright: "Авторское право|Авторское-право",
            Tel: "Телефон|Тел",
            Address: "Адрес",
            TermsAndCondition: "Условия и положения|Условия-и-положения|Условия",
            PrivacyPolicy: "Политика конфиденциальности|Политика-конфиденциальности|Конфиденциальность",
            Powered: "Работает на|Работает-на",
            Search: "Поиск",
            All_rights_reserved: "Все права защищены|Все-права-защищены",
            login: "Вход|Авторизация|Логин|Войти|Авторизоваться",
            logout: "Выход|Выйти|Выход из системы|Выйти из системы",
            call: "Звонок|Позвонить нам|Позвонить-нам",
            register: "Регистрация|Зарегистрироваться|Регистрация сейчас|Зарегистрироваться сейчас",
        },
        Japanese: {
            Home: "ホーム|メイン|ホームページ",
            About: "会社概要|私たちについて|私たちに関して",
            Services: "サービス|サービス提供",
            Products: "製品|商品",
            Contact: "お問い合わせ|お問い合わせください|お問い合わせ-us",
            Blog: "ブログ",
            Shop: "ショップ|ストア",
            FAQ: "よくある質問|FAQ|よくある質問-よくある質問",
            Careers: "キャリア|職業",
            News: "ニュース",
            Testimonials: "お客様の声",
            Portfolio: "ポートフォリオ",
            Support: "サポート|ヘルプ",
            Events: "イベント|イベント",
            Gallery: "ギャラリー",
            Team: "チーム",
            Pricing: "価格設定",
            Copyright: "著作権",
            Tel: "電話",
            Address: "住所",
            TermsAndCondition: "利用規約|利用条件",
            PrivacyPolicy: "プライバシーポリシー|プライバシーポリシー|ポリシー",
            Powered: "パワード バイ | パワード バイ",
            Search: "検索",
            All_rights_reserved: "全著作権所有|全著作権所有",
            login: "ログイン|ログイン|ログイン|サインイン|サインイン",
            logout: "ログアウト|ログアウト|ログアウト|サインアウト|サインアウト",
            call: "電話|お電話|お電話",
            register: "登録|今すぐ登録|今すぐ登録|サインアップ|サインアップ|サインアップ",
        },
        Spanish: {
            Home: "Inicio|Principal|Página de inicio",
            About: "Acerca de|Quiénes somos|Acerca de nosotros",
            Services: "Servicios|Servicio",
            Products: "Productos|Producto",
            Contact: "Contacto|Contáctenos|Contáctanos",
            Blog: "Blog",
            Shop: "Tienda|Tienda en línea",
            FAQ: "Preguntas frecuentes|FAQ|Preguntas-Respuestas-Frecuentes",
            Careers: "Empleos|Carrera",
            News: "Noticias",
            Testimonials: "Testimonios",
            Portfolio: "Portafolio",
            Support: "Soporte|Ayuda",
            Events: "Eventos|Evento",
            Gallery: "Galería",
            Team: "Equipo",
            Pricing: "Precios|Tarifas",
            Copyright: "Derechos de autor",
            Tel: "Teléfono",
            Address: "Dirección",
            TermsAndCondition: "Términos y condiciones|Términos y condiciones|Términos y condiciones|Términos|Condiciones",
            PrivacyPolicy: "Política de privacidad|Política de privacidad|Política",
            Powered: "Desarrollado por|Desarrollado-por",
            Search: "Buscar",
            All_rights_reserved: "Todos los derechos reservados|Todos-los-derechos-reservados",
            login: "Iniciar sesión|Iniciar sesión|Iniciar-sesión|Iniciar sesión|Iniciar-sesión",
            logout: "Cerrar sesión|Cerrar sesión|Cerrar-sesión|Cerrar sesión|Cerrar-sesión",
            call: "Llamar|Llámanos|Llámenos",
            register: "Registrarse|Registrarse ahora|Registrarse-ahora|Registrarse|Registrarse|Registrarse",
        },
        French: {
            Home: "Accueil|Accueil principal|Page d'accueil",
            About: "À propos|Qui sommes-nous|À propos de nous",
            Services: "Services|Service",
            Products: "Produits|Produit",
            Contact: "Contact|Contactez-nous|Contactez-nous",
            Blog: "Blog",
            Shop: "Boutique|Magasin",
            FAQ: "FAQ|Foire aux questions",
            Careers: "Carrières|Carrière",
            News: "Actualités|Nouvelles",
            Testimonials: "Témoignages|Avis",
            Portfolio: "Portefeuille|Portfolio",
            Support: "Support|Aide",
            Events: "Événements|Événement",
            Gallery: "Galerie|Photos",
            Team: "Équipe|Personnel",
            Pricing: "Tarification|Prix",
            Copyright: "Droits d'auteur",
            Tel: "Téléphone",
            Address: "Adresse",
            TermsAndCondition: "Termes et conditions|Conditions générales",
            PrivacyPolicy: "Politique de confidentialité|Politique de vie privée|Confidentialité",
            Powered: "Propulsé par|Fourni par",
            Search: "Rechercher|Chercher",
            All_rights_reserved: "Tous droits réservés|Tous-droits-réservés",
            login: "Connexion|Se connecter",
            logout: "Déconnexion|Se déconnecter",
            call: "Appeler|Appelez-nous|Contactez-nous",
            register: "S'inscrire|Inscrivez-vous maintenant|Enregistrez-vous",
        },
        "Chinese (Mandarin)": {
            Home: "首页|主页|主页",
            About: "关于|关于我们|关于我们",
            Services: "服务|服务",
            Products: "产品|产品",
            Contact: "联系|联系我们|联系我们",
            Blog: "博客",
            Shop: "商店|店铺",
            FAQ: "常见问题|常见问题|常见问题",
            Careers: "职业|职业",
            News: "新闻",
            Testimonials: "客户评价",
            Portfolio: "作品集",
            Support: "支持|帮助",
            Events: "事件|活动",
            Gallery: "画廊",
            Team: "团队",
            Pricing: "定价",
            Copyright: "版权",
            Tel: "电话",
            Address: "地址",
            TermsAndCondition: "条款和条件|条款和条件|条款|条件",
            PrivacyPolicy: "隐私政策|隐私政策|政策",
            Powered: "由|提供|由|提供",
            Search: "搜索",
            All_rights_reserved: "保留所有权利|保留所有权利",
            login: "登录|登录|登录|登录|登录",
            logout: "注销|注销|注销|注销|注销",
            call: "呼叫|呼叫我们|呼叫我们",
            register: "注册|立即注册|立即注册|注册|注册|注册",
        },
        Portuguese: {
            Home: "Início|Principal|Página principal",
            About: "Sobre|Sobre nós|Sobre-nós",
            Services: "Serviços|Serviço",
            Products: "Produtos|Produto",
            Contact: "Contato|Fale conosco|Entre em contato",
            Blog: "Blog",
            Shop: "Loja|Loja online",
            FAQ: "Perguntas frequentes|Perguntas-respondidas-frequentemente",
            Careers: "Carreiras|Carreira",
            News: "Notícias",
            Testimonials: "Depoimentos",
            Portfolio: "Portfólio",
            Support: "Suporte|Ajuda",
            Events: "Eventos|Evento",
            Gallery: "Galeria",
            Team: "Equipe",
            Pricing: "Preços",
            Copyright: "Direitos autorais",
            Tel: "Telefone",
            Address: "Endereço",
            TermsAndCondition: "Termos e condições|Termos & condições|Termos-e-condições|Termos|Condições",
            PrivacyPolicy: "Política de privacidade|Política de-privacidade|Política",
            Powered: "Desenvolvido por|Powered by",
            Search: "Pesquisar",
            All_rights_reserved: "Todos os direitos reservados|Todos-os-direitos-reservados",
            login: "Login|Entrar|Iniciar sessão|Faça login",
            logout: "Logout|Sair|Encerrar sessão|Faça logout",
            call: "Ligar|Ligue-nos|Chamar|Chame-nos",
            register: "Registrar|Registrar agora|Registre-se|Inscreva-se|Faça registro",
        },
        Italian: {
            Home: "Home|Pagina principale",
            About: "Chi siamo|Informazioni|Su di noi",
            Services: "Servizi|Servizio",
            Products: "Prodotti|Prodotto",
            Contact: "Contatti|Contattaci|Contattateci",
            Blog: "Blog",
            Shop: "Negozio|Negozio online",
            FAQ: "Domande frequenti|Domande-ricorrenti",
            Careers: "Carriere|Carriera",
            News: "Notizie",
            Testimonials: "Testimonianze",
            Portfolio: "Portfolio|Portafoglio",
            Support: "Supporto|Aiuto",
            Events: "Eventi|Evento",
            Gallery: "Galleria",
            Team: "Team|Squadra",
            Pricing: "Prezzi|Tariffe",
            Copyright: "Copyright|Diritti d'autore",
            Tel: "Telefono",
            Address: "Indirizzo",
            TermsAndCondition: "Termini e condizioni|Termini & condizioni|Termini|Condizioni",
            PrivacyPolicy: "Informativa sulla privacy|Politica sulla privacy|Privacy",
            Powered: "Realizzato da|Powered by",
            Search: "Ricerca|Cerca",
            All_rights_reserved: "Tutti i diritti riservati|Tutti-i-diritti-riservati",
            login: "Login|Accedi|Effettua il login",
            logout: "Logout|Esci|Effettua il logout",
            call: "Chiama|Chiamaci|Chiamateci",
            register: "Registrati|Registrati ora|Iscriviti|Fai la registrazione",
        },
        Polish: {
            Home: "Strona główna|Główna|Homepage",
            About: "O nas|O naszym serwisie|O firmie",
            Services: "Usługi|Usługa",
            Products: "Produkty|Produkt",
            Contact: "Kontakt|Skontaktuj się|Napisz do nas",
            Blog: "Blog",
            Shop: "Sklep|Sklep internetowy",
            FAQ: "FAQ|Najczęściej zadawane pytania|Najczęściej-zadawane-pytania",
            Careers: "Kariera|Praca",
            News: "Aktualności|Wiadomości",
            Testimonials: "Referencje|Opinie klientów",
            Portfolio: "Portfolio",
            Support: "Wsparcie|Pomoc",
            Events: "Wydarzenia|Wydarzenie",
            Gallery: "Galeria",
            Team: "Zespół|Ekipa",
            Pricing: "Cennik|Opłaty",
            Copyright: "Prawa autorskie|Copyright",
            Tel: "Telefon|Nr telefonu",
            Address: "Adres",
            TermsAndCondition: "Regulamin|Warunki użytkowania|Warunki|Zasady",
            PrivacyPolicy: "Polityka prywatności|Polityka",
            Powered: "Napędzane przez|Powered by",
            Search: "Szukaj|Wyszukaj",
            All_rights_reserved: "Wszelkie prawa zastrzeżone|Wszystkie-prawa-zastrzeżone",
            login: "Zaloguj|Zaloguj się|Zalogowanie|Zalogowany|Zalogowana",
            logout: "Wyloguj|Wyloguj się|Wylogowanie|Wylogowany|Wylogowana",
            call: "Zadzwoń|Zadzwoń do nas|Zadzwońcie do nas",
            register: "Zarejestruj|Zarejestruj się|Rejestracja|Zapisz się",
        },
        Arabic: {
            Home: "الرئيسية|الصفحة الرئيسية|الصفحة الرئيسية",
            About: "حول|حولنا|حولنا",
            Services: "خدمات|خدمة",
            Products: "منتجات|منتج",
            Contact: "اتصل|اتصل بنا|اتصل بنا",
            Blog: "مدونة",
            Shop: "متجر|متجر",
            FAQ: "أسئلة متكررة|أسئلة مكررة|أسئلة مكررة",
            Careers: "وظائف|وظيفة",
            News: "أخبار",
            Testimonials: "شهادات|توصيات",
            Portfolio: "معرض أعمال|معرض الأعمال",
            Support: "الدعم|المساعدة",
            Events: "فعاليات|فعالية",
            Gallery: "معرض الصور|صور",
            Team: "الفريق",
            Pricing: "التسعير",
            Copyright: "حقوق النشر",
            Tel: "الهاتف",
            Address: "العنوان",
            TermsAndCondition: "الشروط والأحكام|الشروط والأحوال|الشروط|الأحوال",
            PrivacyPolicy: "سياسة الخصوصية|سياسة الخصوصية|سياسة",
            Powered: "مدعوم بواسطة|مدعوم بواسطة",
            Search: "بحث",
            All_rights_reserved: "جميع الحقوق محفوظة|جميع الحقوق محفوظة",
            login: "تسجيل الدخول|تسجيل الدخول|تسجيل الدخول|تسجيل الدخول|تسجيل الدخول",
            logout: "تسجيل الخروج|تسجيل الخروج|تسجيل الخروج|تسجيل الخروج|تسجيل الخروج",
            call: "اتصل|اتصل بنا|اتصل بنا",
            register: "سجل|سجل الآن|سجل الآن|سجل|سجل|سجل",
        },
        Dutch: {
            Home: "Home|Hoofdpagina|Homepage",
            About: "Over|Over ons|Over ons",
            Services: "Diensten|Dienst",
            Products: "Producten|Product",
            Contact: "Contact|Neem contact op|Contact opnemen",
            Blog: "Blog",
            Shop: "Winkel|Winkel",
            FAQ: "Veelgestelde vragen|FAQ|Veelgestelde vragen",
            Careers: "Carrières|Carrière",
            News: "Nieuws",
            Testimonials: "Getuigenissen|Referenties",
            Portfolio: "Portfolio",
            Support: "Ondersteuning|Hulp",
            Events: "Evenementen|Evenement",
            Gallery: "Galerij",
            Team: "Team",
            Pricing: "Prijzen",
            Copyright: "Auteursrecht",
            Tel: "Telefoon",
            Address: "Adres",
            TermsAndCondition: "Algemene voorwaarden|Voorwaarden|Voorwaarden",
            PrivacyPolicy: "Privacybeleid|Privacybeleid|Beleid",
            Powered: "Aangedreven door|Aangedreven door",
            Search: "Zoeken",
            All_rights_reserved: "Alle rechten voorbehouden|Alle rechten voorbehouden",
            login: "Inloggen|Log in|Inloggen|Aanmelden|Aanmelden|Aanmelden",
            logout: "Uitloggen|Log uit|Uitloggen|Afmelden|Afmelden|Afmelden",
            call: "Bel|Bel ons|Bel ons",
            register: "Registreren|Registreer nu|Registreer nu|Aanmelden|Aanmelden|Aanmelden",
        },
        German: {
            Home: "Startseite|Hauptseite|Homepage",
            About: "Über|Über uns|Über uns",
            Services: "Dienstleistungen|Dienstleistung",
            Products: "Produkte|Produkt",
            Contact: "Kontakt|Kontaktiere uns|Kontaktiere uns",
            Blog: "Blog",
            Shop: "Geschäft|Geschäft",
            FAQ: "FAQ|Häufig gestellte Fragen|Häufig-gestellte-Fragen",
            Careers: "Karriere|Beruf",
            News: "Nachrichten",
            Testimonials: "Kundenbewertungen|Referenzen",
            Portfolio: "Portfolio",
            Support: "Support|Hilfe",
            Events: "Veranstaltungen|Veranstaltung",
            Gallery: "Galerie",
            Team: "Team",
            Pricing: "Preise",
            Copyright: "Urheberrecht",
            Tel: "Telefon",
            Address: "Adresse",
            TermsAndCondition: "Allgemeine Geschäftsbedingungen|Geschäftsbedingungen|Bedingungen",
            PrivacyPolicy: "Datenschutzrichtlinie|Datenschutzrichtlinie|Richtlinie",
            Powered: "Bereitgestellt von|Bereitgestellt von",
            Search: "Suche",
            All_rights_reserved: "Alle Rechte vorbehalten|Alle Rechte vorbehalten",
            login: "Anmelden|Einloggen|Einloggen|Anmelden|Anmelden|Anmelden",
            logout: "Abmelden|Ausloggen|Ausloggen|Abmelden|Abmelden|Abmelden",
            call: "Anrufen|Rufen Sie uns an|Rufen Sie uns an",
            register: "Registrieren|Jetzt registrieren|Jetzt registrieren|Anmelden|Anmelden|Anmelden",
        },
        Hungarian: {
            Home: "Kezdőlap|Főoldal|Kezdőoldal",
            About: "Rólunk|Rólunk|Rólunk",
            Services: "Szolgáltatások|Szolgáltatás",
            Products: "Termékek|Termék",
            Contact: "Kapcsolat|Kapcsolatfelvétel|Kapcsolat-felvétel",
            Blog: "Blog",
            Shop: "Üzlet|Áruház",
            FAQ: "GYIK|Gyakran Ismételt Kérdések|Gyakran-Ismételt-Kérdések",
            Careers: "Karrier|Karrier",
            News: "Hírek",
            Testimonials: "Vélemények",
            Portfolio: "Portfólió",
            Support: "Támogatás|Segítség",
            Events: "Események|Esemény",
            Gallery: "Galéria",
            Team: "Csapat",
            Pricing: "Árak",
            Copyright: "Szerzői jog",
            Tel: "Telefon",
            Address: "Cím",
            TermsAndCondition: "Felhasználási feltételek|felhasználási-feltételek|feltételek",
            PrivacyPolicy: "Adatvédelmi irányelv|adatvédelmi-irányelv|irányelv",
            Powered: "Powered by|Powered-by",
            Search: "Keresés",
            All_rights_reserved: "Minden jog fenntartva|minden-jog-fenntartva",
            login: "Bejelentkezés|Bejelentkezés|Bejelentkezés|Belépés|Belépés",
            logout: "Kijelentkezés|Kijelentkezés|Kijelentkezés|Kilépés|Kilépés",
            call: "Hívás|Hívjon minket|Hívjon-minket",
            register: "Regisztráció|Regisztráljon most|Regisztráljon-most|Regisztrálás|Regisztráljon|Regisztráljon-most",
        },
        Turkish: {
            Home: "Ana Sayfa|Ana|Başlangıç|Anasayfa",
            About: "Hakkımızda|Biz Kimiz|Hakkında",
            Services: "Hizmetler|Hizmet",
            Products: "Ürünler|Ürün",
            Contact: "İletişim|Bize Ulaşın|İletişim Kur|İletişim Bilgileri",
            Blog: "Blog",
            Shop: "Mağaza|Dükkan|Satış Yeri|Alışveriş",
            FAQ: "SSS|Sıkça Sorulan Sorular|Sık Sorulan Sorular",
            Careers: "Kariyer|Kariyer Fırsatları",
            News: "Haberler|Haber",
            Testimonials: "Referanslar|Tavsiyeler|Yorumlar",
            Portfolio: "Portföy|Projelerimiz|Çalışmalar",
            Support: "Destek|Yardım",
            Events: "Etkinlikler|Etkinlik",
            Gallery: "Galeri|Resimler",
            Team: "Ekip|Takım",
            Pricing: "Fiyatlandırma|Ücretler",
            Copyright: "Telif Hakkı|Tüm Hakları Saklıdır",
            Tel: "Telefon|Tel",
            Address: "Adres",
            TermsAndCondition: "Kullanım Koşulları|Şartlar ve Koşullar|Şartlar|Koşullar",
            PrivacyPolicy: "Gizlilik Politikası|Gizlilik Politikası",
            Powered: "Tarafından Desteklenmektedir|Powered by",
            Search: "Ara|Arama",
            All_rights_reserved: "Tüm Hakları Saklıdır|Telif Hakkı",
            login: "Giriş|Oturum Aç|Giriş Yap|Giriş Yapın",
            logout: "Çıkış|Oturumu Kapat|Çıkış Yap|Çıkış Yapın",
            call: "Ara|Bizi Ara|Arama Yap|Çağrı Yap",
            register: "Kaydol|Şimdi Kaydol|Kaydolun|Üye Ol|Üye Olun",
        },
        Slovakian: {
            Home: "Domov|Hlavná|Domovská stránka",
            About: "O nás|O nás|O-nás",
            Services: "Služby|Služba",
            Products: "Produkty|Produkt",
            Contact: "Kontakt|Kontaktujte nás|Kontaktujte nás",
            Blog: "Blog",
            Shop: "Obchod|Obchod",
            FAQ: "Časté otázky|Často kladené otázky|Často-kladené-otázky",
            Careers: "Kariéra|Kariéra",
            News: "Novinky",
            Testimonials: "Referencie",
            Portfolio: "Portfólio",
            Support: "Podpora|Pomoc",
            Events: "Udalosti|Udalosť",
            Gallery: "Galéria",
            Team: "Tím",
            Pricing: "Ceny",
            Copyright: "Autorské práva",
            Tel: "Tel",
            Address: "Adresa",
            TermsAndCondition: "Podmienky použitia|podmienky & podmienky|podmienky|podmienky",
            PrivacyPolicy: "Zásady ochrany osobných údajov|zásady-ochrany-osobných-údajov|zásady",
            Powered: "Používané s|Používané-s",
            Search: "Vyhľadávanie",
            All_rights_reserved: "Všetky práva vyhradené|všetky-práva-vyhradené",
            login: "prihlásenie|prihlásiť sa|prihlásiť-sa|prihlasovanie|prihlasovanie",
            logout: "odhlásenie|odhlásiť sa|odhlásiť-sa|odhlasovanie|odhlasovanie",
            call: "volanie|volajte nás|volajte-nás",
            register: "registrácia|registrovať sa teraz|registrovať-sa-teraz|registrovať sa|registrácia|registrovať-sa",
        },
        Slovenian: {
            Home: "Domov|Glavna|Domača stran",
            About: "O nas|O nas|O-nas",
            Services: "Storitve|Storitev",
            Products: "Izdelki|Izdelek",
            Contact: "Kontakt|Kontaktirajte nas|Kontaktirajte-nas",
            Blog: "Blog",
            Shop: "Trgovina|Trgovina",
            FAQ: "Pogosta vprašanja|Pogosto zastavljena vprašanja|Pogosto-zastavljena-vprašanja",
            Careers: "Kariera|Kariera",
            News: "Novice",
            Testimonials: "Mnenja strank",
            Portfolio: "Portfelj",
            Support: "Podpora|Pomoč",
            Events: "Dogodki|Dogodek",
            Gallery: "Galerija",
            Team: "Ekipa",
            Pricing: "Cenik",
            Copyright: "Avtorske pravice",
            Tel: "Tel",
            Address: "Naslov",
            TermsAndCondition: "Pogoji uporabe|pogoji & pogoji|pogoji|pogoji",
            PrivacyPolicy: "Pravilnik o zasebnosti|pravilnik-o-zasebnosti|pravilnik",
            Powered: "Z napajanjem z|Z-napajanjem-z",
            Search: "Iskanje",
            All_rights_reserved: "Vse pravice pridržane|vse-pravice-pridržane",
            login: "prijava|prijava|prijava|prijava|prijava",
            logout: "odjava|odjava|odjava|odjava|odjava",
            call: "klic|kličite nas|kličite-nas|pokličite nas|pokličite-nas",
            register: "registracija|registrirajte se zdaj|registrirajte-se-zdaj|registrirajte-se|registracija|registrirajte-se",
        },
        Chzech: {
            Home: "Domů|Hlavní|Domovní stránka",
            About: "O nás|O nás|O-nás",
            Services: "Služby|Služba",
            Products: "Produkty|Produkt",
            Contact: "Kontakt|Kontaktujte nás|Kontaktujte-nás",
            Blog: "Blog",
            Shop: "Obchod|Obchod",
            FAQ: "Často kladené otázky|Často kladené otázky|Často-Kladené-Otázky",
            Careers: "Kariéra|Kariéra",
            News: "Novinky",
            Testimonials: "Reference",
            Portfolio: "Portfólio",
            Support: "Podpora|Pomoc",
            Events: "Události|Událost",
            Gallery: "Galerie",
            Team: "Tým",
            Pricing: "Ceník",
            Copyright: "Autorská práva",
            Tel: "Tel",
            Address: "Adresa",
            TermsAndCondition: "Obchodní podmínky|Obchodní podmínky|Podmínky",
            PrivacyPolicy: "Zásady ochrany soukromí|Zásady-ochrany-soukromí|Zásady",
            Powered: "Poháněno|Poháněno",
            Search: "Hledat",
            All_rights_reserved: "Všechna práva vyhrazena|Všechna-práva-vyhrazena",
            login: "Přihlášení|Přihlášení|Přihlášení|Přihlášení|Přihlášení",
            logout: "Odhlášení|Odhlášení|Odhlášení|Odhlášení|Odhlášení",
            call: "Zavolat|Zavolejte nám|Zavolejte-nám",
            register: "Registrace|Registrovat se nyní|Registrovat-se-nyní|Přihlásit-se|Přihlásit se|Přihlásit-se",
        },
    };

    /**
     * @classdesc Responsible for the feature and candidates extraction for the `footer` classification
     */
    class ClassifierBase {
        /**
         * Mapping of a dictionary key (english) to an array of its translations on every language
         */
        static MultilingualWords = Object.entries(wordsDictionary).reduce((acc, [language, words]) => {
            for (const [wordKey, wordValue] of Object.entries(words)) {
                acc[wordKey] = acc[wordKey] || [];
                acc[wordKey].push(wordValue.toLowerCase());
            }
            return acc;
        }, {});
        /**
         * List of features for this classification
         */
        static Features;
        /**
         * Retries the list of candidates for the class/type of classification.
         * @abstract
         *  */
        static getCandidates(rootElement) {
            throw "Unimplemented method";
        }
        /**
         * Retrieves an object/list of features for given `element`
         * */
        static getFeatures(element) {
            const clientRect = element.getBoundingClientRect();
            const pageRect = {
                height: Math.max(document.body.scrollHeight, document.documentElement.scrollHeight),
                width: Math.max(document.body.scrollWidth, document.documentElement.scrollWidth),
            };
            const visibleChildren = Array.from(element.querySelectorAll("*")).filter(ClassifierBase.isElementVisible);
            const absoluteClientRect = this.calculateElementPositionAndDimensions(element);
            const content = [element, ...visibleChildren]
                .map((child) => {
                let response = "";
                for (const childNode of Array.from(child.childNodes)) {
                    if (childNode.nodeType === Node.TEXT_NODE) {
                        response += childNode.textContent;
                    }
                }
                return response.replace(/[\n\s]/g, "");
            })
                .join("")
                .replace(/\s/g, "");
            const lowerCasedContent = content.toLowerCase();
            const computedStyle = window.getComputedStyle(element);
            const viewport = {
                width: window.innerWidth || document.documentElement.clientWidth,
                height: window.innerHeight || document.documentElement.clientHeight,
            };
            const parents = ClassifierBase.getParents(element);
            const response = {};
            for (const [featureKey, featureProvider] of Object.entries(this.Features)) {
                response[featureKey] = featureProvider({
                    element,
                    content,
                    lowerCasedContent,
                    clientRect,
                    absoluteClientRect,
                    visibleChildren,
                    parents,
                    viewport,
                    pageRect,
                    computedStyle,
                });
                response[featureKey] = parseFloat(response[featureKey].toPrecision(3));
            }
            return response;
        }
        /**
         * Determines whether given `element` is visible to the user
         */
        static isElementVisible(element) {
            const style = window.getComputedStyle(element);
            let visibleDimensions = true;
            if (element.offsetWidth <= 1 || element.offsetHeight <= 1) {
                visibleDimensions = false;
                for (const child of Array.from(element.querySelectorAll("*"))) {
                    if (child.offsetWidth > 1 && child.offsetHeight > 1) {
                        visibleDimensions = true;
                        break;
                    }
                }
            }
            return style.opacity !== "0" && style.visibility !== "hidden" && style.display !== "none" && visibleDimensions;
        }
        /**
         * Determines whether given `element` is a descendent of the body element
         * @param element
         */
        static isBodyDescendent(element) {
            return document.body !== element;
        }
        /**
         * Determine whether given `element` is an image based on it's tag-name or background-image CSS property
         * @param element
         */
        static isImage(element) {
            return element.tagName === "IMG" || element.tagName === "SVG" || window.getComputedStyle(element).backgroundImage !== "none";
        }
        /**
         * Calculates the position and dimensions of given `element` considering all of its overflowing children.
         * @param element
         */
        static calculateElementPositionAndDimensions(element) {
            const boundingClientRect = this.getElementAbsolutePosition(element);
            const matrix = {
                top: [boundingClientRect.top],
                left: [boundingClientRect.left],
                right: [boundingClientRect.right],
                bottom: [boundingClientRect.bottom],
            };
            if (window.getComputedStyle(element).overflow !== "hidden") {
                for (const child of Array.from(element.children).filter((child) => child instanceof HTMLElement && ClassifierBase.isElementVisible(child))) {
                    const nestedMatrix = this.calculateElementPositionAndDimensions(child);
                    matrix.top.push(nestedMatrix.top);
                    matrix.left.push(nestedMatrix.left);
                    matrix.right.push(nestedMatrix.right);
                    matrix.bottom.push(nestedMatrix.bottom);
                }
            }
            const response = {
                top: Math.min(...matrix.top),
                left: Math.min(...matrix.left),
                right: Math.max(...matrix.right),
                bottom: Math.max(...matrix.bottom),
                height: Math.max(...matrix.bottom) - Math.min(...matrix.top),
                width: Math.max(...matrix.right) - Math.min(...matrix.left),
            };
            return response;
        }
        /**
         * Calculates element absolute position relative to the document, including bottom and right coordinates
         */
        static getElementAbsolutePosition(element) {
            const boundingClientRect = element.getBoundingClientRect();
            return {
                top: boundingClientRect.top + document.documentElement.scrollTop,
                left: boundingClientRect.left + document.documentElement.scrollLeft,
                right: boundingClientRect.right + document.documentElement.scrollLeft,
                bottom: boundingClientRect.bottom + document.documentElement.scrollTop,
            };
        }
        /**
         * Retrieves a list of all the ancestors of given `element`
         */
        static getParents(element) {
            const parents = [];
            let currentParent = element.parentElement;
            while (currentParent && currentParent !== document.body) {
                parents.push(currentParent);
                currentParent = currentParent.parentElement;
            }
            return parents;
        }
    }

    var model$1;
    var hasRequiredModel$1;

    function requireModel$1 () {
    	if (hasRequiredModel$1) return model$1;
    	hasRequiredModel$1 = 1;
    	model$1 = function score(input) {
    	    var var0;
    	    if (input[0] > 0.04180000000000001) {
    	        if (input[2] > 0.000000000000000000000000000000000010000000180025095) {
    	            if (input[4] > 0.000000000000000000000000000000000010000000180025095) {
    	                var0 = 0.5354959238897663;
    	            }
    	            else {
    	                var0 = 0.1425113282192199;
    	            }
    	        }
    	        else {
    	            if (input[1] > 0.000000000000000000000000000000000010000000180025095) {
    	                var0 = 0.5019308331915702;
    	            }
    	            else {
    	                var0 = -0.5932571561756527;
    	            }
    	        }
    	    }
    	    else {
    	        if (input[14] > 0.468) {
    	            if (input[0] > 0.013550000000000001) {
    	                if (input[14] > 0.6080000000000001) {
    	                    if (input[10] > 5.875000000000001) {
    	                        var0 = 0.1477076704378512;
    	                    }
    	                    else {
    	                        var0 = 0.45757866277629805;
    	                    }
    	                }
    	                else {
    	                    var0 = -0.33358666391219627;
    	                }
    	            }
    	            else {
    	                var0 = 0.5376800007383584;
    	            }
    	        }
    	        else {
    	            if (input[0] > 0.0014500000000000001) {
    	                var0 = -0.5357885935986592;
    	            }
    	            else {
    	                var0 = 0.11964807554513163;
    	            }
    	        }
    	    }
    	    var var1;
    	    if (input[0] > 0.04180000000000001) {
    	        if (input[1] > 0.000000000000000000000000000000000010000000180025095) {
    	            var1 = 0.4310771918662546;
    	        }
    	        else {
    	            if (input[2] > 0.000000000000000000000000000000000010000000180025095) {
    	                if (input[15] > 0.13650000000000004) {
    	                    var1 = -0.2428628458228172;
    	                }
    	                else {
    	                    var1 = 0.2828176208911415;
    	                }
    	            }
    	            else {
    	                var1 = -0.45840364572903436;
    	            }
    	        }
    	    }
    	    else {
    	        if (input[14] > 0.36650000000000005) {
    	            if (input[14] > 0.6360000000000001) {
    	                if (input[5] > 22.500000000000004) {
    	                    var1 = 0.40973772951422366;
    	                }
    	                else {
    	                    var1 = -0.04626553360058049;
    	                }
    	            }
    	            else {
    	                if (input[0] > 0.011300000000000003) {
    	                    var1 = -0.1573152181563346;
    	                }
    	                else {
    	                    var1 = 0.28003011499328756;
    	                }
    	            }
    	        }
    	        else {
    	            if (input[12] > 2.5000000000000004) {
    	                var1 = 0.04558123011769095;
    	            }
    	            else {
    	                var1 = -0.490120523622292;
    	            }
    	        }
    	    }
    	    var var2;
    	    if (input[0] > 0.03930000000000001) {
    	        if (input[4] > 0.000000000000000000000000000000000010000000180025095) {
    	            var2 = 0.2642623463758446;
    	        }
    	        else {
    	            if (input[2] > 0.000000000000000000000000000000000010000000180025095) {
    	                var2 = 0.044554968167708396;
    	            }
    	            else {
    	                var2 = -0.3929357845650369;
    	            }
    	        }
    	    }
    	    else {
    	        if (input[14] > 0.36650000000000005) {
    	            if (input[0] > 0.013550000000000001) {
    	                if (input[2] > 0.000000000000000000000000000000000010000000180025095) {
    	                    var2 = 0.3506761353940716;
    	                }
    	                else {
    	                    if (input[10] > 5.875000000000001) {
    	                        var2 = -0.4077515739629896;
    	                    }
    	                    else {
    	                        var2 = 0.1447701582120723;
    	                    }
    	                }
    	            }
    	            else {
    	                if (input[5] > 9.500000000000002) {
    	                    var2 = 0.34665801581486616;
    	                }
    	                else {
    	                    var2 = -0.28821796969389424;
    	                }
    	            }
    	        }
    	        else {
    	            if (input[0] > 0.0008550000000000002) {
    	                var2 = -0.42144524096413316;
    	            }
    	            else {
    	                var2 = 0.188052821394435;
    	            }
    	        }
    	    }
    	    var var3;
    	    if (input[0] > 0.04180000000000001) {
    	        if (input[1] > 0.000000000000000000000000000000000010000000180025095) {
    	            var3 = 0.3405889375132391;
    	        }
    	        else {
    	            if (input[2] > 0.000000000000000000000000000000000010000000180025095) {
    	                var3 = 0.07584899208182695;
    	            }
    	            else {
    	                var3 = -0.36135317892464247;
    	            }
    	        }
    	    }
    	    else {
    	        if (input[14] > 0.6235) {
    	            if (input[0] > 0.013550000000000001) {
    	                if (input[1] > 0.000000000000000000000000000000000010000000180025095) {
    	                    var3 = 0.34593249855077485;
    	                }
    	                else {
    	                    if (input[42] > 0.018750000000000003) {
    	                        var3 = 0.18976770064348408;
    	                    }
    	                    else {
    	                        var3 = -0.22781151471897595;
    	                    }
    	                }
    	            }
    	            else {
    	                var3 = 0.3064923280517049;
    	            }
    	        }
    	        else {
    	            if (input[0] > 0.00007205) {
    	                if (input[7] > 0.000000000000000000000000000000000010000000180025095) {
    	                    var3 = 0.18805947925356817;
    	                }
    	                else {
    	                    var3 = -0.2689665102743406;
    	                }
    	            }
    	            else {
    	                var3 = 0.21783049611560829;
    	            }
    	        }
    	    }
    	    var var4;
    	    if (input[0] > 0.03665000000000001) {
    	        if (input[1] > 0.000000000000000000000000000000000010000000180025095) {
    	            var4 = 0.29103128830231206;
    	        }
    	        else {
    	            if (input[2] > 0.000000000000000000000000000000000010000000180025095) {
    	                if (input[16] > 2.5000000000000004) {
    	                    var4 = -0.36419540643116516;
    	                }
    	                else {
    	                    var4 = 0.2460520670594026;
    	                }
    	            }
    	            else {
    	                var4 = -0.3367924456612277;
    	            }
    	        }
    	    }
    	    else {
    	        if (input[14] > 0.36650000000000005) {
    	            if (input[4] > 0.000000000000000000000000000000000010000000180025095) {
    	                var4 = 0.28345207909064335;
    	            }
    	            else {
    	                if (input[0] > 0.015600000000000001) {
    	                    if (input[9] > 0.000000000000000000000000000000000010000000180025095) {
    	                        var4 = -0.24838128883453983;
    	                    }
    	                    else {
    	                        var4 = 0.09707899980618082;
    	                    }
    	                }
    	                else {
    	                    var4 = 0.20131422070889;
    	                }
    	            }
    	        }
    	        else {
    	            if (input[23] > 0.05965000000000001) {
    	                var4 = -0.37547264102025585;
    	            }
    	            else {
    	                var4 = 0.0810892751188778;
    	            }
    	        }
    	    }
    	    var var5;
    	    if (input[0] > 0.04180000000000001) {
    	        if (input[4] > 0.000000000000000000000000000000000010000000180025095) {
    	            var5 = 0.18906102884164802;
    	        }
    	        else {
    	            if (input[1] > 0.000000000000000000000000000000000010000000180025095) {
    	                var5 = 0.10706495684378672;
    	            }
    	            else {
    	                var5 = -0.3107537263648854;
    	            }
    	        }
    	    }
    	    else {
    	        if (input[14] > 0.6360000000000001) {
    	            if (input[5] > 9.500000000000002) {
    	                if (input[25] > 7.500000000000001) {
    	                    var5 = -0.08841542496220378;
    	                }
    	                else {
    	                    var5 = 0.23469576042808096;
    	                }
    	            }
    	            else {
    	                var5 = -0.3215025303420846;
    	            }
    	        }
    	        else {
    	            if (input[8] > 0.7120000000000001) {
    	                if (input[0] > 0.025450000000000004) {
    	                    var5 = -0.4091431298411297;
    	                }
    	                else {
    	                    if (input[8] > 0.9885) {
    	                        var5 = -0.28395286460807606;
    	                    }
    	                    else {
    	                        var5 = 0.15032864846815958;
    	                    }
    	                }
    	            }
    	            else {
    	                var5 = -0.4427123990094048;
    	            }
    	        }
    	    }
    	    var var6;
    	    if (input[0] > 0.03930000000000001) {
    	        if (input[2] > 0.000000000000000000000000000000000010000000180025095) {
    	            if (input[16] > 2.5000000000000004) {
    	                var6 = -0.1765779709714201;
    	            }
    	            else {
    	                var6 = 0.24201638210156784;
    	            }
    	        }
    	        else {
    	            if (input[1] > 0.000000000000000000000000000000000010000000180025095) {
    	                var6 = 0.15979082164341352;
    	            }
    	            else {
    	                var6 = -0.303134946025143;
    	            }
    	        }
    	    }
    	    else {
    	        if (input[14] > 0.6235) {
    	            if (input[4] > 0.000000000000000000000000000000000010000000180025095) {
    	                var6 = 0.2400117633526591;
    	            }
    	            else {
    	                if (input[42] > 0.03885) {
    	                    var6 = 0.17426533804939368;
    	                }
    	                else {
    	                    if (input[0] > 0.00012550000000000004) {
    	                        var6 = -0.1987004473163668;
    	                    }
    	                    else {
    	                        var6 = 0.12768726192318056;
    	                    }
    	                }
    	            }
    	        }
    	        else {
    	            if (input[5] > 38.50000000000001) {
    	                var6 = 0.006765478874928358;
    	            }
    	            else {
    	                var6 = -0.35725927493461507;
    	            }
    	        }
    	    }
    	    var var7;
    	    if (input[0] > 0.41350000000000003) {
    	        var7 = -0.30973658543227217;
    	    }
    	    else {
    	        if (input[42] > 0.0069050000000000005) {
    	            if (input[35] > 6.500000000000001) {
    	                if (input[42] > 0.028050000000000002) {
    	                    var7 = -0.09406650998558472;
    	                }
    	                else {
    	                    var7 = -1.1938171660986683;
    	                }
    	            }
    	            else {
    	                if (input[23] > 0.14350000000000002) {
    	                    var7 = -0.049546610372964164;
    	                }
    	                else {
    	                    if (input[10] > 4.235000000000001) {
    	                        if (input[38] > 3.5000000000000004) {
    	                            if (input[5] > 208.50000000000003) {
    	                                var7 = -0.9098275222492331;
    	                            }
    	                            else {
    	                                var7 = 0.025905341884009874;
    	                            }
    	                        }
    	                        else {
    	                            var7 = 0.14504363690804517;
    	                        }
    	                    }
    	                    else {
    	                        var7 = 0.26108435682062164;
    	                    }
    	                }
    	            }
    	        }
    	        else {
    	            if (input[0] > 0.025450000000000004) {
    	                var7 = -0.26211719866073147;
    	            }
    	            else {
    	                var7 = 0.005367034783598244;
    	            }
    	        }
    	    }
    	    var var8;
    	    if (input[0] > 0.41350000000000003) {
    	        var8 = -0.29537087986604277;
    	    }
    	    else {
    	        if (input[1] > 0.000000000000000000000000000000000010000000180025095) {
    	            if (input[17] > 2.5000000000000004) {
    	                var8 = -0.21863127285609044;
    	            }
    	            else {
    	                var8 = 0.20806327084689888;
    	            }
    	        }
    	        else {
    	            if (input[7] > 0.000000000000000000000000000000000010000000180025095) {
    	                var8 = 0.23185589025210443;
    	            }
    	            else {
    	                if (input[0] > 0.006175000000000001) {
    	                    if (input[11] > 0.000000000000000000000000000000000010000000180025095) {
    	                        var8 = 0.21673724088807791;
    	                    }
    	                    else {
    	                        var8 = -0.20880542075557063;
    	                    }
    	                }
    	                else {
    	                    if (input[15] > 0.19750000000000004) {
    	                        var8 = -0.35558378216098435;
    	                    }
    	                    else {
    	                        if (input[5] > 169.50000000000003) {
    	                            var8 = 0.27503080741727437;
    	                        }
    	                        else {
    	                            if (input[38] > 1.5000000000000002) {
    	                                var8 = -0.41715499696108405;
    	                            }
    	                            else {
    	                                var8 = 0.07184928941144736;
    	                            }
    	                        }
    	                    }
    	                }
    	            }
    	        }
    	    }
    	    var var9;
    	    if (input[42] > 0.0069050000000000005) {
    	        if (input[15] > 0.31450000000000006) {
    	            if (input[16] > 1.5000000000000002) {
    	                var9 = -0.5200765889242452;
    	            }
    	            else {
    	                var9 = 0.0020640940867966643;
    	            }
    	        }
    	        else {
    	            if (input[37] > 5.500000000000001) {
    	                var9 = -0.2533007886322107;
    	            }
    	            else {
    	                if (input[42] > 0.20600000000000002) {
    	                    var9 = -0.16537764386776857;
    	                }
    	                else {
    	                    var9 = 0.14878962022678252;
    	                }
    	            }
    	        }
    	    }
    	    else {
    	        if (input[0] > 0.025450000000000004) {
    	            if (input[11] > 0.000000000000000000000000000000000010000000180025095) {
    	                var9 = 0.1470380035780921;
    	            }
    	            else {
    	                var9 = -0.30313629951297877;
    	            }
    	        }
    	        else {
    	            if (input[3] > 7.500000000000001) {
    	                var9 = 0.15767500525718478;
    	            }
    	            else {
    	                if (input[10] > 4.3950000000000005) {
    	                    var9 = -0.050580732249890424;
    	                }
    	                else {
    	                    var9 = -0.5314774609149354;
    	                }
    	            }
    	        }
    	    }
    	    var var10;
    	    if (input[0] > 0.41350000000000003) {
    	        var10 = -0.2701644232723916;
    	    }
    	    else {
    	        if (input[14] > 0.49750000000000005) {
    	            if (input[35] > 6.500000000000001) {
    	                if (input[15] > 0.14950000000000002) {
    	                    var10 = -0.6325872248796787;
    	                }
    	                else {
    	                    var10 = 0.1931227318207127;
    	                }
    	            }
    	            else {
    	                if (input[11] > 0.000000000000000000000000000000000010000000180025095) {
    	                    var10 = 0.2270772387054968;
    	                }
    	                else {
    	                    if (input[2] > 0.000000000000000000000000000000000010000000180025095) {
    	                        var10 = 0.11343718223214352;
    	                    }
    	                    else {
    	                        if (input[38] > 6.500000000000001) {
    	                            var10 = 0.4328449548724335;
    	                        }
    	                        else {
    	                            var10 = -0.07169940089874766;
    	                        }
    	                    }
    	                }
    	            }
    	        }
    	        else {
    	            if (input[42] > 0.04075000000000001) {
    	                if (input[42] > 0.10950000000000001) {
    	                    var10 = -0.3473305135141645;
    	                }
    	                else {
    	                    var10 = 0.22442888116215481;
    	                }
    	            }
    	            else {
    	                var10 = -0.35273651740368467;
    	            }
    	        }
    	    }
    	    var var11;
    	    var11 = sigmoid(var0 + var1 + var2 + var3 + var4 + var5 + var6 + var7 + var8 + var9 + var10);
    	    return [1.0 - var11, var11];
    	};
    	function sigmoid(x) {
    	    if (x < 0.0) {
    	        var z = Math.exp(x);
    	        return z / (1.0 + z);
    	    }
    	    return 1.0 / (1.0 + Math.exp(-x));
    	}
    	
    	return model$1;
    }

    var modelExports$1 = /*@__PURE__*/ requireModel$1();
    var Model$1 = /*@__PURE__*/getDefaultExportFromCjs(modelExports$1);

    /**
     * @classdesc Responsible for the feature and candidates extraction for the `footer` classification
     */
    class ClassifierLandmarksFooter extends ClassifierBase {
        /** @inheritDoc */
        static Model = Model$1;
        /**
         * The minimum score that will be considered "correct".
         */
        static ScoreThreshold = 0.5;
        static ModelFeatures = [
            "distance_from_bottom_of_page_percent",
            "is_tagname_footer",
            "indicative_word_copyright_sign",
            "num_of_links",
            "indicative_word_privacy_policy",
            "visible_text_content_length",
            "num_of_social_links",
            "indicative_word_copyright",
            "alpha_portion",
            "number_of_parent_with_tagname_footer",
            "aspect_ratio",
            "indicative_word_terms_and_conditions",
            "number_of_visible_div",
            "indicative_word_contact",
            "width_percentage",
            "height_percentage",
            "num_of_images",
            "num_of_inputs",
            "indicative_word_about",
            "indicative_word_blog",
            "indicative_word_careers",
            "indicative_word_home",
            "has_fixed_parent",
            "x_percentage",
            "indicative_word_address",
            "num_of_img",
            "indicative_word_powered",
            "indicative_word_faq",
            "number_of_visible_footer",
            "is_fixed",
            "indicative_word_support",
            "is_out_of_the_page",
            "indicative_word_search",
            "indicative_word_all_rights_reserved",
            "is_tagname_section",
            "have_img_larger_than_50_px",
            "number_of_parent_with_tagname_li",
            "number_of_parent_with_tagname_div",
            "number_of_visible_p",
            "number_of_visible_navs",
            "indicative_word_products",
            "is_tagname_div",
            "numeric_portion",
            "number_of_parent_with_tagname_ul",
        ];
        /**
         * Retrieves list of candidates, their features and label
         * @param types the classification types to extract the data for
         * @param expectedElementCssSelector the tagged/annotated element
         * @param maxNegativeSamples the amount of negative samples to include
         */
        static getFeaturesAndCandidates(types, expectedElementCssSelector, maxNegativeSamples = 2) {
            const response = {};
            for (const [index, type] of Object.entries(types)) {
                const correctCandidates = [];
                const incorrectCandidates = [];
                //const correctElement = getElementByXpath(expectedElementXpath[parseInt(index)]);
                const correctElement = document.querySelector(expectedElementCssSelector[index]);
                for (const rootElement of this.getAllRootElements()) {
                    for (const candidate of this.getCandidates(rootElement)) {
                        if (expectedElementCssSelector.some((cssSelector) => cssSelector !== expectedElementCssSelector[index] && candidate.isEqualNode(document.querySelector(cssSelector))))
                            continue;
                        const label = 1;
                        const row = {
                            candidate,
                            label: candidate === correctElement ? label : 0,
                            labelName: candidate === correctElement ? type : "unknown",
                            features: this.getFeatures(candidate),
                        };
                        row.label ? correctCandidates.push(row) : incorrectCandidates.push(row);
                    }
                }
                response[type] = [...correctCandidates, ...incorrectCandidates.slice(0, maxNegativeSamples)];
            }
            return response;
        }
        /**
         * The selector used to find the candidates for the `footer` classification
         * @private
         */
        static CandidatesSelector = `
    
        section, footer, nav, content,
        
        [id*=footer i]:not(li,a,button, input, textarea), 
        [id*=section i]:not(li,a,button, input, textarea), 
        [id*=navigation i]:not(li,a,button, input, textarea),
        [id*=bottom i]:not(li,a,button, input, textarea), 
        
        [class*=footer i]:not(li,a,button, input, textarea), 
        [class*=section i]:not(li,a,button, input, textarea), 
        [class*=navigation i]:not(li,a,button, input, textarea),
        [class*=bottom i]:not(li,a,button, input, textarea), 
      
        [role*=footer i]:not(li,a,button, input, textarea), 
        [role*=section i]:not(li,a,button, input, textarea), 
        [role*=navigation i]:not(li,a,button, input, textarea),
        [role*=bottom i]:not(li,a,button, input, textarea),   
        
        [aria-label*=footer i]:not(li,a,button, input, textarea), 
        [aria-label*=section i]:not(li,a,button, input, textarea), 
        [aria-label*=navigation i]:not(li,a,button, input, textarea)
        [aria-label*=bottom i]:not(li,a,button, input, textarea)
        `;
        /** @inheritDoc */
        static getCandidates(rootElement) {
            //Getting all the elements that matches the selector
            let matchedElements = Array.from(rootElement.querySelectorAll(this.CandidatesSelector));
            //Filtering out elements that are not visible or are not a descendent of the body
            matchedElements = matchedElements.filter(this.isElementVisible).filter(this.isBodyDescendent);
            return matchedElements;
        }
        /**
         * Retrieves the best predicted element of each of the given `type`s.
         * Query for candidates, calculates the prediction score and return the element with the highest
         * score if higher than the `ScoreThreshold` otherwise will return `null`
         */
        static predict() {
            let features = [];
            let candidates = [];
            for (const rootElement of this.getAllRootElements()) {
                candidates = candidates.concat(this.getCandidates(rootElement));
                features = features.concat(candidates.map((candidate) => this.getFeatures(candidate)));
            }
            //if (features.length === 0) continue;
            const scores = this.inference({ features });
            const th_score_size = 0.9;
            const highestScore = Math.max(...scores);
            const highestScoreIndex = scores.indexOf(highestScore);
            const scoredCandidates = scores.map((score, index) => ({
                score,
                index,
                size: features[index].height * features[index].width,
            }));
            const candidatesAboveThScoreSize = scoredCandidates.filter((item) => item.score > th_score_size);
            let selectedCandidateIndex;
            if (candidatesAboveThScoreSize.length > 0) {
                // Among candidates above th_score_size, select the one with the largest size
                selectedCandidateIndex = candidatesAboveThScoreSize.reduce((maxItem, currentItem) => (currentItem.size > maxItem.size ? currentItem : maxItem)).index;
            }
            else {
                // No candidates have score above th_score_size
                // Select the candidate with the highest score (regardless of size)
                selectedCandidateIndex = highestScoreIndex;
            }
            if (highestScore > this.ScoreThreshold) {
                return [candidates[selectedCandidateIndex]];
            }
            return [];
        }
        /**
         * Retrieves all the root elements from the page, including the document itself and all shadowDom root elements
         * @private
         */
        static getAllRootElements() {
            return [
                document,
                ...Array.from(document.querySelectorAll("*"))
                    .filter((element) => element.shadowRoot)
                    .map((element) => element.shadowRoot),
            ];
        }
        /**
         * Handles the inference of the given `features` using the model of the given `type`
         * loads the model and normalize the features
         * @param features the  features to normalize
         * @param type the type of the model to load
         */
        static inference({ features }) {
            const featuresAs3dArray = features.map((featureSet) => this.ModelFeatures.map((key) => featureSet[key]));
            const scores = [];
            for (const featureVector of featuresAs3dArray) {
                scores.push(Model$1(featureVector)[1]);
            }
            return scores;
        }
        /**
         * Determines whether given `element` is visible to the user
         */
        static isElementVisible(element) {
            const style = window.getComputedStyle(element);
            let visibleDimensions = true;
            if (element.offsetWidth <= 1 || element.offsetHeight <= 1) {
                visibleDimensions = false;
                for (const child of Array.from(element.querySelectorAll("*"))) {
                    if (child.offsetWidth > 1 && child.offsetHeight > 1) {
                        visibleDimensions = true;
                        break;
                    }
                }
            }
            return style.opacity !== "0" && style.visibility !== "hidden" && style.display !== "none" && visibleDimensions;
        }
        /**
         * Determines whether given `element` is a descendent of the body element
         * @param element
         */
        static isBodyDescendent(element) {
            return document.body !== element && document.documentElement !== element;
        }
        /**
         * Retrieves the bounding client rect of the given `element`
         * @param element
         */
        static getBoundingClientRect(element) {
            const rects = element.getBoundingClientRect();
            return {
                top: rects.top + window.scrollY,
                right: rects.right + window.scrollX,
                bottom: rects.bottom + window.scrollY,
                left: rects.left + window.scrollX,
                width: rects.width,
                height: rects.height,
            };
        }
        /**
         * Retrieves an object/list of features for given `element`
         * */
        static getFeatures(element) {
            const clientRect = this.getBoundingClientRect(element);
            const pageRect = {
                height: Math.max(document.body.scrollHeight, document.documentElement.scrollHeight),
                width: Math.max(document.body.scrollWidth, document.documentElement.scrollWidth),
            };
            const visibleChildren = Array.from(element.querySelectorAll("*")).filter(ClassifierBase.isElementVisible);
            const absoluteClientRect = this.calculateElementPositionAndDimensions(element);
            const content = [element, ...visibleChildren]
                .map((child) => {
                let response = "";
                for (const childNode of Array.from(child.childNodes)) {
                    if (childNode.nodeType === Node.TEXT_NODE) {
                        response += childNode.textContent;
                    }
                }
                return response.replace(/[\n\s]/g, "");
            })
                .join("")
                .replace(/\s/g, "");
            const lowerCasedContent = content.toLowerCase();
            const computedStyle = window.getComputedStyle(element);
            const viewport = {
                width: window.innerWidth || document.documentElement.clientWidth,
                height: window.innerHeight || document.documentElement.clientHeight,
            };
            const parents = ClassifierBase.getParents(element);
            const response = {};
            for (const [featureKey, featureProvider] of Object.entries(this.Features)) {
                if (!this.ModelFeatures.includes(featureKey)) {
                    continue;
                }
                response[featureKey] = featureProvider({
                    element,
                    content,
                    lowerCasedContent,
                    clientRect,
                    absoluteClientRect,
                    visibleChildren,
                    parents,
                    viewport,
                    pageRect,
                    computedStyle,
                });
                response[featureKey] = parseFloat(response[featureKey].toPrecision(3));
            }
            return response;
        }
        /**
         * Mapping of a dictionary key (english) to an array of its translations on every language
         */
        static MultilingualWords = Object.entries(wordsDictionary).reduce((acc, [language, words]) => {
            for (const [wordKey, wordValue] of Object.entries(words)) {
                acc[wordKey] = acc[wordKey] || [];
                acc[wordKey].push(wordValue.toLowerCase());
            }
            return acc;
        }, {});
        /**
         * List of features for this classification
         */
        static Features = {
            //Dimensions
            height: ({ absoluteClientRect }) => Math.min(1000, absoluteClientRect.height),
            width: ({ absoluteClientRect }) => Math.min(2500, absoluteClientRect.width),
            x: ({ absoluteClientRect }) => Math.min(Math.max(-100, absoluteClientRect.left), 2500),
            y: ({ absoluteClientRect }) => Math.min(Math.max(-100, absoluteClientRect.top), 2000),
            height_percentage: ({ pageRect, absoluteClientRect }) => (absoluteClientRect.height ? absoluteClientRect.height / pageRect.height : 0),
            width_percentage: ({ pageRect, absoluteClientRect }) => (absoluteClientRect.width ? absoluteClientRect.width / pageRect.width : 0),
            x_percentage: ({ pageRect, absoluteClientRect }) => (absoluteClientRect.left ? absoluteClientRect.left / pageRect.width : 0),
            y_percentage: ({ pageRect, absoluteClientRect }) => (absoluteClientRect.top ? absoluteClientRect.top / pageRect.height : 0),
            aspect_ratio: ({ absoluteClientRect }) => (absoluteClientRect.width && absoluteClientRect.height ? absoluteClientRect.width / absoluteClientRect.height : 0),
            //content
            upper_case_portion: ({ content }) => (content.length ? 1 - content.replace(/[A-Z]/g, "").length / content.length : 0),
            alpha_portion: ({ lowerCasedContent }) => (lowerCasedContent.length ? lowerCasedContent.replace(/[\d\s!@#$%^&*()-_\r\n]/g, "").length / lowerCasedContent.length : 0),
            numeric_portion: ({ lowerCasedContent }) => (lowerCasedContent.length ? (lowerCasedContent.length - lowerCasedContent.replace(/[\d\r\n]/g, "").length) / lowerCasedContent.length : 0),
            digit_count: ({ lowerCasedContent }) => lowerCasedContent.length - lowerCasedContent.replace(/[\d\r\n]/g, "").length,
            visible_text_content_length: ({ lowerCasedContent }) => Math.min(lowerCasedContent.length, 1000),
            //Dom elements
            num_of_inputs: ({ visibleChildren }) => visibleChildren.filter((element) => element.tagName === "INPUT").length,
            num_of_buttons: ({ visibleChildren }) => visibleChildren.filter((element) => element.tagName === "BUTTON").length,
            num_of_textareas: ({ visibleChildren }) => visibleChildren.filter((element) => element.tagName === "TEXTAREA").length,
            num_of_selects: ({ visibleChildren }) => visibleChildren.filter((element) => element.tagName === "SELECT").length,
            num_of_links: ({ visibleChildren }) => visibleChildren.filter((element) => element.tagName === "A").length,
            num_of_images: ({ visibleChildren }) => visibleChildren.filter(this.isImage).length,
            num_of_videos: ({ visibleChildren }) => visibleChildren.filter((element) => element.tagName === "VIDEO").length,
            num_of_iframes: ({ visibleChildren }) => visibleChildren.filter((element) => element.tagName === "IFRAME").length,
            num_of_svgs: ({ visibleChildren }) => visibleChildren.filter((element) => element.tagName === "SVG").length,
            num_of_img: ({ visibleChildren }) => visibleChildren.filter((element) => element.tagName === "IMG").length,
            num_of_video: ({ visibleChildren }) => visibleChildren.filter((element) => element.tagName === "VIDEO").length,
            num_of_other_elements: ({ visibleChildren }) => visibleChildren.filter((element) => element.matches(":not(input,button,textarea,select,a,img,video,iframe,p)")).length,
            num_of_social_links: ({ visibleChildren }) => visibleChildren.filter((element) => element.matches("a[href*=facebook], a[href*=twitter], a[href*=instagram], a[href*=youtube], a[href*=linkedin], a[href*=instagram] ")).length,
            //Existing words
            indicative_word_home: ({ lowerCasedContent }) => (new RegExp(ClassifierBase.MultilingualWords["Home"].join("|")).test(lowerCasedContent) ? 1 : 0),
            indicative_word_about: ({ lowerCasedContent }) => (new RegExp(ClassifierBase.MultilingualWords["About"].join("|")).test(lowerCasedContent) ? 1 : 0),
            indicative_word_services: ({ lowerCasedContent }) => (new RegExp(ClassifierBase.MultilingualWords["Services"].join("|")).test(lowerCasedContent) ? 1 : 0),
            indicative_word_products: ({ lowerCasedContent }) => (new RegExp(ClassifierBase.MultilingualWords["Products"].join("|")).test(lowerCasedContent) ? 1 : 0),
            indicative_word_contact: ({ lowerCasedContent }) => (new RegExp(ClassifierBase.MultilingualWords["Contact"].join("|")).test(lowerCasedContent) ? 1 : 0),
            indicative_word_blog: ({ lowerCasedContent }) => (new RegExp(ClassifierBase.MultilingualWords["Blog"].join("|")).test(lowerCasedContent) ? 1 : 0),
            indicative_word_shop: ({ lowerCasedContent }) => (new RegExp(ClassifierBase.MultilingualWords["Shop"].join("|")).test(lowerCasedContent) ? 1 : 0),
            indicative_word_faq: ({ lowerCasedContent }) => (new RegExp(ClassifierBase.MultilingualWords["FAQ"].join("|")).test(lowerCasedContent) ? 1 : 0),
            indicative_word_careers: ({ lowerCasedContent }) => (new RegExp(ClassifierBase.MultilingualWords["Careers"].join("|")).test(lowerCasedContent) ? 1 : 0),
            indicative_word_news: ({ lowerCasedContent }) => (new RegExp(ClassifierBase.MultilingualWords["News"].join("|")).test(lowerCasedContent) ? 1 : 0),
            indicative_word_testimonials: ({ lowerCasedContent }) => (new RegExp(ClassifierBase.MultilingualWords["Testimonials"].join("|")).test(lowerCasedContent) ? 1 : 0),
            indicative_word_portfolio: ({ lowerCasedContent }) => (new RegExp(ClassifierBase.MultilingualWords["Portfolio"].join("|")).test(lowerCasedContent) ? 1 : 0),
            indicative_word_support: ({ lowerCasedContent }) => (new RegExp(ClassifierBase.MultilingualWords["Support"].join("|")).test(lowerCasedContent) ? 1 : 0),
            indicative_word_events: ({ lowerCasedContent }) => (new RegExp(ClassifierBase.MultilingualWords["Events"].join("|")).test(lowerCasedContent) ? 1 : 0),
            indicative_word_gallery: ({ lowerCasedContent }) => (new RegExp(ClassifierBase.MultilingualWords["Gallery"].join("|")).test(lowerCasedContent) ? 1 : 0),
            indicative_word_team: ({ lowerCasedContent }) => (new RegExp(ClassifierBase.MultilingualWords["Team"].join("|")).test(lowerCasedContent) ? 1 : 0),
            indicative_word_pricing: ({ lowerCasedContent }) => (new RegExp(ClassifierBase.MultilingualWords["Pricing"].join("|")).test(lowerCasedContent) ? 1 : 0),
            indicative_word_copyright: ({ lowerCasedContent }) => (new RegExp(ClassifierBase.MultilingualWords["Copyright"].join("|")).test(lowerCasedContent) ? 1 : 0),
            indicative_word_tel: ({ lowerCasedContent }) => (new RegExp(ClassifierBase.MultilingualWords["Tel"].join("|")).test(lowerCasedContent) ? 1 : 0),
            indicative_word_address: ({ lowerCasedContent }) => (new RegExp(ClassifierBase.MultilingualWords["Address"].join("|")).test(lowerCasedContent) ? 1 : 0),
            indicative_word_terms_and_conditions: ({ lowerCasedContent }) => (new RegExp(ClassifierBase.MultilingualWords["TermsAndCondition"].join("|")).test(lowerCasedContent) ? 1 : 0),
            indicative_word_privacy_policy: ({ lowerCasedContent }) => (new RegExp(ClassifierBase.MultilingualWords["PrivacyPolicy"].join("|")).test(lowerCasedContent) ? 1 : 0),
            indicative_word_powered: ({ lowerCasedContent }) => (new RegExp(ClassifierBase.MultilingualWords["Powered"].join("|")).test(lowerCasedContent) ? 1 : 0),
            indicative_word_search: ({ lowerCasedContent }) => (new RegExp(ClassifierBase.MultilingualWords["Search"].join("|")).test(lowerCasedContent) ? 1 : 0),
            indicative_word_all_rights_reserved: ({ lowerCasedContent }) => (new RegExp(ClassifierBase.MultilingualWords["All_rights_reserved"].join("|")).test(lowerCasedContent) ? 1 : 0),
            indicative_word_copyright_sign: ({ lowerCasedContent }) => (lowerCasedContent.indexOf("©") > -1 ? 1 : 0),
            distance_from_bottom_of_page: ({ clientRect, pageRect }) => Math.max(0, pageRect.height - clientRect.bottom),
            distance_from_bottom_of_page_percent: ({ clientRect, pageRect }) => Math.max(0, pageRect.height - clientRect.bottom) / pageRect.height,
            is_out_of_the_page: ({ absoluteClientRect, pageRect }) => (absoluteClientRect.bottom - 20 < 0 || absoluteClientRect.right - 20 < 0 || absoluteClientRect.top + 20 > pageRect.height || absoluteClientRect.left + 20 > pageRect.width ? 1 : 0),
            /**
             * Determine whether given element is hidden due to being overflowed relative to one of it's parents that has `overflow: hidden`
             */
            is_overflowing: ({ clientRect, parents }) => {
                for (const parent of parents) {
                    const style = window.getComputedStyle(parent);
                    if (style.overflow === "hidden") {
                        const parentClientRect = parent.getBoundingClientRect();
                        if (clientRect.top + 20 < parentClientRect.top || clientRect.bottom - 20 > parentClientRect.bottom || clientRect.left + 20 < parentClientRect.left || clientRect.right - 20 > parentClientRect.right) {
                            return 1;
                        }
                    }
                }
                return 0;
            },
            is_in_fold: ({ absoluteClientRect, viewport }) => (absoluteClientRect.top < viewport.height ? 1 : 0),
            is_fixed: ({ computedStyle }) => (computedStyle.position === "fixed" ? 1 : 0),
            has_fixed_parent: ({ parents }) => (parents.filter((element) => window.getComputedStyle(element).position === "fixed").length ? 1 : 0),
            is_tagname_ul: ({ element }) => (element.tagName === "UL" ? 1 : 0),
            is_tagname_ol: ({ element }) => (element.tagName === "OL" ? 1 : 0),
            is_tagname_li: ({ element }) => (element.tagName === "LI" ? 1 : 0),
            is_tagname_nav: ({ element }) => (element.tagName === "NAV" ? 1 : 0),
            is_tagname_p: ({ element }) => (element.tagName === "P" ? 1 : 0),
            is_tagname_menu: ({ element }) => (element.tagName === "MENU" ? 1 : 0),
            is_tagname_header: ({ element }) => (element.tagName === "HEADER" ? 1 : 0),
            is_tagname_footer: ({ element }) => (element.tagName === "FOOTER" ? 1 : 0),
            is_tagname_section: ({ element }) => (element.tagName === "SECTION" ? 1 : 0),
            is_tagname_content: ({ element }) => (element.tagName === "CONTENT" ? 1 : 0),
            is_tagname_div: ({ element }) => (element.tagName === "DIV" ? 1 : 0),
            number_of_parent_with_tagname_ul: ({ parents }) => parents.filter((element) => element.tagName === "UL").length,
            number_of_parent_with_tagname_ol: ({ parents }) => parents.filter((element) => element.tagName === "OL").length,
            number_of_parent_with_tagname_li: ({ parents }) => parents.filter((element) => element.tagName === "LI").length,
            number_of_parent_with_tagname_nav: ({ parents }) => parents.filter((element) => element.tagName === "NAV").length,
            number_of_parent_with_tagname_p: ({ parents }) => parents.filter((element) => element.tagName === "P").length,
            number_of_parent_with_tagname_menu: ({ parents }) => parents.filter((element) => element.tagName === "MENU").length,
            number_of_parent_with_tagname_header: ({ parents }) => parents.filter((element) => element.tagName === "HEADER").length,
            number_of_parent_with_tagname_footer: ({ parents }) => parents.filter((element) => element.tagName === "FOOTER").length,
            number_of_parent_with_tagname_section: ({ parents }) => parents.filter((element) => element.tagName === "SECTION").length,
            number_of_parent_with_tagname_content: ({ parents }) => parents.filter((element) => element.tagName === "CONTENT").length,
            number_of_parent_with_tagname_div: ({ parents }) => parents.filter((element) => element.tagName === "DIV").length,
            number_of_visible_headers: ({ visibleChildren }) => visibleChildren.filter((element) => element.tagName === "HEADER").length,
            number_of_visible_uls: ({ visibleChildren }) => visibleChildren.filter((element) => element.tagName === "UL").length,
            number_of_visible_ols: ({ visibleChildren }) => visibleChildren.filter((element) => element.tagName === "OL").length,
            number_of_visible_p: ({ visibleChildren }) => visibleChildren.filter((element) => element.tagName === "P").length,
            number_of_visible_lis: ({ visibleChildren }) => visibleChildren.filter((element) => element.tagName === "LI").length,
            number_of_visible_navs: ({ visibleChildren }) => visibleChildren.filter((element) => element.tagName === "NAV").length,
            number_of_visible_menus: ({ visibleChildren }) => visibleChildren.filter((element) => element.tagName === "MENU").length,
            number_of_visible_footer: ({ visibleChildren }) => visibleChildren.filter((element) => element.tagName === "FOOTER").length,
            number_of_visible_section: ({ visibleChildren }) => visibleChildren.filter((element) => element.tagName === "SECTION").length,
            number_of_visible_content: ({ visibleChildren }) => visibleChildren.filter((element) => element.tagName === "CONTENT").length,
            number_of_visible_div: ({ visibleChildren }) => visibleChildren.filter((element) => element.tagName === "DIV").length,
            number_of_visible_elements: ({ visibleChildren }) => visibleChildren.length,
            number_of_visible_direct_children: ({ visibleChildren, element }) => visibleChildren.filter((element) => element.parentElement === element).length,
            have_img_larger_than_50_px: ({ visibleChildren }) => visibleChildren.filter((element) => this.isImage(element) && (element.height > 50 || element.width > 50)).length,
            have_img_larger_than_100_px: ({ visibleChildren }) => visibleChildren.filter((element) => this.isImage(element) && (element.height > 100 || element.width > 100)).length,
            parents_count: ({ parents }) => parents.length,
            font_size: ({ computedStyle }) => parseInt(computedStyle.fontSize),
            font_weight: ({ computedStyle }) => parseInt(computedStyle.fontWeight),
        };
    }

    var model;
    var hasRequiredModel;

    function requireModel () {
    	if (hasRequiredModel) return model;
    	hasRequiredModel = 1;
    	model = function score(input) {
    	    var var0;
    	    if (input[0] > 0.000000000000000000000000000000000010000000180025095) {
    	        if (input[15] > 0.19950000000000004) {
    	            if (input[4] > 0.20850000000000002) {
    	                if (input[7] > 4.500000000000001) {
    	                    var0 = -0.5657232451275721;
    	                }
    	                else {
    	                    var0 = 0.20509059587386685;
    	                }
    	            }
    	            else {
    	                if (input[1] > 0.6935000000000001) {
    	                    if (input[3] > 2.5000000000000004) {
    	                        if (input[14] > 13.500000000000002) {
    	                            var0 = 0.5661993008037507;
    	                        }
    	                        else {
    	                            var0 = -0.16269098616159713;
    	                        }
    	                    }
    	                    else {
    	                        if (input[1] > 0.9415000000000001) {
    	                            if (input[13] > 9.500000000000002) {
    	                                var0 = 0.5253341056132232;
    	                            }
    	                            else {
    	                                if (input[20] > 0.34450000000000003) {
    	                                    var0 = 0.4477256796186456;
    	                                }
    	                                else {
    	                                    var0 = -0.46095409973970175;
    	                                }
    	                            }
    	                        }
    	                        else {
    	                            var0 = -0.6000000837956512;
    	                        }
    	                    }
    	                }
    	                else {
    	                    if (input[20] > 0.05945000000000001) {
    	                        var0 = -0.560281967214613;
    	                    }
    	                    else {
    	                        var0 = 0.08064867905798201;
    	                    }
    	                }
    	            }
    	        }
    	        else {
    	            if (input[11] > 0.000000000000000000000000000000000010000000180025095) {
    	                if (input[9] > 4.245000000000001) {
    	                    var0 = 0.503749908785924;
    	                }
    	                else {
    	                    if (input[9] > 0.49800000000000005) {
    	                        var0 = -0.6000000837956511;
    	                    }
    	                    else {
    	                        var0 = 0.38521607994940643;
    	                    }
    	                }
    	            }
    	            else {
    	                if (input[5] > 0.000000000000000000000000000000000010000000180025095) {
    	                    var0 = -0.09374114988785442;
    	                }
    	                else {
    	                    if (input[9] > 9.305000000000001) {
    	                        if (input[1] > 0.9845) {
    	                            var0 = -0.6000000837956511;
    	                        }
    	                        else {
    	                            var0 = 0.1255048562189821;
    	                        }
    	                    }
    	                    else {
    	                        var0 = -0.5489167689566992;
    	                    }
    	                }
    	            }
    	        }
    	    }
    	    else {
    	        if (input[3] > 1.5000000000000002) {
    	            if (input[8] > 0.000000000000000000000000000000000010000000180025095) {
    	                if (input[20] > 0.18850000000000003) {
    	                    if (input[1] > 0.8675) {
    	                        if (input[1] > 0.9815000000000002) {
    	                            if (input[15] > 0.6540000000000001) {
    	                                var0 = 0.20509059587386705;
    	                            }
    	                            else {
    	                                var0 = -0.4307146384570202;
    	                            }
    	                        }
    	                        else {
    	                            if (input[9] > 13.15) {
    	                                if (input[18] > 0.000000000000000000000000000000000010000000180025095) {
    	                                    var0 = -0.5424146966881832;
    	                                }
    	                                else {
    	                                    if (input[6] > 1.5000000000000002) {
    	                                        var0 = -0.08654509306646395;
    	                                    }
    	                                    else {
    	                                        var0 = -0.6000000837956507;
    	                                    }
    	                                }
    	                            }
    	                            else {
    	                                if (input[9] > 12.550000000000002) {
    	                                    var0 = 0.4383144561716601;
    	                                }
    	                                else {
    	                                    var0 = -0.057139306376624364;
    	                                }
    	                            }
    	                        }
    	                    }
    	                    else {
    	                        var0 = -0.5693496762667464;
    	                    }
    	                }
    	                else {
    	                    if (input[6] > 2.5000000000000004) {
    	                        if (input[9] > 32.65000000000001) {
    	                            var0 = -0.6000000837956512;
    	                        }
    	                        else {
    	                            if (input[9] > 17.350000000000005) {
    	                                if (input[1] > 0.9835000000000002) {
    	                                    var0 = -0.500976681287635;
    	                                }
    	                                else {
    	                                    var0 = -0.05271100244655879;
    	                                }
    	                            }
    	                            else {
    	                                var0 = -0.42959160457099355;
    	                            }
    	                        }
    	                    }
    	                    else {
    	                        if (input[18] > 0.000000000000000000000000000000000010000000180025095) {
    	                            var0 = -0.6000000837956512;
    	                        }
    	                        else {
    	                            var0 = -0.4585723808604182;
    	                        }
    	                    }
    	                }
    	            }
    	            else {
    	                if (input[15] > 0.9995000000000002) {
    	                    var0 = -0.6000000837956512;
    	                }
    	                else {
    	                    if (input[3] > 3.5000000000000004) {
    	                        if (input[1] > 0.49550000000000005) {
    	                            if (input[4] > 0.06495000000000002) {
    	                                if (input[17] > 0.011950000000000002) {
    	                                    var0 = -0.6000000837956511;
    	                                }
    	                                else {
    	                                    var0 = 0.25733925244277167;
    	                                }
    	                            }
    	                            else {
    	                                if (input[9] > 5.075000000000001) {
    	                                    var0 = 0.4192707533745491;
    	                                }
    	                                else {
    	                                    var0 = 0.04101622512142477;
    	                                }
    	                            }
    	                        }
    	                        else {
    	                            var0 = -0.6000000837956512;
    	                        }
    	                    }
    	                    else {
    	                        if (input[5] > 0.000000000000000000000000000000000010000000180025095) {
    	                            var0 = 0.26861348356182563;
    	                        }
    	                        else {
    	                            var0 = -0.4257381112433863;
    	                        }
    	                    }
    	                }
    	            }
    	        }
    	        else {
    	            var0 = -0.5556932760095065;
    	        }
    	    }
    	    var var1;
    	    if (input[0] > 0.000000000000000000000000000000000010000000180025095) {
    	        if (input[15] > 0.18950000000000003) {
    	            if (input[3] > 3.5000000000000004) {
    	                if (input[1] > 0.6185000000000002) {
    	                    if (input[4] > 0.09770000000000002) {
    	                        var1 = 0.1764416953499169;
    	                    }
    	                    else {
    	                        var1 = 0.436207823747846;
    	                    }
    	                }
    	                else {
    	                    if (input[5] > 0.000000000000000000000000000000000010000000180025095) {
    	                        var1 = 0.19540688885051719;
    	                    }
    	                    else {
    	                        var1 = -0.4302971835340316;
    	                    }
    	                }
    	            }
    	            else {
    	                if (input[4] > 0.04070000000000001) {
    	                    var1 = -0.45680095028104784;
    	                }
    	                else {
    	                    if (input[1] > 0.8505000000000001) {
    	                        if (input[5] > 0.000000000000000000000000000000000010000000180025095) {
    	                            var1 = 0.4542214017891795;
    	                        }
    	                        else {
    	                            if (input[20] > 0.23450000000000001) {
    	                                var1 = 0.3257888163916263;
    	                            }
    	                            else {
    	                                if (input[14] > 44.50000000000001) {
    	                                    var1 = 0.2832220232280625;
    	                                }
    	                                else {
    	                                    var1 = -0.22491492335691532;
    	                                }
    	                            }
    	                        }
    	                    }
    	                    else {
    	                        var1 = -0.49923799279501124;
    	                    }
    	                }
    	            }
    	        }
    	        else {
    	            if (input[11] > 0.000000000000000000000000000000000010000000180025095) {
    	                if (input[20] > 0.15650000000000003) {
    	                    var1 = -0.12492731675141244;
    	                }
    	                else {
    	                    var1 = 0.38583491883656557;
    	                }
    	            }
    	            else {
    	                var1 = -0.37603754089100905;
    	            }
    	        }
    	    }
    	    else {
    	        if (input[3] > 1.5000000000000002) {
    	            if (input[8] > 0.000000000000000000000000000000000010000000180025095) {
    	                if (input[10] > 0.000000000000000000000000000000000010000000180025095) {
    	                    if (input[18] > 0.000000000000000000000000000000000010000000180025095) {
    	                        if (input[6] > 2.5000000000000004) {
    	                            if (input[20] > 0.015550000000000001) {
    	                                if (input[13] > 19.500000000000004) {
    	                                    if (input[14] > 74.50000000000001) {
    	                                        var1 = -0.38358334062788035;
    	                                    }
    	                                    else {
    	                                        var1 = 0.18270526781097626;
    	                                    }
    	                                }
    	                                else {
    	                                    var1 = -0.423511839927198;
    	                                }
    	                            }
    	                            else {
    	                                var1 = -0.5011348305367364;
    	                            }
    	                        }
    	                        else {
    	                            var1 = -0.45495479468022443;
    	                        }
    	                    }
    	                    else {
    	                        if (input[10] > 3.5000000000000004) {
    	                            if (input[13] > 63.50000000000001) {
    	                                if (input[13] > 73.50000000000001) {
    	                                    var1 = -0.35394738917808716;
    	                                }
    	                                else {
    	                                    var1 = 0.2609100706681385;
    	                                }
    	                            }
    	                            else {
    	                                var1 = -0.43284747643496774;
    	                            }
    	                        }
    	                        else {
    	                            if (input[1] > 0.9035000000000001) {
    	                                if (input[13] > 19.500000000000004) {
    	                                    if (input[13] > 41.50000000000001) {
    	                                        var1 = -0.5043771541245943;
    	                                    }
    	                                    else {
    	                                        if (input[10] > 2.5000000000000004) {
    	                                            var1 = 0.16859824312482727;
    	                                        }
    	                                        else {
    	                                            if (input[17] > 0.038450000000000005) {
    	                                                var1 = 0.26491669077874574;
    	                                            }
    	                                            else {
    	                                                var1 = -0.2636001932217632;
    	                                            }
    	                                        }
    	                                    }
    	                                }
    	                                else {
    	                                    var1 = -0.30661602165925567;
    	                                }
    	                            }
    	                            else {
    	                                var1 = -0.4521913249391868;
    	                            }
    	                        }
    	                    }
    	                }
    	                else {
    	                    if (input[14] > 59.50000000000001) {
    	                        var1 = -0.28986421928120604;
    	                    }
    	                    else {
    	                        if (input[1] > 0.9835000000000002) {
    	                            var1 = -0.34582159608778495;
    	                        }
    	                        else {
    	                            if (input[15] > 0.5925000000000001) {
    	                                var1 = 0.25284762985760095;
    	                            }
    	                            else {
    	                                if (input[20] > 0.26050000000000006) {
    	                                    var1 = 0.02671630612052997;
    	                                }
    	                                else {
    	                                    var1 = -0.3537003564429539;
    	                                }
    	                            }
    	                        }
    	                    }
    	                }
    	            }
    	            else {
    	                if (input[15] > 0.8340000000000001) {
    	                    var1 = -0.3824429547956966;
    	                }
    	                else {
    	                    if (input[3] > 3.5000000000000004) {
    	                        if (input[1] > 0.49550000000000005) {
    	                            if (input[21] > 0.000000000000000000000000000000000010000000180025095) {
    	                                var1 = -0.05029096351657191;
    	                            }
    	                            else {
    	                                var1 = 0.3236724053144212;
    	                            }
    	                        }
    	                        else {
    	                            var1 = -0.46464347041550735;
    	                        }
    	                    }
    	                    else {
    	                        if (input[17] > 0.018250000000000006) {
    	                            var1 = -0.5058186216523065;
    	                        }
    	                        else {
    	                            if (input[4] > 0.020050000000000002) {
    	                                var1 = -0.4959862142181104;
    	                            }
    	                            else {
    	                                var1 = 0.20652138001522166;
    	                            }
    	                        }
    	                    }
    	                }
    	            }
    	        }
    	        else {
    	            var1 = -0.42428617035915284;
    	        }
    	    }
    	    var var2;
    	    if (input[0] > 0.000000000000000000000000000000000010000000180025095) {
    	        if (input[15] > 0.18950000000000003) {
    	            if (input[3] > 3.5000000000000004) {
    	                if (input[1] > 0.32550000000000007) {
    	                    if (input[4] > 0.11450000000000002) {
    	                        if (input[13] > 17.500000000000004) {
    	                            var2 = -0.19572055566127225;
    	                        }
    	                        else {
    	                            var2 = 0.360381003038679;
    	                        }
    	                    }
    	                    else {
    	                        if (input[22] > 2.5000000000000004) {
    	                            if (input[3] > 23.500000000000004) {
    	                                var2 = 0.38259492519621435;
    	                            }
    	                            else {
    	                                var2 = -0.19653833655996253;
    	                            }
    	                        }
    	                        else {
    	                            var2 = 0.3727670032681199;
    	                        }
    	                    }
    	                }
    	                else {
    	                    var2 = -0.3691182593369424;
    	                }
    	            }
    	            else {
    	                if (input[4] > 0.14350000000000002) {
    	                    var2 = -0.4196850420207869;
    	                }
    	                else {
    	                    if (input[1] > 0.9365000000000002) {
    	                        if (input[14] > 11.500000000000002) {
    	                            var2 = 0.27723781664286273;
    	                        }
    	                        else {
    	                            var2 = -0.11378953115110232;
    	                        }
    	                    }
    	                    else {
    	                        var2 = -0.32479171895631176;
    	                    }
    	                }
    	            }
    	        }
    	        else {
    	            if (input[3] > 5.500000000000001) {
    	                if (input[12] > 0.000000000000000000000000000000000010000000180025095) {
    	                    var2 = -0.45918277654286094;
    	                }
    	                else {
    	                    if (input[20] > 0.14150000000000001) {
    	                        if (input[13] > 23.500000000000004) {
    	                            var2 = 0.2009479106455573;
    	                        }
    	                        else {
    	                            var2 = -0.4405154737896784;
    	                        }
    	                    }
    	                    else {
    	                        var2 = 0.577120676650587;
    	                    }
    	                }
    	            }
    	            else {
    	                if (input[5] > 0.000000000000000000000000000000000010000000180025095) {
    	                    var2 = 0.01677491668353301;
    	                }
    	                else {
    	                    var2 = -0.354961108486362;
    	                }
    	            }
    	        }
    	    }
    	    else {
    	        if (input[13] > 3.5000000000000004) {
    	            if (input[20] > 0.015550000000000001) {
    	                if (input[1] > 0.8005000000000001) {
    	                    if (input[8] > 0.000000000000000000000000000000000010000000180025095) {
    	                        if (input[1] > 0.9915000000000002) {
    	                            var2 = -0.36853723637315194;
    	                        }
    	                        else {
    	                            if (input[14] > 440.50000000000006) {
    	                                var2 = 0.3907497216727994;
    	                            }
    	                            else {
    	                                if (input[10] > 5.500000000000001) {
    	                                    if (input[9] > 31.750000000000004) {
    	                                        var2 = 0.16306181820945848;
    	                                    }
    	                                    else {
    	                                        var2 = -0.46437933213305127;
    	                                    }
    	                                }
    	                                else {
    	                                    if (input[9] > 29.950000000000003) {
    	                                        var2 = -0.3881841653619871;
    	                                    }
    	                                    else {
    	                                        if (input[18] > 0.000000000000000000000000000000000010000000180025095) {
    	                                            if (input[13] > 24.500000000000004) {
    	                                                if (input[17] > 0.02825) {
    	                                                    var2 = 0.46180330686077775;
    	                                                }
    	                                                else {
    	                                                    var2 = -0.1272554665229333;
    	                                                }
    	                                            }
    	                                            else {
    	                                                var2 = -0.26454122189716717;
    	                                            }
    	                                        }
    	                                        else {
    	                                            if (input[17] > 0.06185000000000001) {
    	                                                var2 = -0.49453379996541985;
    	                                            }
    	                                            else {
    	                                                var2 = 0.0035620585755986927;
    	                                            }
    	                                        }
    	                                    }
    	                                }
    	                            }
    	                        }
    	                    }
    	                    else {
    	                        if (input[5] > 0.000000000000000000000000000000000010000000180025095) {
    	                            var2 = 0.3243712442706916;
    	                        }
    	                        else {
    	                            if (input[4] > 0.06495000000000002) {
    	                                var2 = -0.4193838976734883;
    	                            }
    	                            else {
    	                                if (input[15] > 0.2745000000000001) {
    	                                    if (input[3] > 2.5000000000000004) {
    	                                        var2 = 0.29469427993447445;
    	                                    }
    	                                    else {
    	                                        var2 = -0.2363712292045525;
    	                                    }
    	                                }
    	                                else {
    	                                    if (input[6] > 5.500000000000001) {
    	                                        if (input[14] > 7.500000000000001) {
    	                                            var2 = 0.4991525277488537;
    	                                        }
    	                                        else {
    	                                            var2 = -0.13201419758963928;
    	                                        }
    	                                    }
    	                                    else {
    	                                        var2 = -0.43313775768857926;
    	                                    }
    	                                }
    	                            }
    	                        }
    	                    }
    	                }
    	                else {
    	                    var2 = -0.3985277961200667;
    	                }
    	            }
    	            else {
    	                if (input[11] > 0.000000000000000000000000000000000010000000180025095) {
    	                    if (input[14] > 43.50000000000001) {
    	                        var2 = -0.270599682652973;
    	                    }
    	                    else {
    	                        if (input[10] > 8.500000000000002) {
    	                            var2 = -0.42192197101612633;
    	                        }
    	                        else {
    	                            var2 = 0.11791955006251514;
    	                        }
    	                    }
    	                }
    	                else {
    	                    var2 = -0.3625357069177414;
    	                }
    	            }
    	        }
    	        else {
    	            if (input[28] > 250.00000000000003) {
    	                var2 = -0.39487737998553024;
    	            }
    	            else {
    	                var2 = 0.18593467161869;
    	            }
    	        }
    	    }
    	    var var3;
    	    if (input[0] > 0.000000000000000000000000000000000010000000180025095) {
    	        if (input[15] > 0.21550000000000002) {
    	            if (input[1] > 0.7675000000000002) {
    	                if (input[4] > 0.28950000000000004) {
    	                    var3 = -0.34435833181580927;
    	                }
    	                else {
    	                    if (input[3] > 2.5000000000000004) {
    	                        if (input[1] > 0.9925) {
    	                            if (input[9] > 7.285000000000001) {
    	                                var3 = 0.20871656316155998;
    	                            }
    	                            else {
    	                                var3 = -0.4276770288582315;
    	                            }
    	                        }
    	                        else {
    	                            var3 = 0.33547650415008506;
    	                        }
    	                    }
    	                    else {
    	                        if (input[9] > 8.195000000000002) {
    	                            if (input[13] > 7.500000000000001) {
    	                                var3 = 0.31300447207860826;
    	                            }
    	                            else {
    	                                var3 = -0.09946581150039054;
    	                            }
    	                        }
    	                        else {
    	                            var3 = -0.29341052965006814;
    	                        }
    	                    }
    	                }
    	            }
    	            else {
    	                if (input[43] > 0.000000000000000000000000000000000010000000180025095) {
    	                    var3 = 0.3157024630926202;
    	                }
    	                else {
    	                    var3 = -0.28920489544568523;
    	                }
    	            }
    	        }
    	        else {
    	            if (input[2] > 0.000000000000000000000000000000000010000000180025095) {
    	                var3 = -0.3954373033218305;
    	            }
    	            else {
    	                if (input[22] > 0.000000000000000000000000000000000010000000180025095) {
    	                    var3 = -0.40186698792023534;
    	                }
    	                else {
    	                    if (input[1] > 0.5380000000000001) {
    	                        if (input[1] > 0.9905) {
    	                            var3 = -0.31576983000948194;
    	                        }
    	                        else {
    	                            if (input[15] > 0.14750000000000002) {
    	                                var3 = 0.33684748309235985;
    	                            }
    	                            else {
    	                                if (input[20] > 0.06535000000000002) {
    	                                    var3 = -0.1770257707450644;
    	                                }
    	                                else {
    	                                    var3 = 0.23270073062483834;
    	                                }
    	                            }
    	                        }
    	                    }
    	                    else {
    	                        var3 = -0.3556059633862881;
    	                    }
    	                }
    	            }
    	        }
    	    }
    	    else {
    	        if (input[13] > 3.5000000000000004) {
    	            if (input[15] > 0.9995000000000002) {
    	                if (input[10] > 0.000000000000000000000000000000000010000000180025095) {
    	                    var3 = -0.30534890258617664;
    	                }
    	                else {
    	                    if (input[17] > 0.03135000000000001) {
    	                        var3 = -0.4095794582187577;
    	                    }
    	                    else {
    	                        var3 = 0.24775024648043228;
    	                    }
    	                }
    	            }
    	            else {
    	                if (input[1] > 0.8745000000000002) {
    	                    if (input[4] > 0.17050000000000004) {
    	                        var3 = -0.4034788775882555;
    	                    }
    	                    else {
    	                        if (input[8] > 0.000000000000000000000000000000000010000000180025095) {
    	                            if (input[1] > 0.9915000000000002) {
    	                                var3 = -0.2967136855029927;
    	                            }
    	                            else {
    	                                if (input[14] > 440.50000000000006) {
    	                                    var3 = 0.3486274724803307;
    	                                }
    	                                else {
    	                                    if (input[20] > 0.19150000000000003) {
    	                                        if (input[10] > 4.500000000000001) {
    	                                            var3 = -0.4325811585809898;
    	                                        }
    	                                        else {
    	                                            if (input[18] > 0.000000000000000000000000000000000010000000180025095) {
    	                                                var3 = -0.13948362702113232;
    	                                            }
    	                                            else {
    	                                                if (input[20] > 0.20150000000000004) {
    	                                                    if (input[13] > 30.500000000000004) {
    	                                                        var3 = -0.45885819712203146;
    	                                                    }
    	                                                    else {
    	                                                        var3 = 0.02105700085607752;
    	                                                    }
    	                                                }
    	                                                else {
    	                                                    var3 = 0.35361907122633884;
    	                                                }
    	                                            }
    	                                        }
    	                                    }
    	                                    else {
    	                                        if (input[15] > 0.9685) {
    	                                            if (input[3] > 7.500000000000001) {
    	                                                var3 = -0.38809564316890705;
    	                                            }
    	                                            else {
    	                                                var3 = 0.5718609416659288;
    	                                            }
    	                                        }
    	                                        else {
    	                                            var3 = -0.21621777308302606;
    	                                        }
    	                                    }
    	                                }
    	                            }
    	                        }
    	                        else {
    	                            if (input[14] > 28.500000000000004) {
    	                                if (input[21] > 0.000000000000000000000000000000000010000000180025095) {
    	                                    if (input[17] > 0.014050000000000002) {
    	                                        var3 = -0.4654598782422363;
    	                                    }
    	                                    else {
    	                                        var3 = 0.14464536614730655;
    	                                    }
    	                                }
    	                                else {
    	                                    if (input[9] > 30.450000000000003) {
    	                                        if (input[1] > 0.9805) {
    	                                            var3 = -0.2578999909937127;
    	                                        }
    	                                        else {
    	                                            var3 = 0.364007017034855;
    	                                        }
    	                                    }
    	                                    else {
    	                                        var3 = 0.3242596238167756;
    	                                    }
    	                                }
    	                            }
    	                            else {
    	                                if (input[10] > 1.5000000000000002) {
    	                                    if (input[9] > 7.405000000000001) {
    	                                        var3 = -0.3282501649934689;
    	                                    }
    	                                    else {
    	                                        var3 = 0.16053958809168636;
    	                                    }
    	                                }
    	                                else {
    	                                    var3 = -0.4126341324611164;
    	                                }
    	                            }
    	                        }
    	                    }
    	                }
    	                else {
    	                    var3 = -0.29038862186650327;
    	                }
    	            }
    	        }
    	        else {
    	            var3 = -0.34427036826483925;
    	        }
    	    }
    	    var var4;
    	    if (input[0] > 0.000000000000000000000000000000000010000000180025095) {
    	        if (input[15] > 0.24650000000000002) {
    	            if (input[1] > 0.7675000000000002) {
    	                if (input[4] > 0.22800000000000004) {
    	                    var4 = -0.24624905205774406;
    	                }
    	                else {
    	                    if (input[1] > 0.9925) {
    	                        if (input[15] > 0.34550000000000003) {
    	                            var4 = 0.18043764283550381;
    	                        }
    	                        else {
    	                            var4 = -0.3421856503156368;
    	                        }
    	                    }
    	                    else {
    	                        if (input[21] > 1.5000000000000002) {
    	                            var4 = -0.006706009127018597;
    	                        }
    	                        else {
    	                            var4 = 0.30680442726074614;
    	                        }
    	                    }
    	                }
    	            }
    	            else {
    	                var4 = -0.17444970162112922;
    	            }
    	        }
    	        else {
    	            if (input[5] > 0.000000000000000000000000000000000010000000180025095) {
    	                if (input[1] > 0.6675000000000001) {
    	                    var4 = 0.27872327138041714;
    	                }
    	                else {
    	                    var4 = -0.1703511602570297;
    	                }
    	            }
    	            else {
    	                if (input[11] > 0.000000000000000000000000000000000010000000180025095) {
    	                    var4 = 0.13680472578707137;
    	                }
    	                else {
    	                    if (input[17] > 0.006985000000000001) {
    	                        var4 = -0.31299225774736694;
    	                    }
    	                    else {
    	                        if (input[17] > 0.005425000000000001) {
    	                            var4 = 0.23431970901233287;
    	                        }
    	                        else {
    	                            var4 = -0.25386433340605374;
    	                        }
    	                    }
    	                }
    	            }
    	        }
    	    }
    	    else {
    	        if (input[13] > 3.5000000000000004) {
    	            if (input[15] > 0.9995000000000002) {
    	                if (input[18] > 0.000000000000000000000000000000000010000000180025095) {
    	                    var4 = -0.35776104695946476;
    	                }
    	                else {
    	                    if (input[11] > 0.000000000000000000000000000000000010000000180025095) {
    	                        if (input[17] > 0.026750000000000006) {
    	                            if (input[3] > 20.500000000000004) {
    	                                var4 = 0.25932626403182324;
    	                            }
    	                            else {
    	                                var4 = -0.38631910039028045;
    	                            }
    	                        }
    	                        else {
    	                            if (input[14] > 86.50000000000001) {
    	                                var4 = -0.3929884438217208;
    	                            }
    	                            else {
    	                                if (input[6] > 3.5000000000000004) {
    	                                    var4 = 0.6126538029299132;
    	                                }
    	                                else {
    	                                    if (input[14] > 76.50000000000001) {
    	                                        var4 = 0.6079601450594894;
    	                                    }
    	                                    else {
    	                                        if (input[14] > 40.50000000000001) {
    	                                            var4 = -0.38513535598741316;
    	                                        }
    	                                        else {
    	                                            var4 = 0.23260369842586;
    	                                        }
    	                                    }
    	                                }
    	                            }
    	                        }
    	                    }
    	                    else {
    	                        if (input[42] > 1.5000000000000002) {
    	                            var4 = 0.19194274927136065;
    	                        }
    	                        else {
    	                            var4 = -0.3164405662033221;
    	                        }
    	                    }
    	                }
    	            }
    	            else {
    	                if (input[1] > 0.49550000000000005) {
    	                    if (input[4] > 0.17050000000000004) {
    	                        var4 = -0.37064028650937525;
    	                    }
    	                    else {
    	                        if (input[12] > 0.000000000000000000000000000000000010000000180025095) {
    	                            var4 = -0.4008352944164207;
    	                        }
    	                        else {
    	                            if (input[24] > 0.000000000000000000000000000000000010000000180025095) {
    	                                if (input[9] > 34.95000000000001) {
    	                                    var4 = 0.36072882356089203;
    	                                }
    	                                else {
    	                                    var4 = -0.3542437694324695;
    	                                }
    	                            }
    	                            else {
    	                                if (input[9] > 36.20000000000001) {
    	                                    var4 = -0.331799050615282;
    	                                }
    	                                else {
    	                                    if (input[8] > 0.000000000000000000000000000000000010000000180025095) {
    	                                        if (input[8] > 1.5000000000000002) {
    	                                            if (input[13] > 28.500000000000004) {
    	                                                if (input[1] > 0.9875000000000002) {
    	                                                    var4 = 0.33460600683503144;
    	                                                }
    	                                                else {
    	                                                    var4 = -0.226363136806578;
    	                                                }
    	                                            }
    	                                            else {
    	                                                var4 = 0.4238336439056018;
    	                                            }
    	                                        }
    	                                        else {
    	                                            if (input[6] > 1.5000000000000002) {
    	                                                var4 = -0.04087210144098969;
    	                                            }
    	                                            else {
    	                                                var4 = -0.23293714880127156;
    	                                            }
    	                                        }
    	                                    }
    	                                    else {
    	                                        if (input[3] > 2.5000000000000004) {
    	                                            if (input[42] > 0.000000000000000000000000000000000010000000180025095) {
    	                                                var4 = -0.16896269140554204;
    	                                            }
    	                                            else {
    	                                                if (input[15] > 0.23150000000000004) {
    	                                                    var4 = 0.25907401387695184;
    	                                                }
    	                                                else {
    	                                                    var4 = -0.07754567786207284;
    	                                                }
    	                                            }
    	                                        }
    	                                        else {
    	                                            if (input[20] > 0.7775000000000002) {
    	                                                var4 = 0.31455646369441254;
    	                                            }
    	                                            else {
    	                                                var4 = -0.1989934174509523;
    	                                            }
    	                                        }
    	                                    }
    	                                }
    	                            }
    	                        }
    	                    }
    	                }
    	                else {
    	                    var4 = -0.3641058362444607;
    	                }
    	            }
    	        }
    	        else {
    	            if (input[28] > 250.00000000000003) {
    	                var4 = -0.3258706950471014;
    	            }
    	            else {
    	                var4 = 0.25018230508268663;
    	            }
    	        }
    	    }
    	    var var5;
    	    if (input[0] > 0.000000000000000000000000000000000010000000180025095) {
    	        if (input[3] > 3.5000000000000004) {
    	            if (input[9] > 4.005000000000001) {
    	                if (input[1] > 0.18150000000000002) {
    	                    if (input[20] > 0.6105000000000002) {
    	                        var5 = -0.026494582014961045;
    	                    }
    	                    else {
    	                        if (input[1] > 0.9925) {
    	                            if (input[15] > 0.44950000000000007) {
    	                                var5 = 0.2543533908433658;
    	                            }
    	                            else {
    	                                var5 = -0.10146803829229188;
    	                            }
    	                        }
    	                        else {
    	                            var5 = 0.28956625612956977;
    	                        }
    	                    }
    	                }
    	                else {
    	                    var5 = -0.37972287504855623;
    	                }
    	            }
    	            else {
    	                if (input[17] > 0.07665000000000001) {
    	                    var5 = 0.06567141759121717;
    	                }
    	                else {
    	                    var5 = -0.29191901524994546;
    	                }
    	            }
    	        }
    	        else {
    	            if (input[5] > 0.000000000000000000000000000000000010000000180025095) {
    	                var5 = 0.2119830872455822;
    	            }
    	            else {
    	                if (input[2] > 0.000000000000000000000000000000000010000000180025095) {
    	                    var5 = -0.3836633644938315;
    	                }
    	                else {
    	                    if (input[21] > 0.000000000000000000000000000000000010000000180025095) {
    	                        var5 = -0.3940414730668337;
    	                    }
    	                    else {
    	                        if (input[1] > 0.8685000000000002) {
    	                            if (input[4] > 0.15300000000000002) {
    	                                var5 = -0.3565583057136445;
    	                            }
    	                            else {
    	                                if (input[1] > 0.9925) {
    	                                    var5 = -0.3610891334737628;
    	                                }
    	                                else {
    	                                    var5 = 0.16933049122632954;
    	                                }
    	                            }
    	                        }
    	                        else {
    	                            var5 = -0.3672438579119161;
    	                        }
    	                    }
    	                }
    	            }
    	        }
    	    }
    	    else {
    	        if (input[13] > 3.5000000000000004) {
    	            if (input[15] > 0.9995000000000002) {
    	                if (input[18] > 0.000000000000000000000000000000000010000000180025095) {
    	                    var5 = -0.3405212228203474;
    	                }
    	                else {
    	                    if (input[11] > 0.000000000000000000000000000000000010000000180025095) {
    	                        if (input[9] > 11.850000000000003) {
    	                            var5 = 0.03481171941844293;
    	                        }
    	                        else {
    	                            var5 = -0.36321499521553097;
    	                        }
    	                    }
    	                    else {
    	                        var5 = -0.24782450400261663;
    	                    }
    	                }
    	            }
    	            else {
    	                if (input[1] > 0.49550000000000005) {
    	                    if (input[4] > 0.17050000000000004) {
    	                        var5 = -0.34982201027030463;
    	                    }
    	                    else {
    	                        if (input[12] > 0.000000000000000000000000000000000010000000180025095) {
    	                            var5 = -0.37478451237243054;
    	                        }
    	                        else {
    	                            if (input[24] > 0.000000000000000000000000000000000010000000180025095) {
    	                                var5 = -0.2519701225972154;
    	                            }
    	                            else {
    	                                if (input[9] > 30.450000000000003) {
    	                                    var5 = -0.19635524506701266;
    	                                }
    	                                else {
    	                                    if (input[15] > 0.23950000000000002) {
    	                                        if (input[8] > 0.000000000000000000000000000000000010000000180025095) {
    	                                            if (input[1] > 0.9915000000000002) {
    	                                                var5 = -0.21989158486347885;
    	                                            }
    	                                            else {
    	                                                if (input[20] > 0.42550000000000004) {
    	                                                    var5 = 0.18881451750251407;
    	                                                }
    	                                                else {
    	                                                    if (input[15] > 0.36250000000000004) {
    	                                                        if (input[8] > 1.5000000000000002) {
    	                                                            var5 = 0.210639448346592;
    	                                                        }
    	                                                        else {
    	                                                            if (input[10] > 5.500000000000001) {
    	                                                                var5 = -0.3772511424389422;
    	                                                            }
    	                                                            else {
    	                                                                if (input[13] > 22.500000000000004) {
    	                                                                    if (input[17] > 0.010250000000000002) {
    	                                                                        if (input[1] > 0.9745) {
    	                                                                            var5 = -0.3292408040480965;
    	                                                                        }
    	                                                                        else {
    	                                                                            var5 = 0.23159063694103826;
    	                                                                        }
    	                                                                    }
    	                                                                    else {
    	                                                                        var5 = 0.4641206389319701;
    	                                                                    }
    	                                                                }
    	                                                                else {
    	                                                                    if (input[17] > 0.016350000000000003) {
    	                                                                        if (input[17] > 0.017950000000000004) {
    	                                                                            var5 = -0.057323118837807975;
    	                                                                        }
    	                                                                        else {
    	                                                                            var5 = 0.4091913400760221;
    	                                                                        }
    	                                                                    }
    	                                                                    else {
    	                                                                        if (input[17] > 0.012450000000000001) {
    	                                                                            var5 = -0.44814393432650906;
    	                                                                        }
    	                                                                        else {
    	                                                                            var5 = -0.08174325750927812;
    	                                                                        }
    	                                                                    }
    	                                                                }
    	                                                            }
    	                                                        }
    	                                                    }
    	                                                    else {
    	                                                        var5 = -0.3147155252600177;
    	                                                    }
    	                                                }
    	                                            }
    	                                        }
    	                                        else {
    	                                            if (input[10] > 0.000000000000000000000000000000000010000000180025095) {
    	                                                if (input[3] > 2.5000000000000004) {
    	                                                    var5 = 0.14451209958036712;
    	                                                }
    	                                                else {
    	                                                    var5 = -0.3672622984397585;
    	                                                }
    	                                            }
    	                                            else {
    	                                                var5 = 0.39444808730438247;
    	                                            }
    	                                        }
    	                                    }
    	                                    else {
    	                                        var5 = -0.11471702331786926;
    	                                    }
    	                                }
    	                            }
    	                        }
    	                    }
    	                }
    	                else {
    	                    var5 = -0.34482432907387983;
    	                }
    	            }
    	        }
    	        else {
    	            var5 = -0.28940521084643994;
    	        }
    	    }
    	    var var6;
    	    if (input[0] > 0.000000000000000000000000000000000010000000180025095) {
    	        if (input[2] > 0.000000000000000000000000000000000010000000180025095) {
    	            if (input[15] > 0.5705000000000001) {
    	                var6 = -1.2366841281345005;
    	            }
    	            else {
    	                var6 = -0.31616932288393274;
    	            }
    	        }
    	        else {
    	            if (input[3] > 4.500000000000001) {
    	                if (input[1] > 0.18150000000000002) {
    	                    if (input[12] > 0.000000000000000000000000000000000010000000180025095) {
    	                        var6 = -0.256523297308944;
    	                    }
    	                    else {
    	                        if (input[1] > 0.9925) {
    	                            if (input[17] > 0.004765000000000001) {
    	                                if (input[3] > 6.500000000000001) {
    	                                    var6 = -0.40894352337976275;
    	                                }
    	                                else {
    	                                    var6 = 0.0978365503362736;
    	                                }
    	                            }
    	                            else {
    	                                var6 = 0.2839275682714997;
    	                            }
    	                        }
    	                        else {
    	                            var6 = 0.26829971970705835;
    	                        }
    	                    }
    	                }
    	                else {
    	                    var6 = -0.3096341802176078;
    	                }
    	            }
    	            else {
    	                if (input[1] > 0.7865000000000001) {
    	                    if (input[22] > 0.000000000000000000000000000000000010000000180025095) {
    	                        var6 = -0.338837936949396;
    	                    }
    	                    else {
    	                        if (input[4] > 0.28950000000000004) {
    	                            var6 = -0.35389108747972187;
    	                        }
    	                        else {
    	                            if (input[1] > 0.9925) {
    	                                var6 = -0.20290616514912022;
    	                            }
    	                            else {
    	                                var6 = 0.16631615641346506;
    	                            }
    	                        }
    	                    }
    	                }
    	                else {
    	                    var6 = -0.3551616884755917;
    	                }
    	            }
    	        }
    	    }
    	    else {
    	        if (input[13] > 1.5000000000000002) {
    	            if (input[4] > 0.17050000000000004) {
    	                var6 = -0.3329070845107999;
    	            }
    	            else {
    	                if (input[1] > 0.8745000000000002) {
    	                    if (input[1] > 0.9945) {
    	                        if (input[1] > 1.0050000000000001) {
    	                            if (input[15] > 0.6865000000000001) {
    	                                var6 = -0.3885932312086337;
    	                            }
    	                            else {
    	                                var6 = 0.4141498813087199;
    	                            }
    	                        }
    	                        else {
    	                            var6 = -0.32687250707438215;
    	                        }
    	                    }
    	                    else {
    	                        if (input[6] > 3.5000000000000004) {
    	                            if (input[15] > 0.03155000000000001) {
    	                                if (input[14] > 7.500000000000001) {
    	                                    if (input[17] > 0.006075000000000001) {
    	                                        if (input[17] > 0.03045) {
    	                                            var6 = -0.14049943549916244;
    	                                        }
    	                                        else {
    	                                            if (input[20] > 0.5315000000000002) {
    	                                                var6 = -0.19380031511808446;
    	                                            }
    	                                            else {
    	                                                var6 = 0.11578351663837905;
    	                                            }
    	                                        }
    	                                    }
    	                                    else {
    	                                        var6 = -0.22891367099257162;
    	                                    }
    	                                }
    	                                else {
    	                                    var6 = -0.3109880957238796;
    	                                }
    	                            }
    	                            else {
    	                                var6 = 0.6778294668872165;
    	                            }
    	                        }
    	                        else {
    	                            if (input[20] > 0.21050000000000002) {
    	                                if (input[7] > 4.500000000000001) {
    	                                    var6 = -0.328065851472433;
    	                                }
    	                                else {
    	                                    if (input[14] > 10.500000000000002) {
    	                                        var6 = 0.09348515367848169;
    	                                    }
    	                                    else {
    	                                        var6 = -0.3710261242790519;
    	                                    }
    	                                }
    	                            }
    	                            else {
    	                                if (input[1] > 0.9595000000000001) {
    	                                    if (input[18] > 0.000000000000000000000000000000000010000000180025095) {
    	                                        var6 = -0.324198598028791;
    	                                    }
    	                                    else {
    	                                        if (input[9] > 12.050000000000002) {
    	                                            if (input[1] > 0.9775000000000001) {
    	                                                if (input[13] > 23.500000000000004) {
    	                                                    if (input[10] > 4.500000000000001) {
    	                                                        var6 = -0.17934147499862044;
    	                                                    }
    	                                                    else {
    	                                                        var6 = 0.2586146564077536;
    	                                                    }
    	                                                }
    	                                                else {
    	                                                    var6 = -0.2872683155683048;
    	                                                }
    	                                            }
    	                                            else {
    	                                                var6 = -0.3530288952428903;
    	                                            }
    	                                        }
    	                                        else {
    	                                            if (input[14] > 54.50000000000001) {
    	                                                if (input[17] > 0.02295) {
    	                                                    var6 = -0.04731267568086924;
    	                                                }
    	                                                else {
    	                                                    var6 = 0.458682919571401;
    	                                                }
    	                                            }
    	                                            else {
    	                                                var6 = -0.15561071840918814;
    	                                            }
    	                                        }
    	                                    }
    	                                }
    	                                else {
    	                                    if (input[14] > 296.00000000000006) {
    	                                        var6 = 0.5910944942999363;
    	                                    }
    	                                    else {
    	                                        if (input[17] > 0.038450000000000005) {
    	                                            if (input[3] > 20.500000000000004) {
    	                                                var6 = 0.3848137415210768;
    	                                            }
    	                                            else {
    	                                                var6 = -0.22465411339551108;
    	                                            }
    	                                        }
    	                                        else {
    	                                            var6 = 0.09512533267279387;
    	                                        }
    	                                    }
    	                                }
    	                            }
    	                        }
    	                    }
    	                }
    	                else {
    	                    var6 = -0.23234384121718105;
    	                }
    	            }
    	        }
    	        else {
    	            var6 = -0.3126843216163841;
    	        }
    	    }
    	    var var7;
    	    if (input[0] > 0.000000000000000000000000000000000010000000180025095) {
    	        if (input[15] > 0.29750000000000004) {
    	            if (input[1] > 0.8595) {
    	                if (input[4] > 0.03255000000000001) {
    	                    if (input[20] > 0.37650000000000006) {
    	                        if (input[14] > 50.50000000000001) {
    	                            var7 = -0.48614653823199117;
    	                        }
    	                        else {
    	                            var7 = 0.184374710074637;
    	                        }
    	                    }
    	                    else {
    	                        var7 = 0.14365602193336716;
    	                    }
    	                }
    	                else {
    	                    if (input[13] > 7.500000000000001) {
    	                        var7 = 0.2432926830793802;
    	                    }
    	                    else {
    	                        if (input[15] > 0.3945000000000001) {
    	                            var7 = -0.3289140641207362;
    	                        }
    	                        else {
    	                            var7 = 0.23526944685710766;
    	                        }
    	                    }
    	                }
    	            }
    	            else {
    	                if (input[8] > 0.000000000000000000000000000000000010000000180025095) {
    	                    var7 = 0.23647529668320244;
    	                }
    	                else {
    	                    if (input[14] > 82.50000000000001) {
    	                        var7 = -0.49839806170124806;
    	                    }
    	                    else {
    	                        var7 = 0.01342692855335295;
    	                    }
    	                }
    	            }
    	        }
    	        else {
    	            if (input[5] > 0.000000000000000000000000000000000010000000180025095) {
    	                var7 = 0.10359857707105699;
    	            }
    	            else {
    	                if (input[20] > 0.10950000000000001) {
    	                    if (input[9] > 4.3950000000000005) {
    	                        if (input[13] > 5.500000000000001) {
    	                            if (input[8] > 0.000000000000000000000000000000000010000000180025095) {
    	                                var7 = -0.42129422834847935;
    	                            }
    	                            else {
    	                                var7 = 0.04699191560113789;
    	                            }
    	                        }
    	                        else {
    	                            var7 = -0.44677737267141404;
    	                        }
    	                    }
    	                    else {
    	                        var7 = -0.31149619615132595;
    	                    }
    	                }
    	                else {
    	                    if (input[22] > 0.000000000000000000000000000000000010000000180025095) {
    	                        var7 = -0.3531921226812902;
    	                    }
    	                    else {
    	                        if (input[20] > 0.008070000000000003) {
    	                            var7 = 0.36526899809915603;
    	                        }
    	                        else {
    	                            var7 = -0.1884932509470746;
    	                        }
    	                    }
    	                }
    	            }
    	        }
    	    }
    	    else {
    	        if (input[13] > 2.5000000000000004) {
    	            if (input[4] > 0.0033550000000000003) {
    	                if (input[5] > 0.000000000000000000000000000000000010000000180025095) {
    	                    if (input[20] > 0.3995000000000001) {
    	                        var7 = 0.4352924738468923;
    	                    }
    	                    else {
    	                        if (input[10] > 3.5000000000000004) {
    	                            if (input[41] > 2.5000000000000004) {
    	                                if (input[21] > 0.000000000000000000000000000000000010000000180025095) {
    	                                    var7 = -0.35405946890683393;
    	                                }
    	                                else {
    	                                    var7 = 0.5110624770776225;
    	                                }
    	                            }
    	                            else {
    	                                var7 = -0.34740063368074664;
    	                            }
    	                        }
    	                        else {
    	                            if (input[7] > 2.5000000000000004) {
    	                                var7 = -0.20539432874656458;
    	                            }
    	                            else {
    	                                var7 = 0.3731228042071626;
    	                            }
    	                        }
    	                    }
    	                }
    	                else {
    	                    var7 = -0.30434973342546007;
    	                }
    	            }
    	            else {
    	                if (input[1] > 0.9945) {
    	                    if (input[1] > 1.1450000000000002) {
    	                        var7 = 0.20554030994654543;
    	                    }
    	                    else {
    	                        var7 = -0.29033334887452455;
    	                    }
    	                }
    	                else {
    	                    if (input[1] > 0.49550000000000005) {
    	                        if (input[7] > 1.5000000000000002) {
    	                            if (input[20] <= -0.004204999999999999) {
    	                                var7 = -0.3434423290015827;
    	                            }
    	                            else {
    	                                if (input[14] > 28.500000000000004) {
    	                                    if (input[8] > 0.000000000000000000000000000000000010000000180025095) {
    	                                        var7 = -0.012986796983070016;
    	                                    }
    	                                    else {
    	                                        var7 = 0.2002931115395066;
    	                                    }
    	                                }
    	                                else {
    	                                    if (input[15] > 0.5995) {
    	                                        var7 = -0.3861015958668885;
    	                                    }
    	                                    else {
    	                                        if (input[17] > 0.021550000000000003) {
    	                                            if (input[15] > 0.11650000000000002) {
    	                                                var7 = 0.03316988683336425;
    	                                            }
    	                                            else {
    	                                                var7 = 0.6719806084897616;
    	                                            }
    	                                        }
    	                                        else {
    	                                            if (input[6] > 5.500000000000001) {
    	                                                var7 = 0.08941513661588252;
    	                                            }
    	                                            else {
    	                                                var7 = -0.29041033668558375;
    	                                            }
    	                                        }
    	                                    }
    	                                }
    	                            }
    	                        }
    	                        else {
    	                            if (input[14] > 38.50000000000001) {
    	                                if (input[3] > 26.500000000000004) {
    	                                    var7 = 0.31334773329073856;
    	                                }
    	                                else {
    	                                    var7 = -0.34090491426434333;
    	                                }
    	                            }
    	                            else {
    	                                var7 = 0.10619097870831924;
    	                            }
    	                        }
    	                    }
    	                    else {
    	                        var7 = -0.32609012743224974;
    	                    }
    	                }
    	            }
    	        }
    	        else {
    	            if (input[28] > 250.00000000000003) {
    	                var7 = -0.28933664983517526;
    	            }
    	            else {
    	                var7 = 0.2757577939409649;
    	            }
    	        }
    	    }
    	    var var8;
    	    if (input[0] > 0.000000000000000000000000000000000010000000180025095) {
    	        if (input[2] > 0.000000000000000000000000000000000010000000180025095) {
    	            var8 = -0.3494104221344561;
    	        }
    	        else {
    	            if (input[3] > 4.500000000000001) {
    	                if (input[1] > 0.6675000000000001) {
    	                    if (input[20] > 0.5405000000000001) {
    	                        if (input[13] > 16.500000000000004) {
    	                            if (input[3] > 7.500000000000001) {
    	                                var8 = 0.007691232068275579;
    	                            }
    	                            else {
    	                                var8 = -0.6156455552390294;
    	                            }
    	                        }
    	                        else {
    	                            var8 = 0.10615062251640263;
    	                        }
    	                    }
    	                    else {
    	                        if (input[1] > 0.9935000000000002) {
    	                            var8 = 0.052037859233213114;
    	                        }
    	                        else {
    	                            var8 = 0.23621623529691202;
    	                        }
    	                    }
    	                }
    	                else {
    	                    if (input[20] > 0.06535000000000002) {
    	                        var8 = -0.25110704545300433;
    	                    }
    	                    else {
    	                        var8 = 0.16523498396129635;
    	                    }
    	                }
    	            }
    	            else {
    	                if (input[1] > 0.9335000000000001) {
    	                    if (input[21] > 0.000000000000000000000000000000000010000000180025095) {
    	                        var8 = -0.32335935115130005;
    	                    }
    	                    else {
    	                        if (input[8] > 0.000000000000000000000000000000000010000000180025095) {
    	                            var8 = -0.3577985969423347;
    	                        }
    	                        else {
    	                            if (input[1] > 0.9925) {
    	                                var8 = -0.16757832298636577;
    	                            }
    	                            else {
    	                                var8 = 0.15455201285060866;
    	                            }
    	                        }
    	                    }
    	                }
    	                else {
    	                    var8 = -0.24099535120447582;
    	                }
    	            }
    	        }
    	    }
    	    else {
    	        if (input[13] > 1.5000000000000002) {
    	            if (input[4] > 0.17050000000000004) {
    	                var8 = -0.31797620682267896;
    	            }
    	            else {
    	                if (input[1] > 0.49550000000000005) {
    	                    if (input[24] > 0.000000000000000000000000000000000010000000180025095) {
    	                        if (input[6] > 2.5000000000000004) {
    	                            var8 = -0.024177997454219034;
    	                        }
    	                        else {
    	                            var8 = -0.3322443082929485;
    	                        }
    	                    }
    	                    else {
    	                        if (input[11] > 0.000000000000000000000000000000000010000000180025095) {
    	                            if (input[13] > 12.500000000000002) {
    	                                if (input[3] > 4.500000000000001) {
    	                                    var8 = -0.002900618926301701;
    	                                }
    	                                else {
    	                                    var8 = -0.40181269799659725;
    	                                }
    	                            }
    	                            else {
    	                                var8 = 0.22624368699567468;
    	                            }
    	                        }
    	                        else {
    	                            if (input[9] > 41.75000000000001) {
    	                                var8 = -0.3544912000605292;
    	                            }
    	                            else {
    	                                if (input[1] > 0.8985000000000002) {
    	                                    if (input[9] > 39.45000000000001) {
    	                                        var8 = 0.4113814951728802;
    	                                    }
    	                                    else {
    	                                        if (input[15] > 0.9995000000000002) {
    	                                            if (input[14] > 198.50000000000003) {
    	                                                var8 = 0.2877266215426778;
    	                                            }
    	                                            else {
    	                                                var8 = -0.2557852798961143;
    	                                            }
    	                                        }
    	                                        else {
    	                                            if (input[20] > 0.04335000000000001) {
    	                                                if (input[15] > 0.2695000000000001) {
    	                                                    if (input[9] > 11.750000000000002) {
    	                                                        if (input[14] > 82.50000000000001) {
    	                                                            var8 = -0.30743826561054427;
    	                                                        }
    	                                                        else {
    	                                                            var8 = -0.031117334971722192;
    	                                                        }
    	                                                    }
    	                                                    else {
    	                                                        if (input[17] > 0.010350000000000002) {
    	                                                            if (input[18] > 0.000000000000000000000000000000000010000000180025095) {
    	                                                                var8 = -0.1819651381250936;
    	                                                            }
    	                                                            else {
    	                                                                var8 = 0.13573468868395955;
    	                                                            }
    	                                                        }
    	                                                        else {
    	                                                            var8 = 0.38956687792820976;
    	                                                        }
    	                                                    }
    	                                                }
    	                                                else {
    	                                                    if (input[20] > 0.7485) {
    	                                                        if (input[10] > 0.000000000000000000000000000000000010000000180025095) {
    	                                                            var8 = 0.2853615313202955;
    	                                                        }
    	                                                        else {
    	                                                            var8 = -0.2366154783068003;
    	                                                        }
    	                                                    }
    	                                                    else {
    	                                                        var8 = -0.26789251155791205;
    	                                                    }
    	                                                }
    	                                            }
    	                                            else {
    	                                                if (input[6] > 1.5000000000000002) {
    	                                                    if (input[20] > 0.025450000000000004) {
    	                                                        var8 = 0.4687233883805721;
    	                                                    }
    	                                                    else {
    	                                                        if (input[17] > 0.014250000000000002) {
    	                                                            var8 = 0.2959010525064398;
    	                                                        }
    	                                                        else {
    	                                                            var8 = -0.19200903261360924;
    	                                                        }
    	                                                    }
    	                                                }
    	                                                else {
    	                                                    var8 = -0.2392485894547111;
    	                                                }
    	                                            }
    	                                        }
    	                                    }
    	                                }
    	                                else {
    	                                    if (input[9] > 18.050000000000004) {
    	                                        var8 = 0.1805774572979867;
    	                                    }
    	                                    else {
    	                                        var8 = -0.2564457338914691;
    	                                    }
    	                                }
    	                            }
    	                        }
    	                    }
    	                }
    	                else {
    	                    var8 = -0.32018647076355733;
    	                }
    	            }
    	        }
    	        else {
    	            if (input[17] > 0.04825000000000001) {
    	                var8 = 0.3757048660600794;
    	            }
    	            else {
    	                var8 = -0.3182021802530058;
    	            }
    	        }
    	    }
    	    var var9;
    	    if (input[0] > 0.000000000000000000000000000000000010000000180025095) {
    	        if (input[9] > 4.095000000000001) {
    	            if (input[4] > 0.14350000000000002) {
    	                var9 = -0.2588068860643473;
    	            }
    	            else {
    	                if (input[2] > 0.000000000000000000000000000000000010000000180025095) {
    	                    if (input[17] > 0.006195000000000001) {
    	                        var9 = -0.6462961527759437;
    	                    }
    	                    else {
    	                        var9 = 0.050438889454859484;
    	                    }
    	                }
    	                else {
    	                    if (input[3] > 2.5000000000000004) {
    	                        if (input[15] > 0.39150000000000007) {
    	                            var9 = 0.22562422855727146;
    	                        }
    	                        else {
    	                            if (input[1] > 0.9875000000000002) {
    	                                if (input[43] > 0.000000000000000000000000000000000010000000180025095) {
    	                                    var9 = 0.3077198474579384;
    	                                }
    	                                else {
    	                                    if (input[20] > 0.35350000000000004) {
    	                                        if (input[17] > 0.005685000000000001) {
    	                                            var9 = -0.6180783639230358;
    	                                        }
    	                                        else {
    	                                            var9 = -0.01272567593756213;
    	                                        }
    	                                    }
    	                                    else {
    	                                        var9 = 0.02764818257697603;
    	                                    }
    	                                }
    	                            }
    	                            else {
    	                                var9 = 0.14937730389907655;
    	                            }
    	                        }
    	                    }
    	                    else {
    	                        if (input[20] > 0.5945000000000001) {
    	                            var9 = -0.5451060650958778;
    	                        }
    	                        else {
    	                            if (input[1] > 0.9415000000000001) {
    	                                var9 = 0.0731837898853319;
    	                            }
    	                            else {
    	                                var9 = -0.3809395206179213;
    	                            }
    	                        }
    	                    }
    	                }
    	            }
    	        }
    	        else {
    	            if (input[26] > 1.5000000000000002) {
    	                var9 = -0.8383023366871766;
    	            }
    	            else {
    	                if (input[13] > 89.50000000000001) {
    	                    var9 = 0.3969618751709003;
    	                }
    	                else {
    	                    if (input[20] > 0.12450000000000001) {
    	                        var9 = -0.25623715866720553;
    	                    }
    	                    else {
    	                        if (input[12] > 0.000000000000000000000000000000000010000000180025095) {
    	                            var9 = -0.44870890240030425;
    	                        }
    	                        else {
    	                            if (input[9] > 2.3650000000000007) {
    	                                var9 = -0.2503870366576568;
    	                            }
    	                            else {
    	                                var9 = 0.34039145574985985;
    	                            }
    	                        }
    	                    }
    	                }
    	            }
    	        }
    	    }
    	    else {
    	        if (input[2] > 0.000000000000000000000000000000000010000000180025095) {
    	            var9 = -0.32572048676017584;
    	        }
    	        else {
    	            if (input[4] > 0.17050000000000004) {
    	                var9 = -0.313163109383056;
    	            }
    	            else {
    	                if (input[1] > 0.49550000000000005) {
    	                    if (input[1] > 0.9915000000000002) {
    	                        if (input[15] > 0.6865000000000001) {
    	                            var9 = -0.34358708793599624;
    	                        }
    	                        else {
    	                            if (input[17] > 0.006275000000000001) {
    	                                if (input[1] > 1.1850000000000003) {
    	                                    var9 = 0.5006929338421348;
    	                                }
    	                                else {
    	                                    var9 = -0.3042940239153724;
    	                                }
    	                            }
    	                            else {
    	                                if (input[14] > 3.5000000000000004) {
    	                                    if (input[42] > 0.000000000000000000000000000000000010000000180025095) {
    	                                        var9 = -0.3476625618018274;
    	                                    }
    	                                    else {
    	                                        if (input[7] > 3.5000000000000004) {
    	                                            if (input[17] > 0.006075000000000001) {
    	                                                var9 = 0.6177893931408684;
    	                                            }
    	                                            else {
    	                                                if (input[20] > 0.15550000000000003) {
    	                                                    var9 = -0.24638090774388138;
    	                                                }
    	                                                else {
    	                                                    var9 = 0.5816206840202987;
    	                                                }
    	                                            }
    	                                        }
    	                                        else {
    	                                            var9 = 0.7292482530471489;
    	                                        }
    	                                    }
    	                                }
    	                                else {
    	                                    var9 = -0.3188553071917412;
    	                                }
    	                            }
    	                        }
    	                    }
    	                    else {
    	                        if (input[41] > 3.5000000000000004) {
    	                            var9 = -0.4094861016705374;
    	                        }
    	                        else {
    	                            if (input[12] > 0.000000000000000000000000000000000010000000180025095) {
    	                                var9 = -0.34703639922428425;
    	                            }
    	                            else {
    	                                if (input[24] > 0.000000000000000000000000000000000010000000180025095) {
    	                                    if (input[13] > 137.50000000000003) {
    	                                        var9 = 0.49259698924599205;
    	                                    }
    	                                    else {
    	                                        var9 = -0.2461737891543564;
    	                                    }
    	                                }
    	                                else {
    	                                    if (input[6] > 6.500000000000001) {
    	                                        if (input[14] > 65.50000000000001) {
    	                                            var9 = -0.36895724797897334;
    	                                        }
    	                                        else {
    	                                            if (input[3] > 1.5000000000000002) {
    	                                                if (input[1] > 0.9845) {
    	                                                    var9 = -0.2743784938832966;
    	                                                }
    	                                                else {
    	                                                    if (input[17] > 0.015250000000000001) {
    	                                                        var9 = -0.143031649885769;
    	                                                    }
    	                                                    else {
    	                                                        var9 = 0.27810448440047764;
    	                                                    }
    	                                                }
    	                                            }
    	                                            else {
    	                                                var9 = -0.3402560243190787;
    	                                            }
    	                                        }
    	                                    }
    	                                    else {
    	                                        var9 = 0.013064281967218079;
    	                                    }
    	                                }
    	                            }
    	                        }
    	                    }
    	                }
    	                else {
    	                    var9 = -0.31456349524354904;
    	                }
    	            }
    	        }
    	    }
    	    var var10;
    	    if (input[0] > 0.000000000000000000000000000000000010000000180025095) {
    	        if (input[5] > 0.000000000000000000000000000000000010000000180025095) {
    	            if (input[19] > 0.000000000000000000000000000000000010000000180025095) {
    	                if (input[1] > 0.9865) {
    	                    if (input[11] > 0.000000000000000000000000000000000010000000180025095) {
    	                        if (input[20] > 0.35350000000000004) {
    	                            var10 = -0.8151404030167451;
    	                        }
    	                        else {
    	                            var10 = 0.0795939011173865;
    	                        }
    	                    }
    	                    else {
    	                        var10 = 0.20527419592177287;
    	                    }
    	                }
    	                else {
    	                    var10 = 0.23228362215964637;
    	                }
    	            }
    	            else {
    	                var10 = -0.30174476467396055;
    	            }
    	        }
    	        else {
    	            if (input[1] > 0.9405) {
    	                if (input[15] > 0.45450000000000007) {
    	                    if (input[13] > 7.500000000000001) {
    	                        var10 = 0.22438416431888183;
    	                    }
    	                    else {
    	                        var10 = -0.3575162161503762;
    	                    }
    	                }
    	                else {
    	                    if (input[1] > 0.9615000000000001) {
    	                        if (input[17] > 0.0070950000000000015) {
    	                            if (input[9] > 19.650000000000002) {
    	                                var10 = -1.0846298446013118;
    	                            }
    	                            else {
    	                                if (input[14] > 37.50000000000001) {
    	                                    if (input[4] > 0.13950000000000004) {
    	                                        var10 = -0.38521795194728403;
    	                                    }
    	                                    else {
    	                                        var10 = 0.09705858211015748;
    	                                    }
    	                                }
    	                                else {
    	                                    if (input[9] > 10.350000000000003) {
    	                                        var10 = -1.1014729482523273;
    	                                    }
    	                                    else {
    	                                        var10 = -0.2695788618949159;
    	                                    }
    	                                }
    	                            }
    	                        }
    	                        else {
    	                            if (input[1] > 0.9925) {
    	                                var10 = -0.2711939452969373;
    	                            }
    	                            else {
    	                                var10 = 0.1673079694162126;
    	                            }
    	                        }
    	                    }
    	                    else {
    	                        var10 = 0.34082965634841417;
    	                    }
    	                }
    	            }
    	            else {
    	                if (input[21] > 1.5000000000000002) {
    	                    var10 = -0.5420328113044286;
    	                }
    	                else {
    	                    if (input[20] > 0.13550000000000004) {
    	                        if (input[4] > 0.0028300000000000005) {
    	                            var10 = -0.6254455097716743;
    	                        }
    	                        else {
    	                            if (input[20] > 0.25050000000000006) {
    	                                if (input[15] > 0.19450000000000003) {
    	                                    var10 = 0.14593919567749394;
    	                                }
    	                                else {
    	                                    var10 = -0.34449364708132507;
    	                                }
    	                            }
    	                            else {
    	                                var10 = -0.38428814595030214;
    	                            }
    	                        }
    	                    }
    	                    else {
    	                        if (input[12] > 0.000000000000000000000000000000000010000000180025095) {
    	                            var10 = -0.40863071853169647;
    	                        }
    	                        else {
    	                            if (input[3] > 4.500000000000001) {
    	                                var10 = 0.20891521759623502;
    	                            }
    	                            else {
    	                                var10 = -0.2929064911119387;
    	                            }
    	                        }
    	                    }
    	                }
    	            }
    	        }
    	    }
    	    else {
    	        if (input[13] > 1.5000000000000002) {
    	            if (input[4] > 0.0033550000000000003) {
    	                if (input[5] > 0.000000000000000000000000000000000010000000180025095) {
    	                    if (input[10] > 3.5000000000000004) {
    	                        if (input[21] > 0.000000000000000000000000000000000010000000180025095) {
    	                            var10 = -0.33187066202672766;
    	                        }
    	                        else {
    	                            if (input[22] > 0.000000000000000000000000000000000010000000180025095) {
    	                                var10 = 0.3339932073116381;
    	                            }
    	                            else {
    	                                var10 = -0.28292986871402276;
    	                            }
    	                        }
    	                    }
    	                    else {
    	                        var10 = 0.1591751087327201;
    	                    }
    	                }
    	                else {
    	                    if (input[40] > 0.000000000000000000000000000000000010000000180025095) {
    	                        var10 = 0.384572837555157;
    	                    }
    	                    else {
    	                        var10 = -0.279587695938972;
    	                    }
    	                }
    	            }
    	            else {
    	                if (input[13] > 68.50000000000001) {
    	                    if (input[27] > 0.000000000000000000000000000000000010000000180025095) {
    	                        var10 = 0.364386316398611;
    	                    }
    	                    else {
    	                        if (input[13] > 71.50000000000001) {
    	                            var10 = -0.24339469179898252;
    	                        }
    	                        else {
    	                            var10 = 0.40804219829124433;
    	                        }
    	                    }
    	                }
    	                else {
    	                    if (input[13] > 35.50000000000001) {
    	                        if (input[9] > 0.7975000000000002) {
    	                            var10 = -0.296572529860964;
    	                        }
    	                        else {
    	                            if (input[7] > 3.5000000000000004) {
    	                                var10 = 0.5764646233541577;
    	                            }
    	                            else {
    	                                var10 = -0.36885281959882005;
    	                            }
    	                        }
    	                    }
    	                    else {
    	                        if (input[1] > 0.5785000000000001) {
    	                            if (input[18] > 0.000000000000000000000000000000000010000000180025095) {
    	                                if (input[6] > 2.5000000000000004) {
    	                                    var10 = 0.010538691430695383;
    	                                }
    	                                else {
    	                                    var10 = -0.20109388459887687;
    	                                }
    	                            }
    	                            else {
    	                                var10 = 0.011280802819130843;
    	                            }
    	                        }
    	                        else {
    	                            var10 = -0.32973854887475595;
    	                        }
    	                    }
    	                }
    	            }
    	        }
    	        else {
    	            var10 = -0.2662559032370117;
    	        }
    	    }
    	    var var11;
    	    if (input[2] > 0.000000000000000000000000000000000010000000180025095) {
    	        var11 = -0.29637685744028475;
    	    }
    	    else {
    	        if (input[0] > 0.000000000000000000000000000000000010000000180025095) {
    	            if (input[15] > 0.40650000000000003) {
    	                if (input[29] > 0.000000000000000000000000000000000010000000180025095) {
    	                    var11 = -0.6243179452095545;
    	                }
    	                else {
    	                    if (input[14] > 13.500000000000002) {
    	                        if (input[17] > 0.040650000000000006) {
    	                            if (input[9] > 16.650000000000002) {
    	                                var11 = 0.31180258827400303;
    	                            }
    	                            else {
    	                                if (input[17] > 0.05010000000000001) {
    	                                    var11 = 0.005406263252773678;
    	                                }
    	                                else {
    	                                    var11 = -0.49389397494834614;
    	                                }
    	                            }
    	                        }
    	                        else {
    	                            if (input[9] > 32.15000000000001) {
    	                                if (input[11] > 0.000000000000000000000000000000000010000000180025095) {
    	                                    var11 = 0.21951272493775212;
    	                                }
    	                                else {
    	                                    if (input[17] > 0.0038450000000000008) {
    	                                        var11 = -0.31265440930147426;
    	                                    }
    	                                    else {
    	                                        var11 = 0.28633166048219966;
    	                                    }
    	                                }
    	                            }
    	                            else {
    	                                var11 = 0.22228367496738968;
    	                            }
    	                        }
    	                    }
    	                    else {
    	                        var11 = -0.33864392269119964;
    	                    }
    	                }
    	            }
    	            else {
    	                if (input[22] > 0.000000000000000000000000000000000010000000180025095) {
    	                    var11 = -0.31577382100304713;
    	                }
    	                else {
    	                    if (input[1] > 0.38950000000000007) {
    	                        if (input[20] <= -0.000000000000000000000000000000000010000000180025095) {
    	                            var11 = -0.382531944184145;
    	                        }
    	                        else {
    	                            if (input[3] > 6.500000000000001) {
    	                                var11 = 0.2050264214960661;
    	                            }
    	                            else {
    	                                if (input[14] > 62.50000000000001) {
    	                                    if (input[7] > 7.500000000000001) {
    	                                        var11 = -1.3728374150935656;
    	                                    }
    	                                    else {
    	                                        var11 = -0.31532184008861636;
    	                                    }
    	                                }
    	                                else {
    	                                    var11 = 0.054444011059476376;
    	                                }
    	                            }
    	                        }
    	                    }
    	                    else {
    	                        var11 = -0.2868194683777866;
    	                    }
    	                }
    	            }
    	        }
    	        else {
    	            if (input[4] > 0.17050000000000004) {
    	                var11 = -0.30797938174515344;
    	            }
    	            else {
    	                if (input[1] > 0.49550000000000005) {
    	                    if (input[1] > 0.9915000000000002) {
    	                        if (input[15] > 0.6865000000000001) {
    	                            var11 = -0.33862875263925696;
    	                        }
    	                        else {
    	                            if (input[17] > 0.0016450000000000002) {
    	                                if (input[10] > 2.5000000000000004) {
    	                                    var11 = 0.1393790013891831;
    	                                }
    	                                else {
    	                                    if (input[20] > 0.8805000000000002) {
    	                                        var11 = 0.4963717938403495;
    	                                    }
    	                                    else {
    	                                        if (input[15] > 0.6540000000000001) {
    	                                            var11 = 0.46072626717511106;
    	                                        }
    	                                        else {
    	                                            var11 = -0.32453617366105725;
    	                                        }
    	                                    }
    	                                }
    	                            }
    	                            else {
    	                                if (input[7] > 5.500000000000001) {
    	                                    var11 = -0.3167848685574709;
    	                                }
    	                                else {
    	                                    var11 = 0.8233699151006105;
    	                                }
    	                            }
    	                        }
    	                    }
    	                    else {
    	                        if (input[17] > 0.08525) {
    	                            if (input[18] > 0.000000000000000000000000000000000010000000180025095) {
    	                                if (input[3] > 10.500000000000002) {
    	                                    var11 = 0.25233951824541223;
    	                                }
    	                                else {
    	                                    var11 = -0.3544592079556149;
    	                                }
    	                            }
    	                            else {
    	                                var11 = -0.2506569494006796;
    	                            }
    	                        }
    	                        else {
    	                            if (input[18] > 0.000000000000000000000000000000000010000000180025095) {
    	                                if (input[6] > 2.5000000000000004) {
    	                                    var11 = 0.015538301617767581;
    	                                }
    	                                else {
    	                                    if (input[1] > 0.9505) {
    	                                        var11 = -0.32882014494729084;
    	                                    }
    	                                    else {
    	                                        var11 = 0.10894816165249394;
    	                                    }
    	                                }
    	                            }
    	                            else {
    	                                if (input[15] > 0.2695000000000001) {
    	                                    if (input[9] > 8.090000000000002) {
    	                                        if (input[10] > 0.000000000000000000000000000000000010000000180025095) {
    	                                            if (input[9] > 9.705000000000002) {
    	                                                var11 = -0.013063025783068073;
    	                                            }
    	                                            else {
    	                                                var11 = -0.4103559130890425;
    	                                            }
    	                                        }
    	                                        else {
    	                                            if (input[14] > 39.50000000000001) {
    	                                                if (input[15] > 0.48050000000000004) {
    	                                                    var11 = 0.12778520931421455;
    	                                                }
    	                                                else {
    	                                                    var11 = -0.23273841003414023;
    	                                                }
    	                                            }
    	                                            else {
    	                                                var11 = 0.2671968227524951;
    	                                            }
    	                                        }
    	                                    }
    	                                    else {
    	                                        var11 = 0.20609571877025093;
    	                                    }
    	                                }
    	                                else {
    	                                    if (input[5] > 0.000000000000000000000000000000000010000000180025095) {
    	                                        var11 = 0.14931200346556467;
    	                                    }
    	                                    else {
    	                                        var11 = -0.12575510313821803;
    	                                    }
    	                                }
    	                            }
    	                        }
    	                    }
    	                }
    	                else {
    	                    var11 = -0.308908512970489;
    	                }
    	            }
    	        }
    	    }
    	    var var12;
    	    if (input[2] > 0.000000000000000000000000000000000010000000180025095) {
    	        var12 = -0.26203904977537146;
    	    }
    	    else {
    	        if (input[0] > 0.000000000000000000000000000000000010000000180025095) {
    	            if (input[5] > 0.000000000000000000000000000000000010000000180025095) {
    	                if (input[19] > 0.000000000000000000000000000000000010000000180025095) {
    	                    if (input[1] > 0.9865) {
    	                        if (input[20] > 0.48450000000000004) {
    	                            var12 = -0.33812038122197885;
    	                        }
    	                        else {
    	                            if (input[14] > 61.50000000000001) {
    	                                var12 = -0.13171173709264042;
    	                            }
    	                            else {
    	                                var12 = 0.24506291391960786;
    	                            }
    	                        }
    	                    }
    	                    else {
    	                        var12 = 0.19918121869393982;
    	                    }
    	                }
    	                else {
    	                    var12 = -0.23952201240956633;
    	                }
    	            }
    	            else {
    	                if (input[23] > 0.000000000000000000000000000000000010000000180025095) {
    	                    var12 = -0.7736157733416658;
    	                }
    	                else {
    	                    if (input[41] > 0.000000000000000000000000000000000010000000180025095) {
    	                        var12 = -0.4372247823397458;
    	                    }
    	                    else {
    	                        if (input[1] > 0.6935000000000001) {
    	                            if (input[15] > 0.39150000000000007) {
    	                                if (input[13] > 7.500000000000001) {
    	                                    var12 = 0.15062457679234523;
    	                                }
    	                                else {
    	                                    var12 = -0.2682187965947797;
    	                                }
    	                            }
    	                            else {
    	                                if (input[22] > 0.000000000000000000000000000000000010000000180025095) {
    	                                    var12 = -0.36687828626263735;
    	                                }
    	                                else {
    	                                    if (input[1] > 0.9905) {
    	                                        if (input[13] > 10.500000000000002) {
    	                                            var12 = -0.6140928980956166;
    	                                        }
    	                                        else {
    	                                            var12 = -0.0005430539585736974;
    	                                        }
    	                                    }
    	                                    else {
    	                                        if (input[7] > 5.500000000000001) {
    	                                            var12 = 0.1799589222009372;
    	                                        }
    	                                        else {
    	                                            var12 = -0.05834838993406143;
    	                                        }
    	                                    }
    	                                }
    	                            }
    	                        }
    	                        else {
    	                            var12 = -0.22579129243420948;
    	                        }
    	                    }
    	                }
    	            }
    	        }
    	        else {
    	            if (input[4] > 0.17050000000000004) {
    	                var12 = -0.3058906497457735;
    	            }
    	            else {
    	                if (input[1] > 0.8005000000000001) {
    	                    if (input[1] > 0.8125000000000001) {
    	                        if (input[13] > 1.5000000000000002) {
    	                            if (input[9] > 12.750000000000002) {
    	                                if (input[1] > 0.9895000000000002) {
    	                                    if (input[10] > 17.500000000000004) {
    	                                        var12 = 0.24387612062353353;
    	                                    }
    	                                    else {
    	                                        var12 = -0.22197454878634612;
    	                                    }
    	                                }
    	                                else {
    	                                    if (input[10] > 21.500000000000004) {
    	                                        var12 = -0.4016688714002285;
    	                                    }
    	                                    else {
    	                                        if (input[13] > 63.50000000000001) {
    	                                            var12 = 0.2151446764476112;
    	                                        }
    	                                        else {
    	                                            if (input[14] > 82.50000000000001) {
    	                                                var12 = -0.2256799143802389;
    	                                            }
    	                                            else {
    	                                                if (input[10] > 8.500000000000002) {
    	                                                    var12 = -0.27624010002185756;
    	                                                }
    	                                                else {
    	                                                    var12 = 0.012623171550046918;
    	                                                }
    	                                            }
    	                                        }
    	                                    }
    	                                }
    	                            }
    	                            else {
    	                                if (input[17] > 0.011750000000000002) {
    	                                    if (input[1] > 0.9815000000000002) {
    	                                        if (input[10] > 3.5000000000000004) {
    	                                            var12 = 0.05532654023652635;
    	                                        }
    	                                        else {
    	                                            var12 = -0.34721623864023304;
    	                                        }
    	                                    }
    	                                    else {
    	                                        if (input[17] > 0.11750000000000001) {
    	                                            var12 = -0.34213686905250673;
    	                                        }
    	                                        else {
    	                                            if (input[9] > 12.550000000000002) {
    	                                                var12 = 0.35986403745008283;
    	                                            }
    	                                            else {
    	                                                if (input[42] > 1.5000000000000002) {
    	                                                    var12 = 0.3508279341686203;
    	                                                }
    	                                                else {
    	                                                    if (input[10] > 4.500000000000001) {
    	                                                        var12 = -0.21635607999132622;
    	                                                    }
    	                                                    else {
    	                                                        if (input[1] > 0.9025000000000002) {
    	                                                            var12 = 0.0746393375888363;
    	                                                        }
    	                                                        else {
    	                                                            var12 = -0.25878951839465275;
    	                                                        }
    	                                                    }
    	                                                }
    	                                            }
    	                                        }
    	                                    }
    	                                }
    	                                else {
    	                                    if (input[3] > 4.500000000000001) {
    	                                        var12 = 0.2975553373759284;
    	                                    }
    	                                    else {
    	                                        var12 = 0.052775807624178175;
    	                                    }
    	                                }
    	                            }
    	                        }
    	                        else {
    	                            var12 = -0.31037978404662797;
    	                        }
    	                    }
    	                    else {
    	                        var12 = 0.5934646596909894;
    	                    }
    	                }
    	                else {
    	                    if (input[3] > 5.500000000000001) {
    	                        if (input[9] > 18.750000000000004) {
    	                            var12 = 0.7069516854634759;
    	                        }
    	                        else {
    	                            if (input[7] > 5.500000000000001) {
    	                                var12 = 0.21387612786609114;
    	                            }
    	                            else {
    	                                var12 = -0.3587241938372046;
    	                            }
    	                        }
    	                    }
    	                    else {
    	                        var12 = -0.32551680931346566;
    	                    }
    	                }
    	            }
    	        }
    	    }
    	    var var13;
    	    var13 = sigmoid(var0 + var1 + var2 + var3 + var4 + var5 + var6 + var7 + var8 + var9 + var10 + var11 + var12);
    	    return [1.0 - var13, var13];
    	};
    	function sigmoid(x) {
    	    if (x < 0.0) {
    	        var z = Math.exp(x);
    	        return z / (1.0 + z);
    	    }
    	    return 1.0 / (1.0 + Math.exp(-x));
    	}
    	
    	return model;
    }

    var modelExports = /*@__PURE__*/ requireModel();
    var Model = /*@__PURE__*/getDefaultExportFromCjs(modelExports);

    /**
     * @classdesc Responsible for the feature and candidates extraction for the `main-navigation` classification
     */
    class ClassifierLandmarksMainNavigation extends ClassifierBase {
        /** @inheritDoc */
        static Model = Model;
        /**
         * The minimum score that will be considered "correct".
         */
        static ScoreThreshold = 0.9;
        static ModelFeatures = [
            "is_tagname_ul",
            "distance_from_bottom_of_page_percent",
            "number_of_parent_with_tagname_li",
            "num_of_links",
            "numeric_portion",
            "indicative_word_about",
            "number_of_parent_with_tagname_div",
            "parents_count",
            "number_of_visible_uls",
            "aspect_ratio",
            "number_of_visible_div",
            "indicative_word_home",
            "is_out_of_the_page",
            "number_of_visible_elements",
            "visible_text_content_length",
            "width_percentage",
            "number_of_visible_headers",
            "height_percentage",
            "indicative_word_services",
            "is_in_fold",
            "x_percentage",
            "have_img_larger_than_50_px",
            "num_of_img",
            "num_of_inputs",
            "indicative_word_search",
            "is_fixed",
            "number_of_visible_p",
            "indicative_word_shop",
            "font_weight",
            "is_overflowing",
            "indicative_word_products",
            "num_of_iframes",
            "indicative_word_copyright_sign",
            "num_of_textareas",
            "indicative_word_support",
            "number_of_visible_content",
            "number_of_parent_with_tagname_menu",
            "is_tagname_menu",
            "number_of_parent_with_tagname_ol",
            "is_tagname_li",
            "is_tagname_section",
            "num_of_social_links",
            "number_of_visible_navs",
            "indicative_word_blog",
            "is_tagname_p",
        ];
        /**
         * Retrieves list of candidates, their features and label
         * @param types the classification types to extract the data for
         * @param expectedElementCssSelector the tagged/annotated element
         * @param maxNegativeSamples the amount of negative samples to include
         */
        static getFeaturesAndCandidates(types, expectedElementCssSelector, maxNegativeSamples = 2) {
            const response = {};
            for (const [index, type] of Object.entries(types)) {
                const correctCandidates = [];
                const incorrectCandidates = [];
                //const correctElement = getElementByXpath(expectedElementXpath[parseInt(index)]);
                const correctElement = document.querySelector(expectedElementCssSelector[index]);
                for (const rootElement of this.getAllRootElements()) {
                    for (const candidate of this.getCandidates(rootElement)) {
                        if (expectedElementCssSelector.some((cssSelector) => cssSelector !== expectedElementCssSelector[index] && candidate.isEqualNode(document.querySelector(cssSelector))))
                            continue;
                        const label = 1;
                        const row = {
                            candidate,
                            label: candidate === correctElement ? label : 0,
                            labelName: candidate === correctElement ? type : "unknown",
                            features: this.getFeatures(candidate),
                        };
                        row.label ? correctCandidates.push(row) : incorrectCandidates.push(row);
                    }
                }
                response[type] = [...correctCandidates, ...incorrectCandidates.slice(0, maxNegativeSamples)];
            }
            return response;
        }
        /**
         * The selector used to find the candidates for the `main-navigation` classification
         * @private
         */
        static CandidatesSelector = `
    
        ul, ol, nav, header, menu, list,
        
        [id*=nav i]:not(li,a,button, input, textarea), 
        [id*=header i]:not(li,a,button, input, textarea), 
        [id*=menu i]:not(li,a,button, input, textarea), 
        [id*=bar i]:not(li,a,button, input, textarea), 
        [id*=navigation i]:not(li,a,button, input, textarea),
        [id*=list i]:not(li,a,button, input, textarea),
        
        [class*=nav i]:not(li,a,button, input, textarea), 
        [class*=header i]:not(li,a,button, input, textarea), 
        [class*=menu i]:not(li,a,button, input, textarea), 
        [class*=bar i]:not(li,a,button, input, textarea), 
        [class*=navigation i]:not(li,a,button, input, textarea),
        [class*=list i]:not(li,a,button, input, textarea),
        
        [role*=navigation i]:not(li,a,button, input, textarea), 
        [role*=menu i]:not(li,a,button, input, textarea), 
        [role*=list i]:not(li,a,button, input, textarea), 
        [role*=nav i]:not(li,a,button, input, textarea), 
        [role*=bar i]:not(li,a,button, input, textarea), 
        [role*=header i]:not(li,a,button, input, textarea),
        
        [aria-label*=navigation i]:not(li,a,button, input, textarea), 
        [aria-label*=menu i]:not(li,a,button, input, textarea), 
        [aria-label*=list i]:not(li,a,button, input, textarea), 
        [aria-label*=nav i]:not(li,a,button, input, textarea), 
        [aria-label*=bar i]:not(li,a,button, input, textarea), 
        [aria-label*=header i]:not(li,a,button, input, textarea)
        `;
        /** @inheritDoc */
        static getCandidates(rootElement) {
            //Getting all the elements that matches the selector
            let matchedElements = Array.from(rootElement.querySelectorAll(this.CandidatesSelector));
            //Filtering out elements that are not visible or are not a descendent of the body
            matchedElements = matchedElements.filter(this.isElementVisible).filter(this.isBodyDescendent);
            return matchedElements;
        }
        /**
         * Retrieves the best predicted element of each of the given `type`s.
         * Query for candidates, calculates the prediction score and return the element with the highest
         * score if higher than the `ScoreThreshold` otherwise will return `null`
         */
        static predict() {
            let features = [];
            let candidates = [];
            for (const rootElement of this.getAllRootElements()) {
                candidates = candidates.concat(this.getCandidates(rootElement));
                features = features.concat(candidates.map((candidate) => this.getFeatures(candidate)));
            }
            //if (features.length === 0) continue;
            const scores = this.inference({ features });
            const highestScore = Math.max(...scores);
            const highestScoreIndex = scores.indexOf(highestScore);
            if (highestScore > this.ScoreThreshold) {
                return [candidates[highestScoreIndex]];
            }
            return [];
        }
        /**
         * Retrieves all the root elements from the page, including the document itself and all shadowDom root elements
         * @private
         */
        static getAllRootElements() {
            return [
                document,
                ...Array.from(document.querySelectorAll("*"))
                    .filter((element) => element.shadowRoot)
                    .map((element) => element.shadowRoot),
            ];
        }
        /**
         * Handles the inference of the given `features` using the model of the given `type`
         * loads the model and normalize the features
         * @param features the  features to normalize
         * @param type the type of the model to load
         */
        static inference({ features }) {
            const featuresAs3dArray = features.map((featureSet) => this.ModelFeatures.map((key) => featureSet[key]));
            const scores = [];
            for (const featureVector of featuresAs3dArray) {
                scores.push(Model(featureVector)[1]);
            }
            return scores;
        }
        /**
         * Determines whether given `element` is visible to the user
         */
        static isElementVisible(element) {
            const style = window.getComputedStyle(element);
            let visibleDimensions = true;
            if (element.offsetWidth <= 1 || element.offsetHeight <= 1) {
                visibleDimensions = false;
                for (const child of Array.from(element.querySelectorAll("*"))) {
                    if (child.offsetWidth > 1 && child.offsetHeight > 1) {
                        visibleDimensions = true;
                        break;
                    }
                }
            }
            return style.opacity !== "0" && style.visibility !== "hidden" && style.display !== "none" && visibleDimensions;
        }
        /**
         * Determines whether given `element` is a descendent of the body element
         * @param element
         */
        static isBodyDescendent(element) {
            return document.body !== element && document.documentElement !== element;
        }
        /**
         * Retrieves the bounding client rect of the given `element`
         * @param element
         */
        static getBoundingClientRect(element) {
            const rects = element.getBoundingClientRect();
            return {
                top: rects.top + window.scrollY,
                right: rects.right + window.scrollX,
                bottom: rects.bottom + window.scrollY,
                left: rects.left + window.scrollX,
                width: rects.width,
                height: rects.height,
            };
        }
        /**
         * Retrieves an object/list of features for given `element`
         * */
        static getFeatures(element) {
            const clientRect = this.getBoundingClientRect(element);
            const pageRect = {
                height: Math.max(document.body.scrollHeight, document.documentElement.scrollHeight),
                width: Math.max(document.body.scrollWidth, document.documentElement.scrollWidth),
            };
            const visibleChildren = Array.from(element.querySelectorAll("*")).filter(ClassifierBase.isElementVisible);
            const absoluteClientRect = this.calculateElementPositionAndDimensions(element);
            const content = [element, ...visibleChildren]
                .map((child) => {
                let response = "";
                for (const childNode of Array.from(child.childNodes)) {
                    if (childNode.nodeType === Node.TEXT_NODE) {
                        response += childNode.textContent;
                    }
                }
                return response.replace(/[\n\s]/g, "");
            })
                .join("")
                .replace(/\s/g, "");
            const lowerCasedContent = content.toLowerCase();
            const computedStyle = window.getComputedStyle(element);
            const viewport = {
                width: window.innerWidth || document.documentElement.clientWidth,
                height: window.innerHeight || document.documentElement.clientHeight,
            };
            const parents = ClassifierBase.getParents(element);
            const response = {};
            for (const [featureKey, featureProvider] of Object.entries(this.Features)) {
                if (!this.ModelFeatures.includes(featureKey)) {
                    continue;
                }
                response[featureKey] = featureProvider({
                    element,
                    content,
                    lowerCasedContent,
                    clientRect,
                    absoluteClientRect,
                    visibleChildren,
                    parents,
                    viewport,
                    pageRect,
                    computedStyle,
                });
                response[featureKey] = parseFloat(response[featureKey].toPrecision(3));
            }
            return response;
        }
        /**
         * Mapping of a dictionary key (english) to an array of its translations on every language
         */
        static MultilingualWords = Object.entries(wordsDictionary).reduce((acc, [language, words]) => {
            for (const [wordKey, wordValue] of Object.entries(words)) {
                acc[wordKey] = acc[wordKey] || [];
                acc[wordKey].push(wordValue.toLowerCase());
            }
            return acc;
        }, {});
        /**
         * List of features for this classification
         */
        static Features = {
            //Dimensions
            height: ({ absoluteClientRect }) => Math.min(1000, absoluteClientRect.height),
            width: ({ absoluteClientRect }) => Math.min(2500, absoluteClientRect.width),
            x: ({ absoluteClientRect }) => Math.min(Math.max(-100, absoluteClientRect.left), 2500),
            y: ({ absoluteClientRect }) => Math.min(Math.max(-100, absoluteClientRect.top), 2000),
            height_percentage: ({ pageRect, absoluteClientRect }) => (absoluteClientRect.height ? absoluteClientRect.height / pageRect.height : 0),
            width_percentage: ({ pageRect, absoluteClientRect }) => (absoluteClientRect.width ? absoluteClientRect.width / pageRect.width : 0),
            x_percentage: ({ pageRect, absoluteClientRect }) => (absoluteClientRect.left ? absoluteClientRect.left / pageRect.width : 0),
            y_percentage: ({ pageRect, absoluteClientRect }) => (absoluteClientRect.top ? absoluteClientRect.top / pageRect.height : 0),
            aspect_ratio: ({ absoluteClientRect }) => (absoluteClientRect.width && absoluteClientRect.height ? absoluteClientRect.width / absoluteClientRect.height : 0),
            //content
            upper_case_portion: ({ content }) => (content.length ? 1 - content.replace(/[A-Z]/g, "").length / content.length : 0),
            alpha_portion: ({ lowerCasedContent }) => (lowerCasedContent.length ? lowerCasedContent.replace(/[\d\s!@#$%^&*()-_\r\n]/g, "").length / lowerCasedContent.length : 0),
            numeric_portion: ({ lowerCasedContent }) => (lowerCasedContent.length ? (lowerCasedContent.length - lowerCasedContent.replace(/[\d\r\n]/g, "").length) / lowerCasedContent.length : 0),
            digit_count: ({ lowerCasedContent }) => lowerCasedContent.length - lowerCasedContent.replace(/[\d\r\n]/g, "").length,
            visible_text_content_length: ({ lowerCasedContent }) => Math.min(lowerCasedContent.length, 1000),
            //Dom elements
            num_of_inputs: ({ visibleChildren }) => visibleChildren.filter((element) => element.tagName === "INPUT").length,
            num_of_buttons: ({ visibleChildren }) => visibleChildren.filter((element) => element.tagName === "BUTTON").length,
            num_of_textareas: ({ visibleChildren }) => visibleChildren.filter((element) => element.tagName === "TEXTAREA").length,
            num_of_selects: ({ visibleChildren }) => visibleChildren.filter((element) => element.tagName === "SELECT").length,
            num_of_links: ({ visibleChildren }) => visibleChildren.filter((element) => element.tagName === "A").length,
            num_of_images: ({ visibleChildren }) => visibleChildren.filter(this.isImage).length,
            num_of_videos: ({ visibleChildren }) => visibleChildren.filter((element) => element.tagName === "VIDEO").length,
            num_of_iframes: ({ visibleChildren }) => visibleChildren.filter((element) => element.tagName === "IFRAME").length,
            num_of_svgs: ({ visibleChildren }) => visibleChildren.filter((element) => element.tagName === "SVG").length,
            num_of_img: ({ visibleChildren }) => visibleChildren.filter((element) => element.tagName === "IMG").length,
            num_of_video: ({ visibleChildren }) => visibleChildren.filter((element) => element.tagName === "VIDEO").length,
            num_of_other_elements: ({ visibleChildren }) => visibleChildren.filter((element) => element.matches(":not(input,button,textarea,select,a,img,video,iframe,p)")).length,
            num_of_social_links: ({ visibleChildren }) => visibleChildren.filter((element) => element.matches("a[href*=facebook], a[href*=twitter], a[href*=instagram], a[href*=youtube], a[href*=linkedin], a[href*=instagram] ")).length,
            //Existing words
            indicative_word_home: ({ lowerCasedContent }) => (new RegExp(ClassifierBase.MultilingualWords["Home"].join("|")).test(lowerCasedContent) ? 1 : 0),
            indicative_word_about: ({ lowerCasedContent }) => (new RegExp(ClassifierBase.MultilingualWords["About"].join("|")).test(lowerCasedContent) ? 1 : 0),
            indicative_word_services: ({ lowerCasedContent }) => (new RegExp(ClassifierBase.MultilingualWords["Services"].join("|")).test(lowerCasedContent) ? 1 : 0),
            indicative_word_products: ({ lowerCasedContent }) => (new RegExp(ClassifierBase.MultilingualWords["Products"].join("|")).test(lowerCasedContent) ? 1 : 0),
            indicative_word_contact: ({ lowerCasedContent }) => (new RegExp(ClassifierBase.MultilingualWords["Contact"].join("|")).test(lowerCasedContent) ? 1 : 0),
            indicative_word_blog: ({ lowerCasedContent }) => (new RegExp(ClassifierBase.MultilingualWords["Blog"].join("|")).test(lowerCasedContent) ? 1 : 0),
            indicative_word_shop: ({ lowerCasedContent }) => (new RegExp(ClassifierBase.MultilingualWords["Shop"].join("|")).test(lowerCasedContent) ? 1 : 0),
            indicative_word_faq: ({ lowerCasedContent }) => (new RegExp(ClassifierBase.MultilingualWords["FAQ"].join("|")).test(lowerCasedContent) ? 1 : 0),
            indicative_word_careers: ({ lowerCasedContent }) => (new RegExp(ClassifierBase.MultilingualWords["Careers"].join("|")).test(lowerCasedContent) ? 1 : 0),
            indicative_word_news: ({ lowerCasedContent }) => (new RegExp(ClassifierBase.MultilingualWords["News"].join("|")).test(lowerCasedContent) ? 1 : 0),
            indicative_word_testimonials: ({ lowerCasedContent }) => (new RegExp(ClassifierBase.MultilingualWords["Testimonials"].join("|")).test(lowerCasedContent) ? 1 : 0),
            indicative_word_portfolio: ({ lowerCasedContent }) => (new RegExp(ClassifierBase.MultilingualWords["Portfolio"].join("|")).test(lowerCasedContent) ? 1 : 0),
            indicative_word_support: ({ lowerCasedContent }) => (new RegExp(ClassifierBase.MultilingualWords["Support"].join("|")).test(lowerCasedContent) ? 1 : 0),
            indicative_word_events: ({ lowerCasedContent }) => (new RegExp(ClassifierBase.MultilingualWords["Events"].join("|")).test(lowerCasedContent) ? 1 : 0),
            indicative_word_gallery: ({ lowerCasedContent }) => (new RegExp(ClassifierBase.MultilingualWords["Gallery"].join("|")).test(lowerCasedContent) ? 1 : 0),
            indicative_word_team: ({ lowerCasedContent }) => (new RegExp(ClassifierBase.MultilingualWords["Team"].join("|")).test(lowerCasedContent) ? 1 : 0),
            indicative_word_pricing: ({ lowerCasedContent }) => (new RegExp(ClassifierBase.MultilingualWords["Pricing"].join("|")).test(lowerCasedContent) ? 1 : 0),
            indicative_word_copyright: ({ lowerCasedContent }) => (new RegExp(ClassifierBase.MultilingualWords["Copyright"].join("|")).test(lowerCasedContent) ? 1 : 0),
            indicative_word_tel: ({ lowerCasedContent }) => (new RegExp(ClassifierBase.MultilingualWords["Tel"].join("|")).test(lowerCasedContent) ? 1 : 0),
            indicative_word_address: ({ lowerCasedContent }) => (new RegExp(ClassifierBase.MultilingualWords["Address"].join("|")).test(lowerCasedContent) ? 1 : 0),
            indicative_word_terms_and_conditions: ({ lowerCasedContent }) => (new RegExp(ClassifierBase.MultilingualWords["TermsAndCondition"].join("|")).test(lowerCasedContent) ? 1 : 0),
            indicative_word_privacy_policy: ({ lowerCasedContent }) => (new RegExp(ClassifierBase.MultilingualWords["PrivacyPolicy"].join("|")).test(lowerCasedContent) ? 1 : 0),
            indicative_word_powered: ({ lowerCasedContent }) => (new RegExp(ClassifierBase.MultilingualWords["Powered"].join("|")).test(lowerCasedContent) ? 1 : 0),
            indicative_word_search: ({ lowerCasedContent }) => (new RegExp(ClassifierBase.MultilingualWords["Search"].join("|")).test(lowerCasedContent) ? 1 : 0),
            indicative_word_all_rights_reserved: ({ lowerCasedContent }) => (new RegExp(ClassifierBase.MultilingualWords["All_rights_reserved"].join("|")).test(lowerCasedContent) ? 1 : 0),
            indicative_word_copyright_sign: ({ lowerCasedContent }) => (lowerCasedContent.indexOf("©") > -1 ? 1 : 0),
            distance_from_bottom_of_page: ({ clientRect, pageRect }) => Math.max(0, pageRect.height - clientRect.bottom),
            distance_from_bottom_of_page_percent: ({ clientRect, pageRect }) => Math.max(0, pageRect.height - clientRect.bottom) / pageRect.height,
            is_out_of_the_page: ({ absoluteClientRect, pageRect }) => (absoluteClientRect.bottom - 20 < 0 || absoluteClientRect.right - 20 < 0 || absoluteClientRect.top + 20 > pageRect.height || absoluteClientRect.left + 20 > pageRect.width ? 1 : 0),
            /**
             * Determine whether given element is hidden due to being overflowed relative to one of it's parents that has `overflow: hidden`
             */
            is_overflowing: ({ clientRect, parents }) => {
                for (const parent of parents) {
                    const style = window.getComputedStyle(parent);
                    if (style.overflow === "hidden") {
                        const parentClientRect = parent.getBoundingClientRect();
                        if (clientRect.top + 20 < parentClientRect.top || clientRect.bottom - 20 > parentClientRect.bottom || clientRect.left + 20 < parentClientRect.left || clientRect.right - 20 > parentClientRect.right) {
                            return 1;
                        }
                    }
                }
                return 0;
            },
            is_in_fold: ({ absoluteClientRect, viewport }) => (absoluteClientRect.top < viewport.height ? 1 : 0),
            is_fixed: ({ computedStyle }) => (computedStyle.position === "fixed" ? 1 : 0),
            has_fixed_parent: ({ parents }) => (parents.filter((element) => window.getComputedStyle(element).position === "fixed").length ? 1 : 0),
            is_tagname_ul: ({ element }) => (element.tagName === "UL" ? 1 : 0),
            is_tagname_ol: ({ element }) => (element.tagName === "OL" ? 1 : 0),
            is_tagname_li: ({ element }) => (element.tagName === "LI" ? 1 : 0),
            is_tagname_nav: ({ element }) => (element.tagName === "NAV" ? 1 : 0),
            is_tagname_p: ({ element }) => (element.tagName === "P" ? 1 : 0),
            is_tagname_menu: ({ element }) => (element.tagName === "MENU" ? 1 : 0),
            is_tagname_header: ({ element }) => (element.tagName === "HEADER" ? 1 : 0),
            is_tagname_footer: ({ element }) => (element.tagName === "FOOTER" ? 1 : 0),
            is_tagname_section: ({ element }) => (element.tagName === "SECTION" ? 1 : 0),
            is_tagname_content: ({ element }) => (element.tagName === "CONTENT" ? 1 : 0),
            is_tagname_div: ({ element }) => (element.tagName === "DIV" ? 1 : 0),
            number_of_parent_with_tagname_ul: ({ parents }) => parents.filter((element) => element.tagName === "UL").length,
            number_of_parent_with_tagname_ol: ({ parents }) => parents.filter((element) => element.tagName === "OL").length,
            number_of_parent_with_tagname_li: ({ parents }) => parents.filter((element) => element.tagName === "LI").length,
            number_of_parent_with_tagname_nav: ({ parents }) => parents.filter((element) => element.tagName === "NAV").length,
            number_of_parent_with_tagname_p: ({ parents }) => parents.filter((element) => element.tagName === "P").length,
            number_of_parent_with_tagname_menu: ({ parents }) => parents.filter((element) => element.tagName === "MENU").length,
            number_of_parent_with_tagname_header: ({ parents }) => parents.filter((element) => element.tagName === "HEADER").length,
            number_of_parent_with_tagname_footer: ({ parents }) => parents.filter((element) => element.tagName === "FOOTER").length,
            number_of_parent_with_tagname_section: ({ parents }) => parents.filter((element) => element.tagName === "SECTION").length,
            number_of_parent_with_tagname_content: ({ parents }) => parents.filter((element) => element.tagName === "CONTENT").length,
            number_of_parent_with_tagname_div: ({ parents }) => parents.filter((element) => element.tagName === "DIV").length,
            number_of_visible_headers: ({ visibleChildren }) => visibleChildren.filter((element) => element.tagName === "HEADER").length,
            number_of_visible_uls: ({ visibleChildren }) => visibleChildren.filter((element) => element.tagName === "UL").length,
            number_of_visible_ols: ({ visibleChildren }) => visibleChildren.filter((element) => element.tagName === "OL").length,
            number_of_visible_p: ({ visibleChildren }) => visibleChildren.filter((element) => element.tagName === "P").length,
            number_of_visible_lis: ({ visibleChildren }) => visibleChildren.filter((element) => element.tagName === "LI").length,
            number_of_visible_navs: ({ visibleChildren }) => visibleChildren.filter((element) => element.tagName === "NAV").length,
            number_of_visible_menus: ({ visibleChildren }) => visibleChildren.filter((element) => element.tagName === "MENU").length,
            number_of_visible_footer: ({ visibleChildren }) => visibleChildren.filter((element) => element.tagName === "FOOTER").length,
            number_of_visible_section: ({ visibleChildren }) => visibleChildren.filter((element) => element.tagName === "SECTION").length,
            number_of_visible_content: ({ visibleChildren }) => visibleChildren.filter((element) => element.tagName === "CONTENT").length,
            number_of_visible_div: ({ visibleChildren }) => visibleChildren.filter((element) => element.tagName === "DIV").length,
            number_of_visible_elements: ({ visibleChildren }) => visibleChildren.length,
            number_of_visible_direct_children: ({ visibleChildren, element }) => visibleChildren.filter((element) => element.parentElement === element).length,
            have_img_larger_than_50_px: ({ visibleChildren }) => visibleChildren.filter((element) => this.isImage(element) && (element.height > 50 || element.width > 50)).length,
            have_img_larger_than_100_px: ({ visibleChildren }) => visibleChildren.filter((element) => this.isImage(element) && (element.height > 100 || element.width > 100)).length,
            parents_count: ({ parents }) => parents.length,
            font_size: ({ computedStyle }) => parseInt(computedStyle.fontSize),
            font_weight: ({ computedStyle }) => parseInt(computedStyle.fontWeight),
        };
    }

    function scoreLanguage(text, langDict = languageDictionary, langAlphabet = SingleLetterLanguages) {
        const words = text.split(' ');
        const scoreDict = {};
        for (const lang in langDict) {
            if (!langAlphabet.includes(lang)) {
                scoreDict[lang] = 0;
                for (const word of langDict[lang]) {
                    scoreDict[lang] += words.filter((w) => w === word).length;
                }
            }
        }
        for (const l of langAlphabet) {
            scoreDict[l] = 0;
            for (const word of langDict[l]) {
                scoreDict[l] += text.split(word).length - 1;
            }
        }
        let totalScore = 0;
        for (const key in scoreDict) {
            totalScore += scoreDict[key];
        }
        if (totalScore === 0) {
            return null;
        }
        let keyMaxValue = Object.keys(scoreDict)[0];
        for (const key in scoreDict) {
            if (scoreDict[key] > scoreDict[keyMaxValue]) {
                keyMaxValue = key;
            }
        }
        return keyMaxValue;
    }
    /**
     * @param text
     */
    const SupportedLanguages = {
        EN: 'en',
        HE: 'he',
        AR: 'ar',
        UK: 'uk',
        RU: 'ru',
        ES: 'es',
        FR: 'fr',
        IT: 'it',
        DE: 'de',
        PT: 'pt',
        PL: 'pl',
        NL: 'nl',
        HU: 'hu',
        SL: 'sl',
        CS: 'cs',
        SK: 'sk',
        TR: 'tr',
        JA: 'ja',
        ZH: 'zh',
    };
    const SingleLetterLanguages = [SupportedLanguages.AR, SupportedLanguages.JA, SupportedLanguages.ZH, SupportedLanguages.HE];
    const languageDictionary = {
        [SupportedLanguages.EN]: ['the', 'be', 'to', 'of', 'and', 'that', 'have', 'it', 'for', 'not', 'on', 'with', 'he', 'she', 'we', 'they', 'you', 'is', 'are', 'this', 'was', 'me', 'my', 'your', 'his', 'her', 'their', 'in', 'as', 'at', 'by', 'or', 'if', 'do', 'so', 'an', 'up', 'but', 'no', 'on', 'can', 'who', 'what', 'about', 'more', 'out', 'will', 'now'],
        [SupportedLanguages.HE]: ['א', 'ב', 'ג', 'ד', 'ה', 'ו', 'ז', 'ח', 'ט', 'י', 'כ', 'ל', 'מ', 'נ', 'ס', 'ע', 'פ', 'צ', 'ק', 'ר', 'ש', 'ת', 'ו', 'ז', 'ח', 'ט', 'י', 'כ', 'ל', 'מ', 'נ', 'ס', 'ע', 'פ', 'צ', 'ק', 'ר', 'ש', 'ת'],
        [SupportedLanguages.ES]: ['de', 'la', 'que', 'el', 'en', 'los', 'del', 'se', 'las', 'por', 'un', 'para', 'con', 'su', 'al', 'más', 'es', 'como', 'pero', 'le', 'ha', 'me', 'si', 'sin', 'yo', 'este', 'ya', 'lo', 'son', 'su', 'año', 'día', 'si', 'bien', 'dos', 'sí', 'donde', 'muy', 'hay', 'poco', 'está', 'vez', 'hace', 'tiene', 'era', 'ser', 'fue', 'vida', 'hoy'],
        [SupportedLanguages.FR]: ['de', 'la', 'le', 'et', 'les', 'en', 'des', 'du', 'une', 'pour', 'par', 'est', 'sur', 'plus', 'qui', 'dans', 'avec', 'ce', 'il', 'au', 'ne', 'être', 'on', 'que', 'se', 'mais', 'elle', 'tout', 'ceux', 'cela', 'aux', 'nos', 'ses', 'ont', 'peut', 'sans', 'si', 'bien', 'après', 'encore', 'fait', 'être', 'fois', 'moins', 'ans', 'aussi', 'très', 'peu', 'être', 'tout', 'no', 'un'],
        [SupportedLanguages.DE]: ['die', 'und', 'der', 'in', 'zu', 'den', 'das', 'mit', 'es', 'ist', 'ein', 'ich', 'nicht', 'eine', 'sich', 'auf', 'für', 'von', 'werden', 'haben', 'wir', 'sie', 'der', 'ich', 'du', 'das', 'es', 'nicht', 'ein', 'und', 'sich', 'sie', 'der', 'wir', 'in', 'den', 'von', 'mit', 'auf', 'für', 'ist', 'ein', 'ich', 'zu', 'das', 'sich', 'es'],
        [SupportedLanguages.AR]: ['في', 'من', 'على', 'أن', 'الى', 'إلى', 'مع', 'كان', 'هذا', 'بين', 'هو', 'لا', 'ما', 'الله', 'هذه', 'و', 'لم', 'لن', 'كل', 'له', 'إذا', 'لكن', 'أو', 'قد', 'فيه', 'ذلك', 'كما', 'لما', 'به', 'لو', 'لهذا', 'منذ', 'عن', 'هم', 'هنا', 'ومن', 'هنالك', 'كيف', 'هي', 'هون', 'ذلك', 'لهذه', 'بي', 'أنا', 'نحن', 'أنت', 'إليه', 'ا', 'ب', 'ت', 'ث', 'ج', 'ح', 'خ', 'د', 'ذ', 'ر', 'ز', 'س', 'ش', 'ص', 'ض', 'ط', 'ظ', 'ع', 'غ', 'ف', 'ق', 'ك', 'ل', 'م', 'ن', 'ه', 'و', 'ي'],
        [SupportedLanguages.ZH]: ['的', '我', '你', '是', '了', '他', '她', '我们', '在', '这', '也', '可以', '不', '说', '什么', '这个', '一', '有', '吗', '来', '那', '个', '好', '要', '会', '就', '你们', '对', '不是', '得', '没', '能', '去', '过', '对不起', '着', '给', '只', '多', '用', '才', '把', '中', '说话', '没有', '现在', '问题'],
        [SupportedLanguages.IT]: ['di', 'il', 'la', 'che', 'del', 'in', 'per', 'un', 'non', 'una', 'mi', 'ha', 'sono', 'questo', 'ci', 'ma', 'quando', 'più', 'sono', 'io', 'tu', 'lui', 'lei', 'noi', 'voi', 'loro', 'cosa', 'come', 'quando', 'dove', 'qui', 'me', 'te', 'lo', 'la', 'li', 'le', 'gli', 'ne', 'se', 'ma', 'anche', 'ancora', 'bene', 'fare', 'dopo', 'fino', 'già', 'su'],
        [SupportedLanguages.JA]: ['ほ', 'ま', 'き', 'テ', 'へ', 'め', 'ち', 'リ', 'エ', 'コ', 'よ', 'あ', 'じ', 'り', 'ト', 'の', 'ろ', 'どう', 'ん', 'シ', 'せ', 'ワ', 'ネ', 'ン', 'ナ', 'とき', 'について', 'オ', 'レ', 'を', 'ウ', 'たい', 'サ', 'ひ',
            'ロ', 'はい', 'か', 'え', 'ゆ', 'ヨ', 'ある', 'て', 'や', 'ケ', 'なる', 'ので', 'しょう', 'ヌ', 'ア', 'フ', 'わ', 'ム', 'メ', 'ニ', 'ソ', 'さ', 'だ', 'つ', 'セ', 'お', 'ヲ', 'ホ', 'ヤ', 'タ', 'く', 'ぬ', 'ハ', 'ね', 'ふ',
            'ヘ', 'る', 'カ', 'だけ', 'と', 'ス', 'ため', 'ます', 'ラ', 'け', 'し', 'ず', 'ツ', 'ノ', 'が', 'できる', 'ない', 'う', 'ユ', 'そ', 'ヒ', 'すぎる', 'い', 'な', 'イ', 'す', 'ミ', 'こ', 'チ', 'ク', 'から', 'に', 'モ', 'キ', 'れ',
            'ル', 'ら', 'で', 'がる', 'た', 'も', 'み', 'む', 'こと', 'かん', 'しん', 'は', 'マ'],
        [SupportedLanguages.PT]: ['de', 'que', 'do', 'em', 'um', 'para', 'com', 'não', 'uma', 'os', 'se', 'porque', 'mais', 'meu', 'são', 'por', 'isso', 'mas', 'eu', 'esse', 'está', 'como', 'também', 'nada', 'todo', 'tem', 'quem', 'ou', 'na', 'no', 'seu', 'dos', 'à', 'aos', 'das', 'às', 'foi', 'essa', 'eu', 'ele', 'ela', 'nos', 'nas', 'me', 'te', 'lhe', 'lhes', 'um', 'uma'],
        [SupportedLanguages.RU]: ['и', 'не', 'на', 'что', 'как', 'я', 'то', 'это', 'вы', 'он', 'но', 'же', 'из', 'ли', 'к', 'от', 'его', 'она', 'их', 'мы', 'все', 'бы', 'для', 'сейчас', 'еще', 'до', 'о', 'но', 'за', 'всего', 'или', 'так', 'вот', 'ты', 'его', 'в', 'с', 'по', 'же', 'из-за', 'всей', 'ни', 'есть', 'лишь', 'даже', 'если', 'под', 'быть'],
        [SupportedLanguages.UK]: ['не', 'на', 'як', 'що', 'ви', 'вони', 'так', 'але', 'він', 'до', 'по', 'за', 'це', 'вона', 'ми', 'ваш', 'ваша', 'їх', 'його', 'їй', 'йому', 'тут', 'там', 'ало', 'ось', 'от', 'ось', 'щоб', 'ще', 'ти', 'я', 'в', 'з', 'було', 'якщо', 'теж', 'нас', 'також', 'був', 'ні', 'й', 'мене', 'мені', 'йому', 'його', 'дуже', 'ніж', 'для', 'о', 'за', 'не'],
        [SupportedLanguages.NL]: ['de', 'van', 'ik', 'te', 'dat', 'die', 'een', 'hij', 'het', 'niet', 'zijn', 'je', 'met', 'aan', 'voor', 'op', 'er', 'om', 'mij', 'nu', 'doen', 'gaan', 'heb', 'ben', 'was', 'wat', 'wij', 'heeft', 'deze', 'kan', 'dit', 'als', 'zo', 'worden', 'zal', 'hier', 'moet', 'ze', 'dan', 'goed', 'weet', 'waar', 'naar', 'wie', 'zit', 'dat', 'mijn'],
        [SupportedLanguages.PL]: ['nie', 'że', 'się', 'jest', 'co', 'ty', 'ja', 'ta', 'oni', 'teraz', 'tutaj', 'jeszcze', 'bardzo', 'gdzie', 'kto', 'twoje', 'moje', 'nasze', 'wasze', 'można', 'tylko', 'więc', 'ale', 'czy', 'tak', 'do', 'tego', 'mnie', 'nas', 'was', 'dla', 'kiedy', 'by', 'jak', 'przez', 'być', 'niego', 'już', 'niech', 'więcej', 'coś', 'ależ', 'jesteś', 'jestem', 'była', 'dość'],
        [SupportedLanguages.TR]: ['ve', 'bir', 'bu', 'da', 'de', 'ne', 'ben', 'sen', 'için', 'ile', 'evet', 'var', 'yok', 'ama', 'şu', 'şimdi', 'neden', 'nasıl', 'çok', 'şey', 'benim', 'senin', 'bizim', 'sizin', 'onun', 'burada', 'orada', 'burası', 'şeyi', 'onlar', 'olarak', 'bunu', 'ancak', 'iyi', 'önce', 'sana', 'bana', 'kendi', 'gibi', 'şunu', 'zaman', 'tüm', 'iki', 'biri', 'olan', 'bana', 'sana', 'to', 'the', 'on', 'al'],
        [SupportedLanguages.SK]: ['ako', 'aj', 'ale', 'ani', 'čo', 'či', 'do', 'ho', 'ja', 'je', 'jeho', 'jej', 'ju', 'kde', 'keď', 'ma', 'mi', 'mne', 'mu', 'my', 'na', 'ne', 'nie', 'nič', 'od', 'on', 'oni', 'po', 'pre', 'sa', 'si', 'som', 'ste', 'su', 'ta', 'tak', 'toto', 'ty', 'viac', 'vo', 'za', 'že', 'len', 'preto', 'ktorý', 'alebo'],
        [SupportedLanguages.SL]: ['in', 'je', 'na', 'za', 'se', 'ga', 'da', 'ni', 'ne', 'kot', 'ali', 'so', 'po', 'pri', 'sem', 'tudi', 'bi', 'me', 'jih', 'ampak', 'ko', 'že', 'imam', 'če', 's', 'sem', 'pa', 'smo', 'bom', 'tega', 'ali', 'kaj', 'več', 'tvoje', 'ali', 'od', 'to', 'lahko', 'no', 'le', 'sem', 'nas', 'naj', 'bo', 'pri', 'tega', 'vse', 'kje', 'tega'],
        [SupportedLanguages.HU]: ['az', 'és', 'vagy', 'nem', 'egy', 'de', 'van', 'ha', 'nincs', 'aki', 'azt', 'mint', 'ez', 'ért', 'el', 'még', 'két', 'csak', 'egyik', 'amit', 'ő', 'ők', 'mi', 'te', 'azok', 'most', 'vagyok', 'nagy', 'mert', 'hogy', 'tud', 'ne', 'ha', 'szeretem', 'olyan', 'is', 'le', 'volt', 'azért', 'nem', 'őket', 'hogyan', 'már', 'kell', 'több', 'itt', 'minden', 'vagyok', 'tudok', 'leszek'],
        [SupportedLanguages.CS]: ['je', 'na', 'se', 'co', 'do', 'ne', 'pro', 'jsem', 'jako', 'ale', 'si', 'tak', 'za', 'mi', 'po', 'jak', 'že', 'jsou', 'nějak', 'toto', 'také', 'mám', 'tady', 'byl', 'byla', 'už', 'což', 'nic', 'jen', 'ještě', 'ano', 'ani', 'nebo', 'kdo', 'tady', 'když', 'teď', 'moc', 'dost', 'mě', 'tím', 'takže', 'proto', 'či', 'než', 'více', 'ještě', 'které', 'jedna', 'jedno']
    };

    /**
     * @classdesc detects the language of the given text
     */
    class ClassifierLanguage extends ClassifierBase {
        /**
         * Query the model for the language based on given `text`
         * @param text
         */
        static predict(request) {
            return scoreLanguage(request.text) || SupportedLanguages.EN;
        }
    }

    /**
     * NOTE: This service has different behavior than the other services in the project.
     * it encapsulates the logic of setting the locale for the dictionary used by the engine.
     * it must run before the detection process as some detectors rely on dictionary data.
     */
    /**
     * LanguageService is responsible for detecting the most appropriate locale for the current website
     * and setting it using the application's i18n system.
     *
     * It uses the following sources (in priority order):
     *   1. The <html lang="..."> attribute
     *   2. The <meta http-equiv="Content-Language" content="..."> tag
     *   3. Fallback: Machine language prediction via AccessWidget
     */
    class LanguageService {
        // Set of supported locale codes (e.g., "en", "he", "de", etc.)
        static supportedLocales = new Set(Object.values(distExports.LocaleEnum));
        /**
         * Detects the most relevant language based on standard document/browser heuristics,
         * and sets it via the core dictionary engine. Falls back to ML-based language prediction if needed.
         */
        static async detectAndSetLocale() {
            // Get <html lang="...">
            const htmlLang = document.documentElement.lang?.toLowerCase();
            // Get <meta http-equiv="Content-Language" content="...">
            const metaLangTag = document.querySelector('meta[http-equiv="Content-Language"]');
            const metaLang = metaLangTag?.getAttribute("content")?.toLowerCase() || null;
            // Combine and normalize all sources into a list of language candidates
            const candidates = [this.normalize(htmlLang), this.normalize(metaLang)].filter(Boolean);
            // Find the first supported language match
            const matchedLocale = candidates.find((lang) => this.supportedLocales.has(lang));
            if (matchedLocale) {
                distExports.addLocale(matchedLocale);
            }
            else {
                // Fallback: use machine learning to predict language from actual page content
                const text = document.body?.innerText?.slice(0, 1000);
                if (text) {
                    const locale = ClassifierLanguage.predict({ text });
                    if (this.supportedLocales.has(locale)) {
                        distExports.addLocale(locale);
                    }
                }
            }
        }
        /**
         * Returns the currently active locale.
         */
        static get locales() {
            return distExports.getLocales();
        }
        /**
         * Normalizes a language code by stripping regional suffixes (e.g., "en-US" → "en")
         */
        static normalize(lang) {
            if (!lang)
                return null;
            return lang.split("-")[0];
        }
    }

    const MAX_TEXT_LENGTH$1 = 20;
    /**
     * Detector whether the given clickable element is a link checkout.
     */
    class PerceivableComponentLinkCheckout extends PerceivableDetector {
        /** @inheritDoc */
        static id = "perceivable-component-link-checkout";
        /** @inheritDoc */
        static skipChildrenWhen = "positive";
        /** @inheritDoc */
        static subsetOf = [PerceivableTraitClickable, PerceivableTraitVisible];
        /** @inheritDoc */
        static detect(element, classifier) {
            const { visibleText } = classifier.getOperations(element).contentInfo;
            if (visibleText.length < MAX_TEXT_LENGTH$1 && distExports.textContainsWords(visibleText, ["checkout", "check_out"])) {
                return true;
            }
            return false;
        }
    }

    /**
     * Detector whether the given clickable element is a button.
     */
    class PerceivableComponentButton extends PerceivableDetector {
        /** @inheritDoc */
        static id = "perceivable-component-button";
        /** @inheritDoc */
        static skipChildrenWhen = "positive";
        /** @inheritDoc */
        static subsetOf = [PerceivableTraitClickable];
        static notSubsetOf = [PerceivableComponentLinkCheckout];
        /** @inheritDoc */
        static detect(element, classifier) {
            if (element.tagName === "BUTTON") {
                return true;
            }
            if (isButtonLikeAnchor(element)) {
                return true;
            }
            /**
             * This check is required to avoid considering all links as buttons
             * At this point we know that the element is not a button and not a button like anchor
             * hence we can safely return false for all anchor tags
             */
            if (element.tagName === "A") {
                return false;
            }
            if (isButtonLikeInput(element)) {
                return true;
            }
            const operations = classifier.getOperations(element);
            if (this.isIconButton(element, operations)) {
                return true;
            }
            /**
             * The following condition is far from ideal.
             * It is required to avoid many false negatives, but it will also introduce some false positives.
             * The only accurate way of achieving this would be to check whether an element has an event listener or a delegate event listener.
             * Finding delegate event listeners is not possible without changing how users implement the widget's snippet in their code.
             */
            const commonButtonTagsWhenClickable = ["SPAN", "IMG", "I", "LI", "DIV"];
            if (commonButtonTagsWhenClickable.includes(element.tagName)) {
                return true;
            }
            //TODO: Check if relevant
            // if(element.tagName === "LABEL" && !element.closest("form")) {
            //     return true;
            // }
            return false;
        }
        /**
         * Determines whether the given element is an icon button.
         * An Icon button is a button that contains only an icon and no text.
         * Supports the following cases:
         * 1. emoji
         * 2. svg icon
         * 3. font icon
         * 4. image icon
         * 5. <i> tag with icon
         * 6. before/after pseudo elements with icon
         * @param element the element to check
         * @param operations the instance of the classifier
         */
        static isIconButton(element, operations) {
            if (/^\p{Emoji}+$/u.test(operations.contentInfo.visibleText)) {
                return true;
            }
            if (operations.contentInfo.hasVisibleText) {
                return false;
            }
            if (element.querySelector("svg, img, i")) {
                return true;
            }
            const hasPseudoElementContent = Boolean(operations.contentInfo.pseudoBefore.content || operations.contentInfo.pseudoAfter.content);
            if (hasPseudoElementContent) {
                return true;
            }
            return false;
        }
    }

    /**
     * Detector whether the given element is considered a graphic element.
     */
    class PerceivableComponentGraphic extends PerceivableDetector {
        /** @inheritDoc */
        static id = "perceivable-component-graphic";
        /** @inheritDoc */
        static skipChildrenWhen = "positive";
        /** @inheritDoc */
        static subsetOf = [PerceivableTraitRenderable];
        /** @inheritDoc */
        static notSubsetOf = [PerceivableTraitClickable];
        /** @inheritDoc */
        static detect(element, classifier) {
            if (["img", "svg", "canvas"].includes(element.localName)) {
                return true;
            }
            const operations = classifier.getOperations(element);
            return this.isImageLikeElement(operations);
        }
        /**
         * Determines whether the given element is an image based on it's background image. and visible content.
         * @param operations - The operations to use.
         * @private
         */
        static isImageLikeElement(operations) {
            const hasBackgroundImage = operations.colorInfo.backgroundImage !== "none";
            if (!hasBackgroundImage) {
                return false;
            }
            return !operations.contentInfo.hasVisibleText;
        }
    }

    /**
     * Detector whether the given clickable element is a button.
     */
    class PerceivableComponentLink extends PerceivableDetector {
        /** @inheritDoc */
        static id = "perceivable-component-link";
        /** @inheritDoc */
        static skipChildrenWhen = "positive";
        /** @inheritDoc */
        static subsetOf = [PerceivableTraitClickable, PerceivableTraitRenderable];
        /** @inheritDoc */
        static notSubsetOf = [PerceivableComponentButton];
        /** @inheritDoc */
        static detect(element) {
            return element.tagName === "A";
        }
    }

    /**
     * Detector whether the given clickable element is a button.
     */
    class PerceivableComponentLinkAnchor extends PerceivableDetector {
        /** @inheritDoc */
        static id = "perceivable-component-link-anchor";
        /** @inheritDoc */
        static skipChildrenWhen = "positive";
        /** @inheritDoc */
        static subsetOf = [PerceivableComponentLink];
        /** @inheritDoc */
        static detect(element) {
            if (!isParsableURL(element.href, window.location.href)) {
                return false;
            }
            const hash = new URL(element.href, window.location.href).hash;
            if (!hash || !element.getAttribute("href").startsWith("#")) {
                return false;
            }
            if (!CSS.supports(`selector(${hash})`)) {
                return false;
            }
            let anchoredElement = document.querySelector(hash);
            if (anchoredElement) {
                return true;
            }
            // if no anchored element was found, try to decode the hash and see if there's an element
            const decodeHash = decodeURIComponent(hash);
            anchoredElement = document.querySelector(decodeHash);
            return Boolean(anchoredElement);
        }
    }

    /**
     * Detector whether the given clickable element is a application link.
     * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/a#href
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Navigator/registerProtocolHandler#syntax
     */
    class PerceivableComponentLinkApplication extends PerceivableDetector {
        /** @inheritDoc */
        static id = "perceivable-component-link-application";
        /** @inheritDoc */
        static skipChildrenWhen = "positive";
        /** @inheritDoc */
        static subsetOf = [PerceivableComponentLink];
        /** @inheritDoc */
        static notSubsetOf = [PerceivableComponentLinkAnchor];
        /** @inheritDoc */
        static detect(element) {
            if (isInstanceOf(element, HTMLAnchorElement)) {
                const applicationLinkValues = ["web+", "bitcoin:", "ftp:", "ftps:", "geo:", "im:", "irc:", "ircs:", "magnet:", "mailto:", "matrix:", "mms:", "news:", "nntp:", "openpgp4fpr:", "sftp:", "sip:", "sms:", "smsto:", "ssh:", "tel:", "urn:", "webcal:", "wtai:", "xmpp:"];
                for (const value of applicationLinkValues) {
                    if (element.href.startsWith(value)) {
                        return true;
                    }
                }
            }
            return false;
        }
    }

    /**
     * Detector whether the given clickable element is a navigation link.
     */
    class PerceivableComponentLinkNavigation extends PerceivableDetector {
        /** @inheritDoc */
        static id = "perceivable-component-link-navigation";
        /** @inheritDoc */
        static skipChildrenWhen = "positive";
        /** @inheritDoc */
        static subsetOf = [PerceivableComponentLink];
        /** @inheritDoc */
        static notSubsetOf = [PerceivableComponentLinkAnchor, PerceivableComponentLinkApplication];
        /** @inheritDoc */
        static detect() {
            return true;
        }
    }

    /**
     * Detector whether the given element is considered an image.
     */
    class PerceivableComponentImage extends PerceivableDetector {
        /** @inheritDoc */
        static id = "perceivable-component-image";
        /** @inheritDoc */
        static skipChildrenWhen = "positive";
        /** @inheritDoc */
        static subsetOf = [PerceivableComponentGraphic];
        /** @inheritDoc */
        static detect(element) {
            return !["svg", "canvas"].includes(element.localName);
        }
    }

    class PerceivableComponentRadioButton extends PerceivableDetector {
        /** @inheritDoc */
        static id = "perceivable-component-radio-button";
        /** @inheritDoc */
        static skipChildrenWhen = "positive";
        /** @inheritDoc */
        static subsetOf = [PerceivableTraitVisible];
        /** @inheritDoc */
        static dependencies = [PerceivableTraitVisible];
        /** PerceivableComponentCheckbox extends this class - overrides the type to be checkbox */
        static htmlType = "radio";
        static classifier;
        /** @inheritDoc */
        static detect(element, classifier) {
            this.classifier = classifier;
            let radioButtons = [];
            if (this.isSemanticAndVisible(element)) {
                return true;
            }
            if (element.tagName === "LABEL") {
                radioButtons = this.getInputRelatedToLabel(element);
            }
            else {
                const typeSelector = `input[type=${this.htmlType}]`;
                const children = element.children;
                for (let i = 0; i < children.length; i++) {
                    const child = children[i];
                    if (child.matches(typeSelector)) {
                        radioButtons.push(child);
                    }
                }
            }
            if (radioButtons.length !== 1) {
                // we're looking for a single radio, if we find more than one, we're probably too high in the tree.
                // we want the closest element to the input to be detected as a radio-button
                return false;
            }
            const radio = radioButtons[0];
            const isHidden = !classifier.assert(radio, PerceivableTraitVisible);
            if (!isHidden) {
                // we're looking for a hidden radio, if it's shown, it's probably a compliant radio
                return false;
            }
            return true;
        }
        /**
         * Get the input related to a label element
         * based on the `for` attribute or the children of the label
         * @param element
         */
        static getInputRelatedToLabel(element) {
            let radioButtons = [];
            const inputId = element.getAttribute("for");
            if (inputId) {
                const input = document.getElementById(inputId);
                if (input && input.matches(`input[type=${this.htmlType}]`)) {
                    radioButtons = [input];
                }
            }
            else {
                radioButtons = Array.from(element.querySelectorAll(`input[type=${this.htmlType}]`));
            }
            return radioButtons;
        }
        /**
         * Check if the element is a semantic radio button and is visible
         * This avoids processing compliant radio buttons that are already visible.
         * @param element
         */
        static isSemanticAndVisible(element) {
            return element.matches(`input[type=${this.htmlType}]`) && this.classifier.assert(element, PerceivableTraitVisible);
        }
    }

    class PerceivableComponentCheckbox extends PerceivableComponentRadioButton {
        /** @inheritDoc */
        static id = "perceivable-component-checkbox";
        /** @inheritDoc */
        static skipChildrenWhen = "positive";
        /** @inheritDoc */
        static subsetOf = [PerceivableTraitVisible];
        /** @inheritDoc */
        static htmlType = "checkbox";
    }

    /**
     * @class HTMLRelationalMap
     * @description A class that represents a two-way WeakMap of HTML elements and their relations.
     * @template KeyElement The type of the key element in the map.
     * @template Relations The type of the relations object in the map.
     * @implements {WeakMap}
     */
    class HTMLRelationalMap {
        /**
         * The map that stores the key elements and their relations.
         * @private
         */
        keyToRelationsMap = new WeakMap();
        /**
         * The map that stores the related elements and their key elements.
         * @private
         * @remarks This map is used to quickly find the key element of a related element.
         */
        relativeToKeyMap = new WeakMap();
        /**
         * @constructor
         * @param entries The entries to initialize the map with.
         * @remarks The entries should be an array of key-value pairs where the key is the key element and the value is the relations object.
         */
        constructor(entries) {
            if (!entries) {
                return;
            }
            for (const [keyElement, relatedElements] of entries) {
                this.set(keyElement, relatedElements);
            }
        }
        /**
         * @method get
         * @description Get the relations of a key element.
         * @param keyElement
         */
        get(keyElement) {
            return this.keyToRelationsMap.get(keyElement);
        }
        /**
         * @method has
         * @description Check if the map has a key element.
         * @param keyElement
         */
        has(keyElement) {
            return this.keyToRelationsMap.has(keyElement);
        }
        /**
         * @method delete
         * @description Delete a key element and its relations from the map.
         * @param keyElement
         * @returns {boolean} Returns true if the key element was deleted successfully, otherwise false.
         * @remarks This method also deletes the related elements from the relativeToKeyMap.
         */
        delete(keyElement) {
            const relations = this.keyToRelationsMap.get(keyElement);
            if (!relations) {
                return false;
            }
            let result = this.keyToRelationsMap.delete(keyElement);
            for (const relation of Object.values(relations)) {
                if (!relation) {
                    continue;
                }
                if (isInstanceOf(relation, Node)) {
                    // this is a one-to-one relation
                    result = result && this.relativeToKeyMap.delete(relation);
                    continue;
                }
                // The relation is a one-to-many relation
                for (const relative of relation) {
                    result = result && this.relativeToKeyMap.delete(relative);
                }
                continue;
            }
            return result;
        }
        /**
         * @method set
         * @description Set the relations of a key element.
         * @param keyElement
         * @param relations
         * @remarks This method also sets the related elements in the relativeToKeyMap.
         */
        set(keyElement, relations) {
            this.keyToRelationsMap.set(keyElement, relations);
            for (const relation of Object.values(relations)) {
                if (!relation)
                    continue;
                if (isInstanceOf(relation, Node)) {
                    // this is a one-to-one relation
                    this.relativeToKeyMap.set(relation, keyElement);
                    continue;
                }
                // The relation is a one-to-many relation
                for (const relative of relation) {
                    this.relativeToKeyMap.set(relative, keyElement);
                }
            }
            return this;
        }
        /**
         * @method getKeyByRelative
         * @description Get the key element of a related element.
         * @param valueElement
         */
        getKeyByRelative(valueElement) {
            return this.relativeToKeyMap.get(valueElement);
        }
        [Symbol.toStringTag];
    }

    class ComboboxSelectContext extends Context {
        /** @inheritDoc */
        data = {
            elementStore: new HTMLRelationalMap(),
        };
        /**
         * Sets the select data for the given element.
         * @param element - The element to set the data to.
         * @param data - The triggers, options container, and options of the select.
         */
        set({ element, data }) {
            this.data.elementStore.set(element, { ...this.data.elementStore.get(element), ...data });
        }
        /**
         * Gets the parent select of the element
         * @param element
         */
        getParentSelect(element) {
            const parentSelect = this.data.elementStore.getKeyByRelative(element);
            return parentSelect || null;
        }
    }

    /**
     * Detects if an element can be perceived as a custom select (combobox-select)
     * @reference WAI Combobox Select only pattern - https://www.w3.org/WAI/ARIA/apg/patterns/combobox/examples/combobox-select-only/
     */
    class PerceivableComponentComboboxSelect extends PerceivableDetector {
        /** @inheritDoc */
        static id = "perceivable-component-combobox-select";
        /** @inheritDoc */
        static skipChildrenWhen = "positive";
        /** @inheritDoc */
        static subsetOf = [PerceivableTraitRenderable, PerceivableTraitVisible];
        /** @inheritDoc */
        static notSubsetOf = [];
        // TODO: replace PerceivableComponentSelectOptions with a "ListLike" detector when implemented
        static dependencies = [CompliantTraitInteractable, PerceivableTraitClickable, PerceivableTraitTabbable, CompliantComponentSelectOption];
        /** @inheritDoc */
        static contextType = ComboboxSelectContext;
        static classifier;
        /** taken from popular UI libraries
         * @see [the list can be found here](SELECT.md#list-of-known-class-names)
         * */
        static listOfKnownClassNames = [".select__control", ".dropdown-container", ".rmsc.multi-select", ".rc-select", ".react-dropdown-select", ".MuiSelect-select", ".rt-SelectTrigger", ".ant-select"].join(", ");
        /** tags that are not likely to be a select component*/
        static tagNamesToAvoid = ["input", "textarea", "span", "button", "iframe", "pre", "del", "s", "table", "tr", "td", "dialog", "tbody", "th", "i", "b", "strong"];
        /** elements that are not likely to be the trigger to open the options */
        static triggerSelectorsToAvoid = ["input:not([type='button'])", "textarea"].join(", ");
        /** @inheritDoc */
        static detect(element, classifier, _, context) {
            this.classifier = classifier;
            if (isInstanceOf(element, HTMLSelectElement)) {
                // if native select then check that it isn't a multiple or multi-line select because this changes the appearance from a combo-box to a list-box
                if (element.multiple || element.size > 1) {
                    return false;
                }
                const options = new Set(classifier.getMatched([CompliantComponentSelectOption], element));
                context.set({ element, data: { trigger: element, optionsContainer: element, options } });
                return true;
            }
            if (element.matches(this.listOfKnownClassNames)) {
                return true;
            }
            if (this.tagNamesToAvoid.includes(element.tagName.toLowerCase())) {
                return false;
            }
            const children = Array.from(element.children).filter(isSvgOrHtmlElement);
            // we assume there should be at least 1 trigger and 1 options container
            if (children.length < 2) {
                return false;
            }
            // consider adding a Trigger detector
            const trigger = children.find((el) => {
                const { contentInfo } = classifier.getOperations(el);
                const hasCaption = contentInfo.hasVisibleText;
                const isActionable = classifier.assert(el, CompliantTraitInteractable) || classifier.assert(el, PerceivableTraitClickable) || classifier.assert(el, PerceivableTraitTabbable);
                return hasCaption && isActionable && !el.matches(this.triggerSelectorsToAvoid);
            });
            if (!trigger) {
                return false;
            }
            // make sure we don't detect the same element as the trigger and also the options-container
            const data = { trigger };
            for (const child of children) {
                if (child === trigger) {
                    continue;
                }
                if (this.detectSelectOptions(child, data)) {
                    data.optionsContainer = child;
                    break;
                }
            }
            if (!data.optionsContainer || !data.options) {
                return false;
            }
            const { layoutInfo: { aspectRatio }, } = classifier.getOperations(element);
            const thresholdAspectRatio = 1.5;
            // If the element's width is less than 1.5 times its height, it's not likely a select element, most of perceived elements are wider than they are tall
            if (aspectRatio < thresholdAspectRatio) {
                return false;
            }
            context.set({ element, data });
            return true;
        }
        static detectSelectOptions(element, data) {
            const children = element.children;
            const childCount = children.length;
            // Assumption: At least 2 children
            if (childCount < 2)
                return false;
            // Check for non-whitespace text nodes
            for (const child of element.childNodes) {
                if (child.nodeType === Node.TEXT_NODE && child.textContent.trim() !== "") {
                    return false;
                }
            }
            // Convert children to array once
            const childElements = Array.from(children);
            // Check consistent tag names and common class
            if (!this.areTaggedSimilarly(childElements)) {
                return false;
            }
            const optionCandidates = this.getOptionCandidates(element);
            const optionTexts = [];
            for (const candidate of optionCandidates) {
                const text = candidate.textContent.trim();
                if (text.length > 50)
                    return false;
                optionTexts.push(text);
            }
            // At least 2 non-empty, unique, and not too long options
            const nonEmptyOptions = optionTexts.filter((text) => text.length > 0);
            if (nonEmptyOptions.length < 2 || new Set(optionTexts).size !== optionTexts.length) {
                return false;
            }
            // Check consistent styles across options
            if (!this.areStylesConsistent(optionCandidates)) {
                return false;
            }
            data.options = new Set(optionCandidates);
            return true;
        }
        /**
         * Gets an array of all the individual text contents of all children of an element.
         * @param element - The element to get the text content of.
         * @returns The text content of all children of the element.
         */
        static getOptionCandidates(element) {
            const optionCandidates = [];
            for (const child of element.children) {
                const grandChildren = child.children;
                // Case 1: Leaf node, or single simple wrapper
                if (grandChildren.length === 0 || (grandChildren.length === 1 && grandChildren[0].children.length < 2)) {
                    optionCandidates.push(child);
                    continue;
                }
                // Case 2: Multiple grandChildren
                if (grandChildren.length > 1) {
                    // If grandchildren are not tagged similarly, treat the child as a candidate
                    const grandChildrenArray = Array.from(grandChildren);
                    if (!this.areTaggedSimilarly(grandChildrenArray)) {
                        optionCandidates.push(child);
                    }
                    else {
                        // Otherwise, dive deeper recursively
                        optionCandidates.push(...this.getOptionCandidates(child));
                    }
                }
            }
            return optionCandidates;
        }
        /**
         * Checks if all children have the same tag name and include the most common class among the children
         * @param children - The children to check.
         * @private
         */
        static areTaggedSimilarly(children) {
            const referenceTagName = children[0].tagName;
            if (children.some((child) => child.tagName !== referenceTagName)) {
                return false;
            }
            // Determine the most common class among the children
            const classFrequency = {};
            for (const child of children) {
                for (const className of child.classList) {
                    if (!classFrequency[className]) {
                        classFrequency[className] = 0;
                    }
                    classFrequency[className]++;
                }
            }
            const classKeys = Object.keys(classFrequency);
            if (classKeys.length > 0) {
                const baseClass = classKeys.reduce((a, b) => (classFrequency[a] > classFrequency[b] ? a : b), classKeys[0]);
                // Check if all children have the same tag name and include the base class
                if (children.some((child) => !child.classList.contains(baseClass))) {
                    return false;
                }
            }
            return true;
        }
        /**
         * Checks if all children have the same width, font size, font family, and font weight
         * @param children - The children to check.
         * @returns Whether the children have consistent styles.*/
        static areStylesConsistent(children) {
            const operations = this.classifier.getOperations(children[0]);
            const { typographyInfo: referenceTypography } = operations;
            const typographyPropertiesToCheck = ["fontSize", "fontFamily", "fontWeight"];
            for (const child of children) {
                if (child === children[0]) {
                    continue;
                }
                const { typographyInfo: childTypography } = this.classifier.getOperations(child);
                if (!typographyPropertiesToCheck.every((property) => childTypography[property] === referenceTypography[property])) {
                    return false;
                }
            }
            const { layoutInfo: referenceLayout } = operations;
            const layoutPropertiesToCheck = ["width"];
            for (const child of children) {
                if (child === children[0]) {
                    continue;
                }
                const { layoutInfo: childLayout } = this.classifier.getOperations(child);
                if (!layoutPropertiesToCheck.every((property) => childLayout[property] === referenceLayout[property])) {
                    return false;
                }
            }
            return true;
        }
    }

    /**
     * The maximum size of an icon
     * This value is arbitrary and can be adjusted
     *
     * The number is calculated using: 48dp * DPR (Device Pixel Ratio) = The maximum icon size in pixels.
     *
     * Based on the following considerations:
     * 1. On desktops the DPR is about 1-2, and on mobile devices it's about 2-3.
     *   Therefore, the maximum icon size using the formula will be from 48dp * 1 = 48px to 48 * 3 = 144px.
     *
     * 2. According to fontAwesome's documentation, the 2XL (2 Extra Large) size is 2em,
     *   if we consider the default 16px font-size it's equivalent to 32px, therefore 48px (on a DPR = 1) is likely to be safe;
     *   larger icons can be simply considered as images, or large graphic elements.
     *
     * 3. In IBM's design language (see reference below) the recommended largest icon size is 32px. (< 48px which is the lowest possible value for DPR = 1)
     *
     * 4. According to Material design, the largest recommended icon size is 48dp.
     *
     * @see https://docs.fontawesome.com/web/style/size
     * @see https://www.ibm.com/design/language/iconography/ui-icons/usage/
     * @see https://m3.material.io/styles/icons/designing-icons
     * @see https://cloudinary.com/glossary/device-pixel-ratio
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio
     */
    const MAX_ICON_SIZE_PX = 48 * window.devicePixelRatio; // equivalent to 48dp in pixels
    /**
     * Detector whether the given element is considered an icon.
     */
    class PerceivableComponentIcon extends PerceivableDetector {
        /** @inheritDoc */
        static id = "perceivable-component-icon";
        /** @inheritDoc */
        static skipChildrenWhen = "positive";
        /** @inheritDoc */
        static subsetOf = [PerceivableTraitVisible];
        /** @inheritDoc */
        static notSubsetOf = [CompliantComponentInput];
        /** @inheritDoc */
        static dependencies = [PerceivableComponentGraphic];
        /** @inheritDoc */
        static detect(element, classifier) {
            if (this.visibleTextIsRenderedAsIcon(element)) {
                return true;
            }
            return this.isIconLikeGraphic(element, classifier) || this.isElementFontBasedIconLike(element, classifier);
        }
        /**
         * Check if the element's text node is rendered as an icon.
         */
        static visibleTextIsRenderedAsIcon(element) {
            const child = this.getOnlyChildTextNode(element);
            if (child && child.nodeValue?.trim()) {
                const rect = new NodeRects(child).nodeContentsBoundingClientRect;
                if (this.isTextRenderedAsIcon(rect) &&
                    this.isWithinMaxIconSize({
                        height: rect.height,
                        width: rect.width,
                    })) {
                    return true;
                }
            }
            return false;
        }
        /**
         * checks if the element has only a single child text node and returns it
         */
        static getOnlyChildTextNode(element) {
            if (element.childNodes.length === 1) {
                const child = element.childNodes[0];
                if (child.nodeType === Node.TEXT_NODE) {
                    return child;
                }
            }
            return null;
        }
        /**
         * if the a (single) text node has equal height and width we consider it an icon
         * floor or ceil to support different browsers
         * TODO: other possibilites include cloning the elment into an off-screen iframe and not applying icon styles to it in order to get the rect of the text itself.
         * if the cloned element rect is vastly different than the original element rect, we can conclude that the original element is an icon.
         */
        static isTextRenderedAsIcon(rect) {
            return Math.floor(rect.height) === Math.floor(rect.width) || Math.ceil(rect.height) === Math.ceil(rect.width);
        }
        /**
         * If the element is a graphic element, has no text, and it's sufficiently small, we'll consider it an icon.
         * @param element
         * @param classifier
         * @private
         */
        static isIconLikeGraphic(element, classifier) {
            const isGraphic = classifier.assert(element, PerceivableComponentGraphic);
            if (!isGraphic) {
                return false;
            }
            const { width, height } = classifier.getOperations(element).layoutInfo;
            return this.isWithinMaxIconSize({
                height,
                width,
            });
        }
        static isWithinMaxIconSize({ height, width }) {
            return width <= MAX_ICON_SIZE_PX && height <= MAX_ICON_SIZE_PX;
        }
        /**
         * Determines whether the given element is a font-based icon, based on its font-family difference with its parent and pseudo-element content.
         * @param element
         * @param classifier
         * @private
         */
        static isElementFontBasedIconLike(element, classifier) {
            const elementFontFamily = classifier.getOperations(element).typographyInfo.fontFamily;
            const elementContentInfo = classifier.getOperations(element).contentInfo;
            if (element.parentElement) {
                const parentFontFamily = classifier.getOperations(element.parentElement).typographyInfo.fontFamily;
                if (elementFontFamily === parentFontFamily) {
                    return false;
                }
            }
            return Boolean(elementContentInfo.pseudoAfter.content) || Boolean(elementContentInfo.pseudoBefore.content);
        }
    }

    class CarouselContext extends Context {
        /** @inheritDoc */
        data = {
            elementStore: new Map(),
        };
        /**
         * Sets the table data for the given element.
         * @param element - The element to set the data to.
         * @param data - The rows and cells of the table.
         */
        set({ element, data }) {
            this.data.elementStore.set(element, { ...this.data.elementStore.get(element), ...data });
        }
        /**
         * Gets the connected carousel element of the given element.
         * @param element - The element to get the connected carousel of.
         * @param controlType - The type of control to get the connected carousel of.
         */
        getConnectedCarousel(element, controlType) {
            const carousels = Array.from(this.data.elementStore.keys());
            for (const carousel of carousels) {
                const carouselButtons = this.data.elementStore.get(carousel);
                const control = carouselButtons[controlType];
                if (Array.isArray(control)) {
                    if (control.includes(element)) {
                        return carousel;
                    }
                }
                else if (control === element) {
                    return carousel;
                }
            }
            return null;
        }
    }

    function calculateTotalDistance(elements, classifier) {
        return elements.reduce((distance, picker, currentIndex) => {
            if (currentIndex === 0) {
                return distance;
            }
            const previousPicker = elements[currentIndex - 1];
            const { rect: pickerRect } = classifier.getOperations(picker).layoutInfo;
            const { rect: previousPickerRect } = classifier.getOperations(previousPicker).layoutInfo;
            return distance + getElementProximity(pickerRect, previousPickerRect).x;
        }, 0);
    }

    /*
     * This value is used to determine the approximate position of the slide picker buttons.
     * The slide picker buttons are usually placed at the bottom of the carousel,
     * so we can use this value to determine if the given element is a slide picker.
     * For example, for the value 25, we will check if the element is placed in the bottom (or top) 25% of the carousel.
     * If it is, we can assume that it is a slide picker.
     */
    const CAROUSEL_COMPONENT_TYPES = ["previous", "next", "carouselSlidePicker"];
    const CAROUSEL_CONTENT_WORDS = ["carousel", "slideshow", "rotator", "slider", "swiper"];
    const MAX_CAROUSEL_HEIGHT = 1000;
    /**
     * Detect whether the given element is a carousel.
     */
    class PerceivableComponentCarousel extends PerceivableDetector {
        /** @inheritDoc */
        static id = "perceivable-component-carousel";
        /** @inheritDoc */
        static skipChildrenWhen = "positive";
        /** @inheritDoc */
        static subsetOf = [PerceivableTraitVisible];
        /** @inheritDoc */
        static notSubsetOf = [PerceivableTraitClickable, PerceivableTraitTabbable];
        /** @inheritDoc */
        static dependencies = [PerceivableTraitVisible, PerceivableTraitClickable, CompliantComponentListItem, PerceivableComponentIcon, PerceivableTraitClickableRepetitiveStructure];
        /** @inheritDoc */
        static classifier;
        /** @inheritDoc */
        static contextType = CarouselContext;
        /** @inheritDoc */
        static detect(element, classifier, _, context) {
            this.classifier = classifier;
            const children = [];
            for (let i = 0; i < element.children.length; i++) {
                const child = element.children[i];
                if (isSvgOrHtmlElement(child)) {
                    children.push(child);
                }
            }
            // Eliminating elements that are not likely to be carousels
            if (children.length === 0 || !this.hasCarouselContextualStrings(element) || this.hasNonCarouselDimensions(element)) {
                return false;
            }
            const buttons = this.getClickablesOfRepetitiveStructures(element);
            if (buttons.length < 2) {
                return false;
            }
            // Getting the buttons that are likely to be carousel buttons based on attributes or position
            const carouselButtons = buttons.reduce((buttonCandidates, button) => {
                if (!buttonCandidates.previous) {
                    if (this.isElementComponentMatchFittingType(button, "previous")) {
                        buttonCandidates.previous = button;
                        return buttonCandidates;
                    }
                    if (this.isElementInCorrectPositionOrderInDOM(button, buttons, "previous")) {
                        buttonCandidates.previous = button;
                        return buttonCandidates;
                    }
                }
                if (!buttonCandidates.next) {
                    if (this.isElementComponentMatchFittingType(button, "next")) {
                        buttonCandidates.next = button;
                        return buttonCandidates;
                    }
                    if (this.isElementInCorrectPositionOrderInDOM(button, buttons, "next")) {
                        buttonCandidates.next = button;
                        return buttonCandidates;
                    }
                }
                if (this.doesElementHaveSlidePickerDimensions(button, element) && this.isElementPositionedLikeSlidePicker(button, element)) {
                    buttonCandidates.slidePickers.push(button);
                    return buttonCandidates;
                }
                return buttonCandidates;
            }, { previous: null, next: null, slidePickers: [] });
            if (carouselButtons.slidePickers.length) {
                carouselButtons.slidePickers = this.filterSlidePickersByHorizontalAlignment(carouselButtons.slidePickers);
            }
            if (children.some((child) => this.isCarouselContainer(child, carouselButtons))) {
                return false;
            }
            // If not all slide picker buttons have the same visibility, we can't be sure they are slide picker buttons
            if (carouselButtons.slidePickers.length) {
                const expectedPickerVisibility = classifier.assert(carouselButtons.slidePickers[0], PerceivableTraitVisible);
                if (carouselButtons.slidePickers.some((picker) => classifier.assert(picker, PerceivableTraitVisible) !== expectedPickerVisibility)) {
                    carouselButtons.slidePickers = [];
                }
            }
            if ((carouselButtons.previous && carouselButtons.next) || carouselButtons.slidePickers.length > 1) {
                context.set({ element, data: carouselButtons });
                return true;
            }
            return false;
        }
        /**
         * Checks if the given element has contextual strings that are likely to match a carousel.
         * @param element
         * @private
         */
        static hasCarouselContextualStrings(element) {
            const { contextInfo } = this.classifier.getOperations(element);
            const context = contextInfo.elementContexts.next()?.value?.toLowerCase() ?? "";
            return CAROUSEL_CONTENT_WORDS.some((word) => context.includes(word));
        }
        /**
         * Checks if the element has dimensions that are not likely to match a carousel.
         * @param element
         * @private
         */
        static hasNonCarouselDimensions(element) {
            const { layoutInfo } = this.classifier.getOperations(element);
            const { renderedWidth, renderedHeight } = layoutInfo;
            return renderedWidth < 50 || renderedHeight < 50 || renderedHeight > MAX_CAROUSEL_HEIGHT;
        }
        /**
         * Gets all the buttons that are clickable and are part of a repetitive structure under the given element
         * @param element
         */
        static getClickablesOfRepetitiveStructures(element) {
            const buttonsSet = new Set();
            for (const structure of this.classifier.getMatchedInclusive([PerceivableTraitClickableRepetitiveStructure], element)) {
                for (const button of this.classifier.getMatched([PerceivableTraitClickable], structure)) {
                    buttonsSet.add(button);
                }
            }
            return Array.from(buttonsSet);
        }
        /**
         * If the element is matching the "this detectors type" type in componentMatch,
         * and does not match any of the "not this type" types,
         * it is safe to assume the element is the "this detectors type" button.
         */
        static isElementComponentMatchFittingType(element, type) {
            const elementMatchingTypes = this.getComponentMatchTypes(element);
            const isMatchingTypesContainThisType = elementMatchingTypes.includes(type);
            if (isMatchingTypesContainThisType) {
                // If the element matches the desired type, we want to make sure it doesn't fit any other type, to avoid ambiguity
                const notThisType = CAROUSEL_COMPONENT_TYPES.filter((t) => t !== type);
                const isElementMatchesOtherType = elementMatchingTypes.some((type) => notThisType.includes(type));
                if (!isElementMatchesOtherType) {
                    return true;
                }
            }
            return false;
        }
        /**
         * Getting all the buttons that are suspected to be carousel arrows.
         * This is done by filtering the buttons to get all the buttons that either have no matching type or, if they have a type, making sure it's not "carouselSlidePicker".
         * If we are left with two buttons, we check if our where the element is placed in the DOM relatively to the other one.
         * If we're looking for "previous", we check if the element is the former element in the DOM.
         * If we're looking for "next", we check if the element is the latter element in the DOM.
         */
        static isElementInCorrectPositionOrderInDOM(element, carouselButtons, type) {
            const carouselButtonsSuspectedAsArrows = carouselButtons.filter((button) => {
                const matchingTypes = this.getComponentMatchTypes(button);
                return matchingTypes.every((type) => !type) || !matchingTypes.includes("carouselSlidePicker");
            });
            if (carouselButtonsSuspectedAsArrows.length !== 2) {
                return false;
            }
            /**
             * Sorting the buttons based on their order in the DOM.
             * Check this reference bellow for more information about compareDocumentPosition:
             * https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition
             */
            carouselButtonsSuspectedAsArrows.sort((a, b) => (a.compareDocumentPosition(b) === Node.DOCUMENT_POSITION_PRECEDING ? 1 : -1));
            if (type === "previous" && carouselButtonsSuspectedAsArrows[0] === element) {
                return true;
            }
            if (type === "next" && carouselButtonsSuspectedAsArrows[1] === element) {
                return true;
            }
            return false;
        }
        /**
         * This function checks if the given element has dimensions that are likely to match slide picker buttons.
         * @param element
         * @param carouselCandidate
         * @private
         */
        static doesElementHaveSlidePickerDimensions(element, carouselCandidate) {
            const { rect } = this.classifier.getOperations(element).layoutInfo;
            const { rect: carouselRect } = this.classifier.getOperations(carouselCandidate).layoutInfo;
            return rect.width <= carouselRect.width / 5 && rect.height <= carouselRect.height / 5;
        }
        /**
         * This function checks if the given element is positioned within a given parent + margin like a slide picker.
         * Slide picker buttons are usually at the bottom of the carousel, rarely on the top.
         * Basically this function checks if the element is placed in the bottom (or top) third of the carousel height.
         * Check both of the following tests for passing and failing examples:
         *  - atomic-tests/pass/carousel-slide-selectors-found-by-position.html
         *  - atomic-tests/fail/carousel-slide-selectors-missing-position.html
         */
        static isElementPositionedLikeSlidePicker(element, parent) {
            // Element positions
            const { rect: elementRect } = this.classifier.getOperations(element).layoutInfo;
            // Parent positions
            const { rect: parentRect, margin: parentMargin } = this.classifier.getOperations(parent).layoutInfo;
            /**
             * Note: this function runs only after we know the element is contained within the parent.
             * Running this check without validating the element is contained within parent first,
             * WILL CAUSE UNEXPECTED BEHAVIOR
             */
            let maxTopLimit = parentRect.bottom - parentRect.height / 3;
            let maxBottomLimit = parentRect.bottom + parentMargin.bottom;
            if (elementRect.top >= maxTopLimit && elementRect.bottom <= maxBottomLimit) {
                // Selectors on the bottom
                return true;
            }
            maxTopLimit = parentRect.top - parentMargin.top;
            maxBottomLimit = parentRect.top + parentRect.height / 3;
            if (elementRect.top >= maxTopLimit && elementRect.bottom <= maxBottomLimit) {
                // Selectors on the top
                return true;
            }
            return false;
        }
        /**
         * This function filters the slide picker button candidates by their horizontal alignment.
         * @param slidePickers
         * @private
         */
        static filterSlidePickersByHorizontalAlignment(slidePickers) {
            // Grouping slide picker buttons by their horizontal alignments
            const slidePickersByTop = slidePickers.reduce((map, picker) => {
                const top = this.classifier.getOperations(picker).layoutInfo.top;
                if (!map.has(top)) {
                    map.set(top, []);
                }
                map.get(top).push(picker);
                return map;
            }, new Map());
            // Getting the group with the most slide picker buttons where the group size is less than 10 (to avoid false positives)
            const groupLengths = Array.from(slidePickersByTop.values())
                .filter((group) => group.length < 10)
                .map((group) => group.length);
            // If there are no slide picker groups with less than 10 elements, we can't be sure they are slide picker buttons
            if (!groupLengths.length) {
                return [];
            }
            const maxGroupLength = Math.max(...groupLengths);
            const groupsWithMaxLength = Array.from(slidePickersByTop.values()).filter((group) => group.length === maxGroupLength);
            // If there is only one group with the max length, we can assume that it is the slide picker buttons
            if (groupsWithMaxLength.length === 1) {
                return groupsWithMaxLength[0];
            }
            // If there are multiple groups with the same max length, we need to find the group with the minimum total distance between its elements
            let minDistance = Infinity;
            let slidePickerGroupWithMinTotalDistance = [];
            for (const group of groupsWithMaxLength) {
                const totalDistance = calculateTotalDistance(group, this.classifier);
                if (totalDistance < minDistance) {
                    minDistance = totalDistance;
                    slidePickerGroupWithMinTotalDistance = group;
                }
            }
            if (slidePickerGroupWithMinTotalDistance?.length) {
                return slidePickerGroupWithMinTotalDistance;
            }
        }
        /**
         * Checks if any of the children are strong carousel candidates and thus the current element is a container.
         * @param child
         * @param carouselButtons
         * @private
         */
        static isCarouselContainer(child, carouselButtons) {
            if (this.hasNonCarouselDimensions(child)) {
                return false;
            }
            const childButtons = this.getClickablesOfRepetitiveStructures(child);
            return (childButtons.length &&
                Object.values(carouselButtons).every((button) => {
                    if (!button) {
                        return true;
                    }
                    else if (Array.isArray(button)) {
                        return button.every((picker) => childButtons.includes(picker));
                    }
                    else {
                        return childButtons.includes(button);
                    }
                }));
        }
        /**
         * A shorthand function to get the componentMatch types of the given element.
         * Returns an array of the two available types: contextMatching and contentMatching.
         */
        static getComponentMatchTypes(element) {
            const { element: { type: contextMatching }, content: { type: contentMatching }, } = this.classifier.getOperations(element).componentMatch;
            return [contextMatching, contentMatching];
        }
    }

    /**
     * Remove trailing slash from a URL
     */
    const removeTrailingSlash = (url) => {
        return url.replace(/\/$/, "");
    };

    /**
     * Detects a breadcrumb component
     */
    class PerceivableComponentBreadcrumb extends PerceivableDetector {
        /** @inheritDoc */
        static id = "perceivable-component-breadcrumb";
        static skipChildrenWhen = "positive";
        /** @inheritDoc */
        static subsetOf = [PerceivableTraitRenderable, PerceivableTraitVisible];
        /** @inheritDoc */
        /**
         * TODO: add PerceivableComponentPagination to the notSubsetOf once it's implemented
         */
        static notSubsetOf = [PerceivableTraitClickable, PerceivableComponentLinkNavigation, PerceivableComponentCarousel];
        /** @inheritDoc */
        static notChildOf = [PerceivableTraitClickable, PerceivableComponentLinkNavigation];
        static dependencies = [PerceivableTraitClickable, PerceivableTraitVisible, PerceivableComponentLinkNavigation, PerceivableTraitTabbable];
        static maxMatches = 1;
        /** @inheritDoc */
        static classifier;
        /**
         * checks if all links point to the same origin as the current page
         *
         * NOTE: we are removing the subdomain from the origin to compare the origins because some websites have different subdomains for different pages
         *
         * TODO: might want to remove the subdomain removal logic, because it might cause false positives and it's a less common use case
         */
        static allLinksPointToSameOrigin(element) {
            const subdomainRegex = /((.+?)(\.))?/;
            const links = this.getLinkItems(element);
            return links.every((link) => {
                const url = new URL(link.href);
                return url.hostname.replace(subdomainRegex, "") === window.location.hostname.replace(subdomainRegex, "");
            });
        }
        /**
         *  determines if an element's children are too big relative to the document on the y-axis
         */
        static isEelementChildrenTooBig(element) {
            /**
             * `tooBigElementHeight` - the height of an element that is considered too big relative to the document
             */
            const tooBigElementHeight = 50;
            return this.getVisibleChildren(element).some((el) => {
                const { renderedHeight } = this.classifier.getOperations(el).layoutInfo;
                /**
                 * clientRects returns list of more than one if the element is wrapped
                 */
                const numberOfLines = el.getClientRects().length;
                return renderedHeight >= tooBigElementHeight * numberOfLines;
            });
        }
        /**
         * list of textual separators
         */
        static textualSeparators = ["/", "\\", ">", "<", "|", "-", "•"];
        /**
         * checks if a given element's text content is a separator
         */
        static textIsSeparator(element) {
            const { contentInfo } = this.classifier.getOperations(element);
            return isTextLengthInRange(contentInfo.textContentGenerator, { min: 1, max: 2 }) && this.textualSeparators.includes(contentInfo.textContent);
        }
        /**
         * checks if an element has a psuedo element that is a separator
         */
        static hasPseudoSeparator(element) {
            const { content: pseudoAfter } = this.classifier.getOperations(element).resources.computedPseudoAfterStyle;
            const { content: pseudoBefore } = this.classifier.getOperations(element).resources.computedPseudoBeforeStyle;
            return pseudoAfter !== "none" || pseudoBefore !== "none";
        }
        /**
         * checks if the last child of an element is a separator
         */
        static lastChildIsSeparator(element) {
            // Traverse element.children in reverse to find the last valid SVG/HTML element
            const children = element.children;
            for (let i = children.length - 1; i >= 0; i--) {
                const child = children[i];
                if (isSvgOrHtmlElement(child)) {
                    return this.textIsSeparator(child);
                }
            }
            // No valid child found
            return false;
        }
        /**
         * gets all the visible children of an element
         */
        static getVisibleChildren(element) {
            const result = [];
            const children = element.children;
            for (let i = 0; i < children.length; i++) {
                const child = children[i];
                if (isSvgOrHtmlElement(child) && this.classifier.assert(child, PerceivableTraitVisible)) {
                    result.push(child);
                }
            }
            return result;
        }
        /**
         * Checks if there are separators between list items.
         *
         * This function iterates through the visible children of the given element and checks if there are separators between the list items.
         * A separator can be determined by the provided callback function `isElementSeparatorCb`, or if the item is the last child separator, or if it has a pseudo separator.
         */
        static hasSeparatorBetweenListItems(element, isElementSeparatorCb) {
            const listItems = this.getVisibleChildren(element);
            if (listItems.length === 0) {
                return false;
            }
            for (let i = 0; i < listItems.length; i++) {
                const listItem = listItems[i];
                // Determine if the current list item is a separator
                const isSeparator = isElementSeparatorCb(listItem) || this.lastChildIsSeparator(listItem) || this.hasPseudoSeparator(listItem);
                /**
                 * If the index is odd and the item is not a separator, return false.
                 * This ensures that separators are correctly placed between breadcrumb items.
                 * In a typical breadcrumb structure, items are at even indexes (0, 2, 4, ...), and separators are at odd indexes (1, 3, 5, ...).
                 * If an item at an odd index is not a separator, it indicates an invalid breadcrumb structure.
                 */
                if (i % 2 === 1 && !isSeparator) {
                    return false;
                }
            }
            return true;
        }
        /**
         * given an element, gets all the visible clickable elements inside it
         */
        static getElementClickables(element) {
            return this.classifier.getMatchedInclusive([PerceivableTraitClickable, PerceivableTraitVisible], element);
        }
        /**
         * checks if the path of a link is contained by another link
         */
        static linkPathContainedByPreviousLinkPath(linkA, linkB) {
            return linkA.pathname.includes(linkB.pathname);
        }
        /**
         * checks if all link paths are contained by the previous link path
         */
        static allLinkPathContainedByPreviousLinkPath(links) {
            for (let i = 0; i < links.length; i++) {
                if (!links[i + 1]) {
                    break;
                }
                if (!this.linkPathContainedByPreviousLinkPath(links[i + 1], links[i])) {
                    return false;
                }
            }
            return true;
        }
        /**
         * checks if there are duplicate links from a given array of links
         *
         * NOTE: we are comparing the `pathname` of the links because hash links will have the same `pathname` as the current page, while 'href' will be different hence causing false positives
         */
        static hasDuplicateLinks(links) {
            return new Set(links.map((link) => link.pathname)).size !== links.length;
        }
        /**
         * checks if the first list item is a single link breadcrumb
         * @param firstListItem - the first list item of the breadcrumb which contains a link
         *
         */
        static isSingleLinkBreadcrumb(firstListItem) {
            const siblingElement = firstListItem.nextElementSibling;
            if (!isSvgOrHtmlElement(siblingElement)) {
                return false;
            }
            /**
             * TODO: checking for 'li' here is too specific, but without it there would be false positives (breadcrumb-similar-structure--single-link.html).
             * Need to find a better way to check for this
             */
            if ([siblingElement?.localName, firstListItem.localName].includes("li") && !this.isLinkItem(siblingElement)) {
                return true;
            }
            /**
             * if the current list item has psuedo separator, then it's a single link breadcrumb
             */
            if (this.hasPseudoSeparator(firstListItem)) {
                return true;
            }
            /**
             * if the next sibling is a separator or has a psuedo separator, then it's a single link breadcrumb
             */
            if (isSvgOrHtmlElement(siblingElement) && (this.hasPseudoSeparator(siblingElement) || this.textIsSeparator(siblingElement))) {
                return true;
            }
            return false;
        }
        /**
         * the list items are always the level that's before the last level - one before the container of the breadcrumb
         */
        static getListItemsFromLevels(levels) {
            return [...new Set(levels[levels.length - 2] || [])];
        }
        /**
         * determines if the structure of an element is of a  link based breadcrumb
         */
        static isLinkBreadcrumbStructure(element) {
            const repetitivePathOccurrences = getRepetitivePathOccurrences(element, this.getLinkItems(element));
            const children = [...element.children].filter((el) => isSvgOrHtmlElement(el));
            for (const [_, paths] of repetitivePathOccurrences) {
                /**
                 * transpose the matrix to get the levels of the breadcrumb
                 * i.e:
                 * [link, li, div],
                 * [link, li, div]
                 *
                 * to:
                 * [link, link],
                 * [li, li],
                 *
                 */
                const levels = transposeMatrix([...paths]);
                /**
                 * first level must be links (since this is where the traversal starts from in `getRepetitiveLinkPathOccurrences`)
                 *
                 * NOTE: the current types and data structure do not allow for implicit type checking, so we have to cast it to the correct type.
                 * we do not want to change the data structure of `getRepetitiveLinkPathOccurrences` beacause it would be less readable, and also, less performant.
                 * i.e, it would look something like this:
                 * new Map<string, Set<Map<HTMLAnchorElement, SvgOrHtmlElement[]>>>()
                 * and will carry a performance penalty because of the extra checks that would have to be done
                 */
                const links = levels[0];
                /**
                 * if there are duplicate links, then it's not a breadcrumb
                 */
                if (this.hasDuplicateLinks(links)) {
                    return false;
                }
                const listItems = this.getListItemsFromLevels(levels);
                if (listItems.length === 1) {
                    return this.isSingleLinkBreadcrumb(listItems[0]);
                }
                /**
                 * if not all links are contained by the previous link, then it's not a breadcrumb
                 * but, if there is a separator between the list items, then it's a breadcrumb
                 *
                 * TODO: the separator check was added because we cannot eliminate elements simply based on `allLinkPathContainedByPreviousLinkPath`,
                 * because there are sites that don't follow this pattern (i.e: SPA's). e.g: breadcrumb-with-different-path-links.html
                 */
                if (!this.allLinkPathContainedByPreviousLinkPath(links) &&
                    !this.nonTabbableElementsBetweenListItems(children, listItems) &&
                    !this.hasSeparatorBetweenListItems(element, (listItem) => 
                    /**
                     * if the list item is a text-based separator or it's not clickable, then it's a separator
                     */
                    this.textIsSeparator(listItem) || this.getElementClickables(listItem).length === 0)) {
                    return false;
                }
                return this.commonBreadcrumbHeuristics(listItems, (el) => this.isLinkItem(el));
            }
            return false;
        }
        /**
         * determines if between every pair of list items there are non-tabbable elements. this probably means that there is a separator between the list items
         */
        static nonTabbableElementsBetweenListItems(children, listItems) {
            return listItems.every((listItem, i) => {
                const isLastListItem = !listItems[i + 1];
                const elementsBetween = children.slice(children.indexOf(listItem) + 1, children.indexOf(listItems[i + 1])).filter((el) => isSvgOrHtmlElement(el));
                /**
                 * if the current list item is the last one, then there are no elements between, otherwise check if there are any non-tabbable elements between the list items
                 */
                const areElementsBetweenTabbable = isLastListItem ||
                    elementsBetween.some((el) => {
                        return !this.classifier.getMatchedInclusive([PerceivableTraitTabbable, PerceivableTraitVisible], el).length;
                    });
                return areElementsBetweenTabbable || this.hasPseudoSeparator(listItem);
            }, []);
        }
        /**
         * determines if the structure of an element is of a clickable breadcrumb
         */
        static isClickableBreadcrumbStructure(element) {
            const nonLinkClickables = this.getElementClickables(element).filter((el) => !this.isLinkItem(el));
            const children = [...element.children].filter((el) => isSvgOrHtmlElement(el));
            const clickablePathOccurrences = getRepetitivePathOccurrences(element, nonLinkClickables);
            for (const [_, paths] of clickablePathOccurrences) {
                /**
                 * transpose the matrix to get the levels of the breadcrumb
                 * i.e:
                 * [link, li, div],
                 * [link, li, div]
                 *
                 * to:
                 * [link, link],
                 * [li, li],
                 *
                 */
                const levels = transposeMatrix([...paths]);
                const listItems = this.getListItemsFromLevels(levels);
                if (!this.nonTabbableElementsBetweenListItems(children, listItems)) {
                    return false;
                }
                if (!this.hasSeparatorBetweenListItems(element, (listItem) => 
                /**
                 * if the list item is a text-based separator, then it's a separator
                 *
                 * NOTE: we cannot use `getElementClickables` check here because it would cause false positives (quantity-selector-with-breadcrumb-similar-structure.html):
                 * The link based breadcrumb check has much more hueuristics to determine if it's a breadcrumb, and to eliminate false positives such as this,
                 * but the clickable based breadcrumb check can't have the same logic to eliminate false positives, so we cannot use it here.
                 * This also means the clickable based breadcrumb currently doesnt work with: clickable-breadcrumb-with-image-based-separators.html
                 */
                this.textIsSeparator(listItem))) {
                    return false;
                }
                return this.commonBreadcrumbHeuristics(listItems, (el) => this.getElementClickables(el).length > 0);
            }
            return false;
        }
        /**
         * common heuristics for both clickable and link breadcrumbs
         */
        static commonBreadcrumbHeuristics(listItems, isClickable) {
            if (listItems.length > 1) {
                /**
                 * if all list items are the same, then it's not a breadcrumb
                 */
                if (listItems.every((el) => el === listItems[0])) {
                    return false;
                }
                /**
                 * if all list items are siblings and are all clickable but the last one, then it's a breadcrumb (the last item is might not be clickable because it's the current page or a separator)
                 */
                if (allElementsAreSiblings(listItems)) {
                    const allListItemsExceptLastAreClickables = listItems.slice(0, -1).every(isClickable);
                    if (!allListItemsExceptLastAreClickables) {
                        return false;
                    }
                    return true;
                }
            }
            return false;
        }
        /**
         * determines if an element is a link/contains a link
         */
        static getLinkItems(element) {
            return this.classifier.getMatchedInclusive([PerceivableComponentLinkNavigation], element);
        }
        /**
         * determines if an element is a link
         */
        static isLinkItem(element) {
            return this.getLinkItems(element).length > 0;
        }
        /**
         * checks if all menu items are aligned vertically
         */
        static allMenuItemsVertical(element) {
            const elements = this.getVisibleChildren(element);
            if (!elements.length) {
                return false;
            }
            const { rect: referenceRect } = this.classifier.getOperations(elements[0]).layoutInfo;
            return elements.slice(1).every((el) => {
                const { rect } = this.classifier.getOperations(el).layoutInfo;
                return rect.top !== referenceRect.top && (rect.left === referenceRect.left || rect.right === referenceRect.right);
            });
        }
        /**
         *  checks spacing for all elements that are on the same line, since some can be wrapped
         */
        static sameSpacingBetweenInlineElements(element) {
            if (element.children.length === 0) {
                return false;
            }
            const children = [];
            for (let i = 0; i < element.children.length; i++) {
                const child = element.children[i];
                if (isSvgOrHtmlElement(child)) {
                    children.push(child);
                }
            }
            const { top: firstElementTop, bottom: firstElementBottom } = this.classifier.getOperations(children[0]).layoutInfo;
            const elements = this.getVisibleChildren(element).filter((el) => {
                /**
                 * filter out separators
                 */
                if (!this.textIsSeparator(el)) {
                    const { top, bottom } = this.classifier.getOperations(el).layoutInfo;
                    return top === firstElementTop && bottom === firstElementBottom;
                }
                return false;
            });
            return this.sameSpacingBetweenItems(elements);
        }
        /**
         * checks if the spacing between all given elements is the same
         */
        static sameSpacingBetweenItems(elements) {
            const proximities = new Array();
            for (let i = 0; i < elements.length; i++) {
                const child = elements[i];
                const nextChild = elements[i + 1];
                if (!nextChild) {
                    break;
                }
                const rectA = this.classifier.getOperations(child).layoutInfo.rect;
                const rectB = this.classifier.getOperations(nextChild).layoutInfo.rect;
                const proximity = getElementProximity(rectA, rectB);
                proximities.push(proximity);
            }
            const firstProximity = proximities[0];
            // TODO: Math.round is used because the distance calculation from firefox produces floating point numbers which causes false negatives. need to find a better solution
            return proximities.every((proximity) => Math.round(proximity.x) === Math.round(firstProximity.x) && Math.round(proximity.y) === Math.round(firstProximity.y));
        }
        /**
         * checks if the first visible element is not a link
         */
        static firstVisibleElementNotLink(element) {
            const visibleChildren = this.getVisibleChildren(element);
            if (visibleChildren.length === 0) {
                return false;
            }
            const firstChild = visibleChildren[0];
            return !this.isLinkItem(firstChild);
        }
        /**
         * checks if the last item link in a given `elements` array from points to the current page
         * if the last item is not a link the it returns true because the check is irrelevant in this case
         *
         * TODO: might be better to split this into two functions: lastLinkPointsToCurrentPage and lastItemIsLink
         */
        static lastItemLinkPointsToCurrentPage(elements) {
            if (elements.length === 0) {
                return false;
            }
            const lastChild = elements[elements.length - 1];
            const link = this.getLinkItems(lastChild)[0];
            if (link) {
                if (removeTrailingSlash(link.pathname) === removeTrailingSlash(window.location.pathname)) {
                    return true;
                }
            }
            else {
                return true;
            }
            return false;
        }
        /**
         * flattens the breadcrumb structure to get all the elements in the same level
         * NOTE: this is done because some websites have breadcrumbs that are nested in multiple levels (test file:  nested-breadcrumb--ending-element-not-interactable.html)
         */
        static flattenBreadcumbs(elements, arr = []) {
            for (const element of elements) {
                if (this.isLinkBreadcrumbStructure(element)) {
                    return this.flattenBreadcumbs(this.getVisibleChildren(element), arr);
                }
                else {
                    arr.push(element);
                }
            }
            return arr;
        }
        /**
         * given an element, checks if it's attributes contains a keyword that indicates that it's a breadcrumb (i.e: class="breadcrumb", aria-label="Breadcrumb")
         *
         * TODO: replace this with ContextInfo once it's implemented
         */
        static tagContainsBreadcrumbKeyword(element) {
            const includedAttributes = ["class", "id"];
            return (distExports.textContainsWord(element.localName, "breadcrumb") ||
                distExports.textContainsWord(element.localName, "breadcrumbs") || // check the tag name (can be a custom component)
                includedAttributes.some((attr) => {
                    return distExports.textContainsWord(element.getAttribute(attr) ?? "", "breadcrumb") || distExports.textContainsWord(element.getAttribute(attr) ?? "", "breadcrumbs");
                }));
        }
        static isLinkBreadcrumb(element) {
            /**
             * eliniate elements that their first visible child is not a link
             */
            if (this.firstVisibleElementNotLink(element)) {
                return false;
            }
            /**
             * eliminate elements that have links that point to different origins
             */
            if (!this.allLinksPointToSameOrigin(element)) {
                return false;
            }
            /**
             * check if the structure of the repetitive links is a breadcrumb
             */
            if (this.isLinkBreadcrumbStructure(element)) {
                /**
                 * check that all elements are inline and that all inline elements have the same spacing between them
                 * and that the last item link points to the current page
                 *
                 * NOTE:
                 * - we have to flatten the breadcrumbs structure to get all the elements in the same level, otherwise the last item would be a breadcrumb container and not a link and this would cause false positives
                 * - if the last item link doesnt point to the current page, we rely on text detection to determine if it's a breadcrumb via `tagContainsBreadcrumbKeyword`
                 *
                 *
                 * TODO: consider replacing flatten logic with a something that removes elements that have no styling impact on the breadcrumb but are causing false positives
                 * for example, nested breadcrumbs, where the nested breadcrumb is within a span that has no styling impact on the breadcrumb and it would look exactly the same if it was removed
                 */
                if (this.menuItemsPositionedLikeBreadcrumb(element)) {
                    const visibleChildren = this.getVisibleChildren(element);
                    /**
                     * we are flattening items after we have found an initial breadcrumb structure and check to see if there are more nested list items inside of the breadcrumb.
                     * this is done for performance considerations, because we don't want to flatten the entire tree if we don't have an initial breadcrumb structure.
                     */
                    const listItems = this.flattenBreadcumbs(visibleChildren);
                    return this.lastItemLinkPointsToCurrentPage(listItems) || this.tagContainsBreadcrumbKeyword(element);
                }
            }
            return false;
        }
        /**
         * checks if all menu items are not vertical and have the same spacing between them
         */
        static menuItemsPositionedLikeBreadcrumb(element) {
            return !this.allMenuItemsVertical(element) && this.sameSpacingBetweenInlineElements(element);
        }
        /**
         * checks that the element is clickable breadcrumb by checking the structure and the position of the menu items
         */
        static isClickableBreadcrumb(element) {
            return this.isClickableBreadcrumbStructure(element) && this.menuItemsPositionedLikeBreadcrumb(element);
        }
        static detect(element, classifier) {
            this.classifier = classifier;
            /**
             * if the one of the list items is too big relative to the document, then it's not a breadcrumb
             * NOTE:
             * - we are checking aginst the items and not the container because it's possible that the container is too big because it was wrapped in smaller viewport
             * - having this check here is a performance optimization
             * TODO: this looks like a correct assumption, but needs to be tested more
             */
            if (this.isEelementChildrenTooBig(element)) {
                return false;
            }
            return this.isLinkBreadcrumb(element) || this.isClickableBreadcrumb(element);
        }
    }

    /**
     * Notice there is no reference to visibility - this is because there are cases where we want to detect this structure while the element is not visible.
     * A hidden menu, toggle by the menu-trigger (like in dropdowns) is a good example.
     */
    class PerceivableComponentClickablesList extends Detector {
        /** @inheritDoc */
        static id = "perceivable-component-clickables-list";
        /** @inheritDoc */
        static skipChildrenWhen = "never";
        /** @inheritDoc */
        static notSubsetOf = [PerceivableTraitDirectText];
        /** @inheritDoc */
        static subsetOf = [PerceivableTraitClickableRepetitiveStructure];
        /** @inheritDoc */
        static dependencies = [PerceivableTraitClickable, PerceivableTraitClickableRepetitiveStructure];
        static classifier;
        /** @inheritDoc */
        static detect(element, classifier) {
            this.classifier = classifier;
            const { repetitiveItems, clickables } = classifier.getContextData(PerceivableTraitClickableRepetitiveStructure).elementStore.get(element);
            //  Clickable elements in a list are most likely to contain text content and this will prevent false positives
            return this.doesEachRepetitiveItemHaveClickables(repetitiveItems, clickables);
        }
        /**
         * checks if all the repetitive items are/contain clickable elements
         */
        static doesEachRepetitiveItemHaveClickables(repetitiveItems, clickables) {
            const clickablesWithTextContent = new Set();
            const repetitiveItemsWithClickables = new Set();
            for (const el of repetitiveItems) {
                /**
                 * filter out the clickables that are not contained within the list item
                 */
                const elementClickables = clickables.filter((clickable) => el.contains(clickable));
                /**
                 * if there are no clickables in the list item, we can skip this element.
                 * we break out of the loop and return early because we expect all the repetitive items to contain clickables.
                 */
                if (!elementClickables.length) {
                    return false;
                }
                /**
                 * save clickables with discernible text content to be checked later if list items contain discernible clickables
                 */
                for (const clickable of elementClickables) {
                    if (this.classifier.getOperations(clickable).contentInfo.hasTextContent) {
                        clickablesWithTextContent.add(clickable);
                        break; // we only want to check if there's at least one discernible clickable per list item
                    }
                }
                /**
                 * either there's only one clickable in a list item or all the clickables are contained within a sibling of the first clickable in the list item (this eliminates false positives, such as cards with multiple clickables, etc.)
                 * test-case: src/perceivable/components/list-menu/atomic-tests/pass/complex-ul-menu.html
                 */
                if (elementClickables.length === 1) {
                    repetitiveItemsWithClickables.add(el);
                    continue;
                }
                const firstClickable = elementClickables[0];
                const otherClickables = elementClickables.slice(1);
                const firstClickableSiblings = Array.from(firstClickable?.parentElement.children);
                const otherClickablesAncestor = firstClickableSiblings.find((sibling) => sibling?.contains(otherClickables[0]));
                /** Checks structure where the first clickable is the button for the submenu that contains the other clickables
                 * test-case: src/perceivable/components/list-menu/atomic-tests/pass/complex-ul-menu.html
                 */
                if (otherClickables.every((clickable) => otherClickablesAncestor?.contains(clickable))) {
                    repetitiveItemsWithClickables.add(el);
                    continue;
                }
            }
            /**
             *  80% of the items should contain discernible clickables, while all the repetitive items should contain clickables.
             *  this is done due to cases where a list menu has some non-discernible clickables such as images and icons.
             *
             *  test-case: @see file://./atomic-tests/pass/menu-with-some-non-discernible-clickables-list-items.html
             */
            return clickablesWithTextContent.size / repetitiveItems.length >= 0.8 && repetitiveItemsWithClickables.size >= repetitiveItems.length;
        }
    }

    // Detect whether the given clickable element is a carousel "previous slide" button.
    class PerceivableComponentCarouselArrowPrevious extends PerceivableDetector {
        /** @inheritDoc */
        static id = "perceivable-component-carousel-arrow-previous";
        /** @inheritDoc */
        static skipChildrenWhen = "positive";
        /** @inheritDoc */
        static subsetOf = [PerceivableTraitClickable];
        /** @inheritDoc */
        static dependencies = [PerceivableComponentCarousel, PerceivableTraitClickable];
        static arrowType = "previous";
        /** @inheritDoc */
        static detect(element, classifier) {
            const context = classifier.getContext(PerceivableComponentCarousel);
            const connectedCarousel = context.getConnectedCarousel(element, this.arrowType);
            // If we can't connect the element to a carousel, it can't be a "carousel control" button, neither "previous" nor "next"
            if (!connectedCarousel) {
                return false;
            }
            const carouselButtons = context.get().elementStore.get(connectedCarousel);
            if (carouselButtons[this.arrowType] !== element) {
                return false;
            }
            return true;
        }
    }

    // Detect whether the given clickable element is a carousel "next slide" button.
    class PerceivableComponentCarouselArrowNext extends PerceivableComponentCarouselArrowPrevious {
        /** @inheritDoc */
        static id = "perceivable-component-carousel-arrow-next";
        static arrowType = "next";
    }

    /**
     * Detect whether the given clickable element is a carousel slide picker.
     * Slide pickers are buttons that allow the user to navigate to a specific slide in a carousel,
     * usually dot-buttons at the bottom of the carousel.
     */
    class PerceivableComponentCarouselSlidePicker extends PerceivableDetector {
        /** @inheritDoc */
        static id = "perceivable-component-carousel-slide-picker";
        /** @inheritDoc */
        static skipChildrenWhen = "positive";
        /** @inheritDoc */
        static subsetOf = [PerceivableTraitClickable];
        /** @inheritDoc */
        static notSubsetOf = [PerceivableComponentCarouselArrowPrevious, PerceivableComponentCarouselArrowNext];
        /** @inheritDoc */
        static dependencies = [PerceivableComponentCarousel];
        /** @inheritDoc */
        static detect(element, classifier) {
            const context = classifier.getContext(PerceivableComponentCarousel);
            const connectedCarousel = context.getConnectedCarousel(element, "slidePickers");
            // If we can't connect the element to a carousel, it can't be a "carousel control" button, neither "previous" nor "next"
            if (!connectedCarousel) {
                return false;
            }
            const carouselButtons = context.get().elementStore.get(connectedCarousel);
            if (!carouselButtons.slidePickers.includes(element)) {
                return false;
            }
            return true;
        }
    }

    /**
     * Detects if an element is a list menu
     *
     * Notice there is no reference to visibility - this is because there are cases where we want to detect this structure while the element is not visible.
     * A hidden menu, toggle by the menu-trigger (like in dropdowns) is a good example.
     *
     * NOTE: the logic is entirely different from oldWidget/accessFlow, so no REPLACED/REMOVED comments were added
     * the old logic is here:
     * - @see https://github.com/acsbe/accessWidget/blob/1964d4ca0a44f7f168c1646683b44830b1cc784f/src/js/app/actions/adjustments/keyNav.js#L573
     * - @see https://github.com/acsbe/aflw-scanner/blob/e5e06d682d333863dac145e91e2df45ab884e53b/services/auditor/src/audits/auditor.ts#L1927
     */
    class PerceivableComponentListMenu extends PerceivableDetector {
        /** @inheritDoc */
        static id = "perceivable-component-list-menu";
        static skipChildrenWhen = "never";
        static subsetOf = [PerceivableComponentClickablesList];
        static dependencies = [PerceivableTraitClickable, PerceivableTraitTabbable, PerceivableComponentCarouselSlidePicker, PerceivableTraitVisible];
        static notSubsetOf = [PerceivableComponentBreadcrumb, PerceivableComponentCarousel];
        static classifier;
        /**
         * the threshold for the distance between the element and the sibling that's considered a close sibling
         */
        static closeSiblingThreshold = {
            x: 200,
            y: 50,
        };
        /**
         * checks if the list items are far from each other
         *
         * NOTE: this was previously relying on one occurence to determine that it's not a list menu, the issue with this is that some menus break in certain vieports in to two lines causing the last element in the first line and the second element on the second line to be far from each other.
         * related test: @see file://./atomic-tests/pass/wrapping-menu.html
         */
        static listItemsAreFarFromEachOther(listItems) {
            const visibleListItems = listItems.filter((el) => this.classifier.assert(el, PerceivableTraitVisible)); // we can't check distance on invisible elements so we filter them out
            return visibleListItems.some((el, i, arr) => {
                if (i + 1 < arr.length) {
                    const nextEl = arr[i + 1];
                    const { rect } = this.classifier.getOperations(el).layoutInfo;
                    const { rect: nextRect } = this.classifier.getOperations(nextEl).layoutInfo;
                    const { x, y } = getElementProximity(rect, nextRect);
                    if (x > this.closeSiblingThreshold.x || y > this.closeSiblingThreshold.y) {
                        return true;
                    }
                }
                return false;
            });
        }
        /**
         * the threshold for the distance between the elements that are considered aligned
         */
        static alignmentThreshold = 5;
        /**
         * groups elements by their inline alignment
         */
        static groupByInlineElements(elements, alignment, threshold = this.alignmentThreshold) {
            const groups = [];
            elements.forEach((el) => {
                const { rect } = this.classifier.getOperations(el).layoutInfo;
                const group = groups.find((g) => {
                    const { rect: groupRect } = this.classifier.getOperations(g[0]).layoutInfo;
                    if (alignment === "horizontal") {
                        return Math.abs(rect.top - groupRect.top) < threshold && (rect.left !== groupRect.left || rect.right !== groupRect.right);
                    }
                    return Math.abs(rect.top - groupRect.top) > threshold && (rect.left === groupRect.left || rect.right === groupRect.right);
                });
                if (group) {
                    group.push(el);
                }
                else {
                    groups.push([el]);
                }
            });
            return groups;
        }
        /**
         * checks if all menu items are aligned horizontally
         */
        static allMenuItemsHorizontal(elements) {
            const horizontalGroups = this.groupByInlineElements(elements, "horizontal");
            return horizontalGroups.length === 1;
        }
        /**
         * checks if all menu items are aligned vertically
         */
        static allMenuItemsVertical(elements) {
            const verticalGroups = this.groupByInlineElements(elements, "vertical");
            return verticalGroups.length === 1;
        }
        /**
         * given an element, gets all the visible clickable elements inside it
         */
        static getElementClickables(element) {
            return this.classifier.getMatchedInclusive([PerceivableTraitClickable], element).filter((el) => !this.classifier.getMatchedInclusive([PerceivableComponentCarouselSlidePicker], el).length); // exclude carousel slide pickers
        }
        /**
         * the list items are always the level that's before the last level - one before the container of the breadcrumb
         */
        static getListItemsFromLevels(levels) {
            return [...new Set(levels[levels.length - 2] || [])];
        }
        /**
         * check if there are tabbable elements between list items
         */
        static tabblabeElementsBetweenListItems(children, listItems) {
            const tabbleElemntsCount = listItems.reduce((acc, el, i) => {
                const elementsBetween = children.slice(children.indexOf(el) + 1, children.indexOf(listItems[i + 1])).filter((el) => isSvgOrHtmlElement(el));
                const isTabbable = elementsBetween.some((el) => {
                    return this.classifier.getMatchedInclusive([PerceivableTraitTabbable], el).length;
                });
                if (isTabbable) {
                    acc += 1;
                }
                return acc;
            }, 0);
            /**
             * if it's 50% or more of the list items have tabbable elements between them, then we consider it as having tabbable elements between list items
             * this is done to prevent false positives in cases where some list menus a mix of element types and this heuristic falsely identifies them as having tabbable elements between list items
             * this happens because the tag name is different on the second level, so the item in question is not part of the path from `getRepetitivePathOccurrences`
             *
             * related test: @see file://./atomic-tests/pass/mixed-menu-items.html
             */
            return tabbleElemntsCount / listItems.length >= 0.5;
        }
        /**
         * checks if any child node is equal to the parent node in dimensions
         */
        static childNodeSizeEqualToParent(element) {
            const parentRect = this.classifier.getOperations(element).layoutInfo.rect;
            const childNodeEqualToParent = [...element.childNodes].find((node) => {
                const rect = new NodeRects(node).boundingClientRect;
                return JSON.stringify(rect) === JSON.stringify(parentRect);
            });
            return childNodeEqualToParent;
        }
        /**
         * finds the main alignment groups for a list of elements and determines the primary alignment direction (i.e: the group that has the maximum members in the same vertical or horizontal alignment)
         */
        static getMainAlignmentGroups(listItems) {
            const verticallyAlignedGroups = this.groupByInlineElements(listItems, "vertical");
            const horizontallyAlignedGroups = this.groupByInlineElements(listItems, "horizontal");
            const maxVerticalGroupLength = Math.max(0, ...verticallyAlignedGroups.map((g) => g.length));
            const maxHorizontalGroupLength = Math.max(0, ...horizontallyAlignedGroups.map((g) => g.length));
            let mainGroups = [];
            if (maxHorizontalGroupLength > maxVerticalGroupLength) {
                mainGroups = horizontallyAlignedGroups;
            }
            if (maxVerticalGroupLength > maxHorizontalGroupLength) {
                mainGroups = verticallyAlignedGroups;
            }
            return { mainGroups };
        }
        /**
         *  checks if the element is a list menu by checking if it contains clickable elements with a repetitive path
         *  the element is a list menu if:
         * - the same path occurs qual or more than the threshold
         * - and equivilant location elements are siblings (using transposeMatrix)
         * - and the parent is the same as the target element
         * - and if the found element is on the same level is the same one and the target element is not the same as the found element, then it's not a list menu
         * TODO:
         * - might want to check that the clickable element also has some sort of content
         */
        static isListMenuStructure(element) {
            const clickablePathOccurrences = getRepetitivePathOccurrences(element, this.getElementClickables(element));
            for (const [_, paths] of clickablePathOccurrences) {
                const levels = transposeMatrix([...paths]);
                const clickables = levels[0]; // the first level is always the clickables
                const listItems = this.getListItemsFromLevels(levels);
                /**
                 * if there are tabbable elements between list items, then it's not a list menu.
                 * eliminates false-positives such as quantity selectors, etc.
                 * e.g:
                 * - src/perceivable/components/list-menu/atomic-tests/fail/quantity-selection-element.html
                 * - src/perceivable/components/list-menu/atomic-tests/fail/non-menu-repetitive-strutcture.html
                 */
                const visibleChildren = [...element.children].filter((el) => isSvgOrHtmlElement(el) && this.classifier.assert(el, PerceivableTraitVisible));
                const visibleListItems = listItems.filter((el) => this.classifier.assert(el, PerceivableTraitVisible));
                if (this.tabblabeElementsBetweenListItems(visibleChildren, visibleListItems)) {
                    continue;
                }
                /**
                 * if the child node is equal to the parent node in dimensions, then it's not a list menu.
                 * this eliminates cases where we have repetitive clickable structure such as a paragraph with multiple links and other text in it, e.g: src/perceivable/components/list-menu/atomic-tests/fail/paragraph-with-links.html
                 */
                if (this.childNodeSizeEqualToParent(element)) {
                    continue;
                }
                const { mainGroups } = this.getMainAlignmentGroups(visibleListItems);
                /**
                 * if there's no main alignment group, then it's not a list menu.
                 */
                if (mainGroups.length === 0) {
                    continue;
                }
                /**
                 * this is done to eliminate false positives such as tiles that are aligned like menus but look more like tiles/galeries
                 * for the most part, list-menus are no longer than 1 line, and in some cases they wrap to 2 lines (mostly turn into hamburger menus), but very rarely it's more than 2.
                 * we use this check together with `allItemsHaveVisibleText` to prevent false negatives.
                 *
                 * TODO: `allItemsHaveVisibleText` might be redundant but it's put in place to avoid false negatives while also eliminating tiles/galeries.
                 *
                 * @see file://./atomic-tests/fail/tiles.html
                 */
                if (mainGroups.length > 2) {
                    const allItemsHaveVisibleText = visibleListItems.every((i) => this.classifier.getOperations(i).contentInfo.hasVisibleText);
                    if (!allItemsHaveVisibleText) {
                        continue;
                    }
                }
                for (const group of mainGroups) {
                    /**
                     * skip if list items are far from each other
                     * e.g: src/perceivable/components/list-menu/atomic-tests/fail/menu-like-structure--far-apart.html
                     */
                    if (this.listItemsAreFarFromEachOther(group)) {
                        continue;
                    }
                    /**
                     * get visible clickables of current group
                     * we can't check alignment on invisible elements so we filter them out
                     */
                    const relatedClickables = clickables.filter((clickable) => group.some((el) => el.contains(clickable) && this.classifier.assert(clickable, PerceivableTraitVisible)));
                    /**
                     * only relevant if there are at least 2 clickables so we can compare their distance
                     *
                     * related tests:
                     * - @see file://./atomic-tests/fail/bug-newsletter-form.html
                     */
                    if (relatedClickables.length >= 2) {
                        const isHorizontal = this.allMenuItemsHorizontal(relatedClickables);
                        const isVertical = this.allMenuItemsVertical(relatedClickables);
                        if (!(isHorizontal !== isVertical)) {
                            continue;
                        }
                    }
                    return true;
                }
            }
            return false;
        }
        static detect(element, classifier) {
            this.classifier = classifier;
            /**
             * create a new detector i.e (ListMenusContainer/MultipleClickableRepetitiveStructures) that checks if an element has children that are detected as list menu, for example a footer menu that has multiple list-menus
             * can be done by using:
             * this.classifier.getMatchedDirect([PerceivableTraitClickableRepetitiveStructure], element).length >= 2;
             *
             * NOTE: this might require the currenly worked on depth mechanism to be more accurate
             */
            return this.isListMenuStructure(element);
        }
    }

    /**
     * Detects if an element is a perceivable form element.
     */
    class PerceivableComponentForm extends PerceivableDetector {
        /** @inheritDoc */
        static id = "perceivable-component-form";
        /** @inheritDoc */
        static skipChildrenWhen = "positive";
        /** @inheritDoc */
        static subsetOf = [PerceivableTraitVisible];
        /** @inheritDoc */
        static notSubsetOf = [CompliantTraitInteractable, CompliantComponentFormField, PerceivableComponentComboboxSelect, PerceivableComponentCheckbox, PerceivableComponentRadioButton, PerceivableComponentListMenu];
        static dependencies = [CompliantComponentForm, CompliantComponentInput];
        /** @inheritDoc */
        static detect(element, classifier) {
            const { windowInfo: { contentWidth }, layoutInfo: { renderedWidth }, } = classifier.getOperations(element);
            if (renderedWidth >= contentWidth) {
                return false;
            }
            const formFields = this.getFormFields(element, classifier);
            // If there are no inputs, this is not a form
            if (formFields.length === 0) {
                return false;
            }
            const labeledFields = [];
            for (const formField of formFields) {
                /**
                 * if some of the fields have associated labels it's safe to assume they are within a perceivable form
                 */
                if (classifier.getOperations(formField).contentInfo.srVisibleText) {
                    labeledFields.push(formField);
                }
            }
            /**
             * if there are more than one labeled field we assume their common ancestor is the form
             * related test: src/perceivable/components/form/atomic-tests/pass/multi-part-form.html
             * TODO:
             * - fails in this case: src/perceivable/components/form/atomic-tests/pass/multi-part-form--container-between-form-and-fields.html, need to refine the hueristics to ignore containers that have no visual impact.
             * - performance concerns, this is a very expensive operation, need to find a way to optimize it or add more hueristics beforehand.
             */
            if (labeledFields.length > 1) {
                const commonAncestor = this.getFirstCommonAncestor(labeledFields, 7);
                if (commonAncestor) {
                    if (commonAncestor === element) {
                        return true;
                    }
                }
            }
            else if (labeledFields.length === 1) {
                /**
                 * if there is only one labeled field we assume it's parent is the form
                 * related test: /src/perceivable/components/form/atomic-tests/pass/sms-verification-form--without-buttons.html
                 */
                if (labeledFields[0].parentElement === element) {
                    return true;
                }
            }
            /**
             * if no labeled fields are found we assume the form is the parent of the first field
             */
            return formFields[0].parentElement === element;
        }
        /**
         * Get the first common ancestor of two elements
         */
        static getFirstCommonAncestor(elements, depth = Infinity) {
            let count = 0;
            for (const element of elements) {
                const ancestors = getAncestors(element);
                for (const ancestor of ancestors) {
                    if (count > depth) {
                        return;
                    }
                    count++;
                    if (elements.every((el) => ancestor.contains(el))) {
                        return ancestor;
                    }
                }
            }
        }
        /**
         * Get all form fields in an element
         */
        static getFormFields(element, classifier) {
            const results = new Set();
            const detectors = [CompliantComponentFormField, PerceivableComponentCheckbox, PerceivableComponentRadioButton, PerceivableComponentComboboxSelect];
            for (let i = 0; i < detectors.length; i++) {
                const matched = classifier.getMatchedInclusive([detectors[i]], element);
                for (let j = 0; j < matched.length; j++) {
                    results.add(matched[j]);
                }
            }
            return Array.from(results);
        }
    }

    /**
     * Detects if an element is a perceivable form field component.
     */
    class PerceivableComponentFormSubmitButton extends PerceivableDetector {
        /** @inheritDoc */
        static id = "perceivable-component-form-submit-button";
        /** @inheritDoc */
        static skipChildrenWhen = "positive";
        /** @inheritDoc */
        static notChildOf = [PerceivableComponentRadioButton, PerceivableComponentCheckbox, PerceivableComponentComboboxSelect];
        /** @inheritDoc */
        static subsetOf = [PerceivableComponentButton];
        /** @inheritDoc */
        static dependencies = [CompliantComponentForm, PerceivableComponentButton, PerceivableComponentRadioButton, PerceivableComponentCheckbox, PerceivableComponentComboboxSelect];
        /** @inheritDoc */
        static detect(element, classifier) {
            const form = classifier.getParent(element, CompliantComponentForm) || classifier.getParent(element, PerceivableComponentForm);
            /**
             * if the button is not inside a form, it is not a submit button
             * TODO: this doesnt take into account buttons that are outside a form but are associated with it, this is a less likely scenario that we might want to consider in the future.
             * test cases:
             * - src/perceivable/components/form-submit-button/atomic-tests/pass/button-outside-form.html
             * - src/perceivable/components/form-submit-button/atomic-tests/fail/button-outside-form--already-submit-inside.html
             *
             */
            if (!form) {
                return false;
            }
            /**
             * if the button has a label, it is probably not a submit button but a form control
             * NOTE: we check for associated labels instead of checking for `contentInfo.labelText` because we also want to detect labels that are associated but have no text
             */
            const associatedLabels = getAssociatedLabels(element);
            if (associatedLabels.length) {
                return false;
            }
            else {
                /**
                 * if the button has no labels, and it's the last button in the form, it is probably a submit button
                 */
                const buttons = classifier.getMatched([PerceivableComponentButton], form);
                const otherButtons = buttons.filter((button) => button !== element);
                if (otherButtons.length) {
                    const isLastButton = otherButtons.every((otherButton) => element.compareDocumentPosition(otherButton) === Node.DOCUMENT_POSITION_PRECEDING);
                    return isLastButton;
                }
                return true;
            }
        }
    }

    /**
     * Determines whether the given element is a required form field
     */
    class PerceivableComponentFormFieldRequired extends PerceivableDetector {
        /** @inheritDoc */
        static id = "perceivable-component-form-field-required";
        /** @inheritDoc */
        static skipChildrenWhen = "positive";
        /** @inheritDoc */
        static dependencies = [PerceivableComponentForm, CompliantComponentForm];
        /** @inheritDoc */
        static subsetOf = [PerceivableTraitRenderable, CompliantTraitInteractable];
        /** @inheritDoc */
        static notSubsetOf = [PerceivableComponentFormSubmitButton];
        /** @inheritDoc */
        static detect(element, classifier, operations) {
            // Check if element has parent PerceivableComponentForm CompliantComponentForm
            const perceivableFormParent = classifier.getParent(element, PerceivableComponentForm);
            const compliantFormParent = classifier.getParent(element, CompliantComponentForm);
            if (!perceivableFormParent && !compliantFormParent) {
                return false;
            }
            // Check if element does not have attribute that contains "optional"
            if (this.hasActiveAttributeNameWithText(element, "optional")) {
                return false;
            }
            // Check if element has attribute that contains "required"
            if (this.hasActiveAttributeNameWithText(element, "required")) {
                return true;
            }
            const { relatedText } = operations.contentInfo;
            if (distExports.textContainsWord(relatedText, "optional")) {
                return false;
            }
            if (this.hasAsteriskOrRequired(relatedText)) {
                return true;
            }
            const placeholder = element.getAttribute("placeholder") ?? "";
            if (distExports.textContainsWord(placeholder, "optional")) {
                return false;
            }
            if (this.hasAsteriskOrRequired(placeholder)) {
                return true;
            }
            // TODO Find a more robust way to find an input's label, even if it's not explicit and the relation is only visual
            if (this.checkLabel(element, classifier)) {
                return true;
            }
            const { colorInfo: { borderColor }, } = operations;
            // Check if the element's border color is red which is a good indication that it's required
            if (this.isColorRed(borderColor)) {
                return true;
            }
            return false;
        }
        /**
         * Determines if the given element has a label that indicates it's required
         * @param element
         * @param classifier
         */
        static checkLabel(element, classifier) {
            const label = element.ownerDocument.querySelector(`label[for="${CSS.escape(element.id)}"]`);
            if (!label) {
                return false;
            }
            const { contentInfo, typographyInfo: { color: labelColor }, } = classifier.getOperations(label);
            const beforeContent = contentInfo.pseudoBefore.content;
            const afterContent = contentInfo.pseudoAfter.content;
            if (this.hasAsteriskOrRequired(beforeContent) || this.hasAsteriskOrRequired(afterContent)) {
                return true;
            }
            if (this.isColorRed(labelColor)) {
                return true;
            }
            return false;
        }
        /**
         * Determines if the given rgb color string can be perceived as red
         * @param color
         */
        static isColorRed(color) {
            const redValue = Number(color.split(",")[0].split("(")[1]);
            const greenValue = Number(color.split(",")[1]);
            const blueValue = Number(color.split(",")[2].split(")")[0]);
            return redValue > 200 && greenValue < 50 && blueValue < 50;
        }
        /**
         * Determines if the given element has an active attribute key that contains the given text
         * @param element
         * @param text
         */
        static hasActiveAttributeNameWithText(element, text) {
            const attributeNames = element.getAttributeNames();
            const hasActiveAttribute = attributeNames.some((attributeName) => {
                if (!attributeName.toLowerCase().includes(text.toLowerCase()))
                    return false;
                const value = element.getAttribute(attributeName);
                return value === "" || value === "true";
            });
            return hasActiveAttribute;
        }
        /**
         * Determines if the given text has an asterisk or the word is "required"
         * @param text
         */
        static hasAsteriskOrRequired(text) {
            const words = text
                .toLowerCase()
                .trim()
                .replace(/[^\p{L}*]+/gu, " ") // Replace non-letter characters with space
                .split(" ");
            const alphabeticWordOrAsterisk = /^\*?\p{L}{2,}\*?$|^\*$/u;
            const firstWord = words.find((word) => alphabeticWordOrAsterisk.exec(word)) ?? "";
            const lastWord = words.findLast((word) => alphabeticWordOrAsterisk.exec(word)) ?? "";
            if (firstWord.startsWith("*") || lastWord.endsWith("*") || distExports.textContainsWord(firstWord, "required") || distExports.textContainsWord(lastWord, "required")) {
                return true;
            }
        }
    }

    const VISIBLE_TEXT_LENGTH_THRESHOLD_MAX = 250;
    const CLICKABLE_SIZE_THRESHOLD_MAX = 200;
    const CLICKABLE_SIZE_THRESHOLD_MIN = 15;
    const CLICKABLE_SIZE_THRESHOLD_MIDDLE = 30;
    /**
     * Detector whether given `element` is perceived as navigation menu element.
     */
    class PerceivableComponentNavigationMenu extends PerceivableDetector {
        /** @inheritDoc */
        static id = "perceivable-component-navigation-menu";
        /** @inheritDoc */
        static skipChildrenWhen = "positive";
        /** @inheritDoc */
        static subsetOf = [PerceivableComponentListMenu, PerceivableTraitVisible];
        /** @inheritDoc */
        static dependencies = [PerceivableComponentForm, PerceivableTraitClickable];
        /** @inheritDoc */
        static detect(element, classifier) {
            // TODO: uncomment out this code when the issue with PerceivableComponentLink is fixed
            // const hasLink = classifier.getMatched([PerceivableComponentLink], element).length > 0;
            // if (!hasLink) {
            //   return false;
            // }
            const height = classifier.getOperations(element).layoutInfo.height;
            if (height < CLICKABLE_SIZE_THRESHOLD_MIN) {
                return false;
            }
            const hasForm = classifier.getMatched([PerceivableComponentForm], element).length > 0;
            if (hasForm) {
                return false;
            }
            const clickables = classifier.getMatched([PerceivableTraitClickable], element);
            for (let i = 0; i < Math.min(2, clickables.length); i++) {
                const { height, width } = classifier.getOperations(clickables[i]).layoutInfo;
                if (height > CLICKABLE_SIZE_THRESHOLD_MAX && width > CLICKABLE_SIZE_THRESHOLD_MAX) {
                    return false;
                }
                if (clickables.length === 2 && height > CLICKABLE_SIZE_THRESHOLD_MIDDLE) {
                    return false;
                }
            }
            return isTextLengthInRange(classifier.getOperations(element).contentInfo.visibleTextGenerator, { max: VISIBLE_TEXT_LENGTH_THRESHOLD_MAX });
        }
    }

    const NAVIGATION_SIZE_THRESHOLD = 500;
    /**
     * Detector whether given `element` is perceived as navigation element.
     */
    class PerceivableComponentNavigation extends PerceivableDetector {
        /** @inheritDoc */
        static id = "perceivable-component-navigation";
        /** @inheritDoc */
        static skipChildrenWhen = "positive";
        /** @inheritDoc */
        static subsetOf = [PerceivableTraitVisible];
        /** @inheritDoc */
        static dependencies = [PerceivableComponentNavigationMenu];
        /** @inheritDoc */
        static detect(element, classifier) {
            if (classifier.getMatchedDirect([PerceivableComponentNavigationMenu], element).length === 0) {
                return false;
            }
            const { height, width } = classifier.getOperations(element).layoutInfo;
            if (height > NAVIGATION_SIZE_THRESHOLD && width > NAVIGATION_SIZE_THRESHOLD) {
                return false;
            }
            return true;
        }
    }

    /**
     * Detect if the current page is a Shopify store
     * @returns {boolean} True if the page is a Shopify store, false otherwise
     */
    function isShopify() {
        // 1. Shopify global objects
        if (typeof window["Shopify"] === "object" || typeof window["ShopifyAnalytics"] === "object") {
            return true;
        }
        // 2. Shopify meta tags
        if (document.querySelector('meta[name="shopify-checkout-api-token"], meta[id="shopify-digital-wallet"]')) {
            return true;
        }
        return false;
    }

    /**
     * Service for detecting and caching the CMS (Content Management System) of the current page.
     * This service runs detection on first access and provides cached results thereafter.
     */
    class CMSService {
        static cmsName = null;
        /**
         * Detects the CMS name
         * @returns {CMSName} The detected CMS name
         */
        static detectCMS() {
            if (isShopify()) {
                return "shopify";
            }
            // Add more CMS detections here in the future
            return "unknown";
        }
        /**
         * Gets the detected CMS name
         * @returns {CMSName} The CMS name
         */
        static getCMSName() {
            if (CMSService.cmsName === null) {
                CMSService.cmsName = CMSService.detectCMS();
            }
            return CMSService.cmsName;
        }
    }

    /**
     * Locate the footer landmark in a Shopify store
     * @returns {HTMLElement[] | null} An array with the footer element if found, null otherwise
     */
    function locateShopifyFooter(classifier) {
        if (CMSService.getCMSName() !== "shopify") {
            return null;
        }
        const footer = getShopifyFooter(classifier);
        if (footer) {
            return [footer];
        }
        return null;
    }
    /**
     * Detect the footer element in a Shopify store
     * (looking in the main document only, not in iframes or shadow DOMs)
     * @returns {HTMLElement | null} The footer element if found, null otherwise
     */
    function getShopifyFooter(classifier) {
        // 1. Try compliant elements first
        const semanticFooters = classifier.getMatched([CompliantComponentFooter, PerceivableTraitVisible]);
        if (semanticFooters.length) {
            return sortByArea(semanticFooters, classifier)[0];
        }
        // 2. Shopify sections
        const shopifyFooter = document.querySelector("[id*='shopify-section-footer'], .shopify-section[id*='footer'], .shopify-section-footer, .footer, .site-footer");
        if (shopifyFooter)
            return shopifyFooter;
        return null;
    }

    /**
     * Locate the `footer` component in the page
     */
    class PerceivableComponentFooter extends Locator {
        /** @inheritDoc */
        static id = "perceivable-component-footer";
        /** @inheritDoc */
        static async doLocate(classifier) {
            const shopifyFooters = locateShopifyFooter(classifier);
            if (shopifyFooters) {
                return shopifyFooters;
            }
            return ClassifierLandmarksFooter.predict();
        }
    }

    /**
     * Locate the main navigation landmark in a Shopify store
     * @returns {HTMLElement[] | null} An array with the main nav element if found, null otherwise
     */
    function locateShopifyMainNavigation(classifier) {
        if (CMSService.getCMSName() !== "shopify") {
            return null;
        }
        const nav = getShopifyMainNavigation(classifier);
        if (nav) {
            return [nav];
        }
        return null;
    }
    /**
     * Detect the main navigation element in a Shopify store
     * @returns {HTMLElement | null}
     */
    function getShopifyMainNavigation(classifier) {
        const genericMainNavigation = getMainNavigationGenericWay(classifier);
        if (genericMainNavigation) {
            return genericMainNavigation;
        }
        const shopifyHeaderBasedMainNavigation = getShopifyHeaderBasedMainNavigation(classifier);
        if (shopifyHeaderBasedMainNavigation) {
            return shopifyHeaderBasedMainNavigation;
        }
        return null;
    }
    /**
     * Get Shopify header-based main navigation, if any
     * @param classifier
     */
    function getShopifyHeaderBasedMainNavigation(classifier) {
        const headerNavs = document.querySelectorAll(`
    [id*="shopify-section-header"] nav,
    .shopify-section-header nav,
    .site-header nav,
     nav.header-menu-desktop,
     nav.header__primary-nav,
    .header ul,
    .header nav,
    .main-navigation,
    .primary-navigation,
    .header--list-menu,
     header .main-nav--menu
  `);
        if (headerNavs.length) {
            // sort by area and start from the largest visible one
            const sortedHeaderNavs = sortByArea(Array.from(headerNavs), classifier);
            for (const nav of sortedHeaderNavs) {
                if (classifier.assert(nav, PerceivableTraitVisible)) {
                    return nav;
                }
            }
        }
        return null;
    }
    /**
     * Filter out elements that are inside a footer
     * @param elements
     * @param classifier
     */
    function getEffectiveCandidates(elements, classifier) {
        return elements.filter((el) => {
            const isInsideComplaintFooter = classifier.getParent(el, CompliantComponentFooter);
            if (isInsideComplaintFooter) {
                return false;
            }
            const perceivableFooter = classifier.getMatched([PerceivableComponentFooter]);
            if (perceivableFooter[0]?.contains(el)) {
                return false;
            }
            return true;
        });
    }
    /**
     * Get navigation inside header, if any
     * @param classifier
     * steps:
     * 1. get all headers
     * 2. in case there is no header, use the body as root
     * 3. for each root, get all visible navigation/list-menu/navigation-menu/compliant-navigation elements
     * 4. filter out those inside footers
     * 5. sort by containment (those containing more candidates are ranked higher)
     * 6. in case of ties, sort by area and return the largest one
     * @return {SvgOrHtmlElement | null}
     */
    function getMainNavigationGenericWay(classifier) {
        const headers = classifier.getMatched([CompliantComponentHeader]);
        // in case there is no header, we'll use the body, and search the whole document
        const roots = headers.length ? headers : [document.body];
        for (const root of roots) {
            const candidates = [...classifier.getMatched([PerceivableComponentListMenu, PerceivableTraitVisible], root), ...classifier.getMatched([PerceivableComponentNavigation], root), ...classifier.getMatched([PerceivableComponentNavigationMenu], root), ...classifier.getMatched([CompliantComponentNavigation, PerceivableTraitVisible], root)];
            if (!candidates.length) {
                continue;
            }
            const effectiveCandidates = getEffectiveCandidates(Array.from(new Set(candidates)), classifier);
            if (effectiveCandidates.length === 1) {
                return effectiveCandidates[0];
            }
            if (!effectiveCandidates.length) {
                continue;
            }
            const withContainment = effectiveCandidates
                .map((el) => ({
                el,
                contains: effectiveCandidates.filter((other) => el !== other && el.contains(other)).length,
            }))
                .sort((a, b) => b.contains - a.contains);
            // in case some have the same containment count, we return the largest one among them by area?
            const highestContainmentCount = withContainment[0].contains;
            const topContainmentElements = withContainment.filter((item) => item.contains === highestContainmentCount).map((item) => item.el);
            return sortByArea(topContainmentElements, classifier).at(0); // largest one
        }
        return null;
    }

    /**
     * Locate the `main-navigation` component in the page
     */
    class PerceivableComponentMainNavigation extends Locator {
        /** @inheritDoc */
        static id = "perceivable-component-main-navigation";
        /** @inheritDoc */
        static dependencies = [CompliantComponentNavigation, CompliantComponentHeader, PerceivableTraitVisible, PerceivableComponentListMenu, PerceivableComponentNavigation, PerceivableComponentNavigationMenu, CompliantComponentFooter];
        /** @inheritDoc */
        static async doLocate(classifier) {
            const shopifyMainNavigation = locateShopifyMainNavigation(classifier);
            if (shopifyMainNavigation) {
                return shopifyMainNavigation;
            }
            return ClassifierLandmarksMainNavigation.predict();
        }
    }

    /**
     * Detector whether the given element is a backdrop.
     * This is a helper for Dialog detector.
     */
    class PerceivableComponentBackdrop extends PerceivableDetector {
        /** @inheritDoc */
        static id = "perceivable-component-backdrop";
        /** @inheritDoc */
        static skipChildrenWhen = "positive";
        /** @inheritDoc */
        static subsetOf = [PerceivableTraitVisible];
        /** @inheritDoc */
        static detect(element, classifier) {
            const { layoutInfo, windowInfo } = classifier.getOperations(element);
            const isFullHeight = layoutInfo.height >= windowInfo.height * 0.7; // thresholds of 70% as exists in the legacy code
            const isFullWidth = layoutInfo.width === windowInfo.width;
            const hasPositiveZIndex = layoutInfo.zIndex > 0;
            const startsFromTopCorner = layoutInfo.left === 0 && layoutInfo.top === 0;
            const isSpecialPositioning = ["fixed", "absolute"].includes(layoutInfo.position);
            return isSpecialPositioning && hasPositiveZIndex && isFullHeight && isFullWidth && startsFromTopCorner;
        }
    }

    /**
     * Detector whether the given element is a dialog.
     */
    class PerceivableComponentDialogModal extends PerceivableDetector {
        /** @inheritDoc */
        static id = "perceivable-component-dialog-modal";
        /** @inheritDoc */
        static skipChildrenWhen = "positive";
        /** @inheritDoc */
        static subsetOf = [PerceivableTraitVisible];
        /** @inheritDoc */
        static notSubsetOf = [PerceivableComponentBackdrop];
        /** @inheritDoc */
        static notChildOf = [];
        /** @inheritDoc */
        static dependencies = [PerceivableTraitTabbable, PerceivableTraitClickable, PerceivableComponentBackdrop];
        static minimumHeight = 100;
        static minimumWidth = 100;
        /** helper for easy access */
        static windowInfo;
        static detect(element, classifier) {
            if (this.tagNameToAvoid.includes(element.tagName.toLowerCase())) {
                return false;
            }
            if (isInstanceOf(element, HTMLDialogElement) && element.hasAttribute("open")) {
                return true;
            }
            const { layoutInfo, windowInfo } = classifier.getOperations(element);
            this.windowInfo = windowInfo;
            // has to be horizontally or vertically centered
            if (layoutInfo.height < this.minimumHeight || layoutInfo.width < this.minimumWidth) {
                return false;
            }
            if (!this.isElementCentered(layoutInfo.rect)) {
                return false;
            }
            // If the element is fullscreen, it is not a dialog
            if (this.isFullscreen(layoutInfo.rect)) {
                return false;
            }
            // dialogs usually have actionable children (like close button)
            const actionableChildren = classifier.getMatchedInclusive([PerceivableTraitTabbable], element).concat(classifier.getMatchedInclusive([PerceivableTraitClickable], element));
            if (actionableChildren.length === 0) {
                return false;
            }
            // if the element has a backdrop parent or sibling, it is likely a dialog
            if (classifier.getParent(element, PerceivableComponentBackdrop) || this.hasBackdropSibling(element, classifier)) {
                return true;
            }
            return false;
        }
        /**
         * Determines if the element is in fullscreen mode (occupying the entire screen).
         * @param {DOMRect} boundingClientRect - The bounding client rectangle of the element.
         * @returns {boolean} True if the element is in fullscreen mode, false otherwise.
         */
        static isFullscreen(boundingClientRect) {
            const { top, right, bottom, left } = boundingClientRect;
            const viewportWidth = this.windowInfo.width;
            const viewportHeight = this.windowInfo.height;
            return top === 0 && left === 0 && right - left === viewportWidth && bottom - top === viewportHeight;
        }
        /**
         * Checks if the element is centered in the viewport.
         * @param {DOMRect} rect - The bounding client rectangle of the element.
         * @returns {boolean} True if the element is centered in the viewport, false otherwise.
         * */
        static isElementCentered(rect) {
            // Calculate distances from the element's edges to the viewport edges
            const distanceFromLeft = rect.left;
            const distanceFromRight = this.windowInfo.width - rect.right;
            const distanceFromTop = rect.top;
            const distanceFromBottom = this.windowInfo.height - rect.bottom;
            // Define a tolerance for "centering", to allow for slight misalignment
            const tolerance = 40;
            // Check if the element is horizontally and vertically centered within tolerance
            const isHorizontallyCentered = Math.abs(distanceFromLeft - distanceFromRight) <= tolerance;
            const isVerticallyCentered = Math.abs(distanceFromTop - distanceFromBottom) <= tolerance;
            return isHorizontallyCentered || isVerticallyCentered;
        }
        static hasBackdropSibling(element, classifier) {
            const parent = element.parentElement;
            if (!parent)
                return false;
            for (const sibling of parent.children) {
                if (sibling !== element && classifier.assert(sibling, PerceivableComponentBackdrop)) {
                    return true;
                }
            }
            return false;
        }
        /**
         * List of tags to avoid when detecting dialog, as they are not likely to be dialogs.
         * */
        static tagNameToAvoid = [
            "header",
            "footer",
            "nav",
            "main",
            "article",
            "table",
            "thead",
            "tbody",
            "tfoot",
            "tr",
            "th",
            "td",
            "ul",
            "ol",
            "li",
            "figure",
            "figcaption",
            "fieldset",
            "legend",
            "dl",
            "dt",
            "dd",
            "h1",
            "h2",
            "h3",
            "h4",
            "h5",
            "h6",
            "p",
            "hr",
            "blockquote",
            "pre",
            "code",
            "address",
            "b",
            "i",
            "strong",
            "em",
            "small",
            "s",
            "cite",
            "q",
            "dfn",
            "abbr",
            "ruby",
            "rt",
            "rp",
            "bdi",
            "bdo",
            "a",
            "img",
            "video",
            "audio",
            "source",
            "track",
            "map",
            "area",
            "canvas",
            "svg",
            "math",
            "iframe",
            "embed",
            "object",
            "param",
            "picture",
            "ins",
            "del",
            "mark",
            "progress",
            "meter",
            "details",
            "summary",
            "menu",
            "menuitem",
        ];
    }

    /**
     * Returns the deepest active element in a Shadow DOM or Document.
     * @param root - The root element (ShadowRoot or Document) to start the search from.
     */
    function getDeepestActiveElement(root = document) {
        const activeElement = root.activeElement;
        if (!isSvgOrHtmlElement(activeElement)) {
            return null; // Ensure the active element is an HTML or SVG element
        }
        if (!activeElement.shadowRoot) {
            return activeElement; // Return if the active element has no shadow root
        }
        return getDeepestActiveElement(activeElement.shadowRoot); // Recursively search in the shadow root
    }

    /**
     * detects if an element is a skip link
     */
    class PerceivableComponentSkipLink extends PerceivableDetector {
        /** @inheritDoc */
        static id = "perceivable-component-skip-link";
        static skipChildrenWhen = "positive";
        static dependencies = [PerceivableTraitVisible];
        /** @inheritDoc */
        static subsetOf = [PerceivableTraitRenderable, PerceivableTraitScreenReaderOnly, PerceivableTraitTabbable];
        /**
         * detects if an element is a skip link according to the following rules:
         * - must be a non url link (href="#something", href="javascript:void(0)")
         * - must be screen reader only
         * - must be visible on focus/active
         * - ? check for strings in href and textContent such as "skip to main content" or "skip to content" or "#main" or "#content" - need to translate to all languages
         *
         * how it works:
         * - checks if the element is a button like anchor
         * - saves the current active element and if the element has transitions or animations
         * - if the element has transitions or animations, it disables them before focusing the element
         * - focuses the element and checks if it's visible, saves the result
         * - blurs the element and focuses the previous active element to not interfere with the user's focus flow
         * - enables the transitions and animations if they were disabled
         *
         * NOTE: this check works only when the browser is focused on the document, if the browser is focused on the devtools, or in another app/tab the check will fail.
         */
        static detect(element, classifier) {
            if (!document.hasFocus()) {
                console.warn("[Warning] PerceivableComponentSkipLink:\nPlease note that this detector might not work as you expect if the devtools are open, or the focus is on another app/tab instead.");
            }
            /**
             * if the element is not a button like anchor, then it's not a skip link
             *
             * NOTE: there is a possibility that some sites may use any kind of clickables, but from our experience this isn't common at all (if the need arises, we can add support for other clickable elements)
             */
            const isAnchorWithHashTagHref = element.tagName === "A" && element.getAttribute("href").startsWith("#") && element.getAttribute("href").length > 1;
            if (!isButtonLikeAnchor(element) && !isAnchorWithHashTagHref) {
                return false;
            }
            const prevActiveElement = getDeepestActiveElement();
            const operations = classifier.getOperations(element);
            const { transitionDuration, animationDuration } = operations.resources.computedStyle;
            const { animation: inlineAnimation, transition: inlineTransition } = element.style;
            /**
             * we need to disable transitions to determine visibility synchronously
             */
            if (transitionDuration !== "0s") {
                element.style.setProperty("transition", "none", "important");
            }
            if (animationDuration !== "0s") {
                element.style.setProperty("animation", "none", "important");
            }
            element.focus();
            /**
             * NOTE: we are using the `detect` method instead of `assert` because we check the visibility of the element after the focus event which is not the same as it was before the focus event (in the State).
             *
             * TODO: need to develop a way to receive the State of the element after the focus event from the `assert` method (or via getVisisbilityInfo or other sort of reevaluation method)
             *  Than move this logic to the index file.
             */
            OperationService.removeElementFromCache(element);
            const isVisible = PerceivableTraitVisible.detect(element, classifier);
            if (prevActiveElement === document.body) {
                element.blur();
            }
            else {
                prevActiveElement.focus();
            }
            OperationService.removeElementFromCache(element);
            /**
             * re-introduces the previous transitions and animations.
             * if we had inline styles previously, we set them back, otherwise we remove the property.
             */
            if (transitionDuration !== "0s" && inlineTransition) {
                element.style.setProperty("transition", inlineTransition, "important");
            }
            else {
                element.style.removeProperty("transition");
            }
            if (animationDuration !== "0s" && inlineAnimation) {
                element.style.setProperty("animation", inlineAnimation, "important");
            }
            else {
                element.style.removeProperty("animation");
            }
            return isVisible;
        }
    }

    const currencies = [
        "$",
        "€",
        "£",
        "¥",
        "₪",
        "₹",
        "₩",
        "₽",
        "₫",
        "₭",
        "₦",
        "₱",
        "₲",
        "₴",
        "฿",
        "₡",
        "₵",
        "₺",
        "₸",
        "ƒ",
        "₣",
        "₧",
        "¤",
        "₯",
        "৳",
        "៛",
        "₠",
        "৲",
        "₿",
        "Ξ",
        "Ł",
        "Ɖ",
        "◈",
        "Ͼ",
        "₳",
        "₮",
        "₾",
        "₼",
        "₨",
        "₤",
        "usd",
        "eur",
        "gbp",
        "gbx",
        "cny",
        "ils",
        "nis",
        "cad",
        "inr",
        "jpy",
        "krw",
        "rub",
        "vnd",
        "lak",
        "ngn",
        "php",
        "pyg",
        "uah",
        "thb",
        "crc",
        "ghs",
        "try",
        "kzt",
        "awg",
        "htg",
        "kes",
        "mwk",
        "npr",
        "sos",
        "syp",
        "xof",
        "ang",
        "bbd",
        "bzd",
        "bmd",
        "bnd",
        "kyd",
        "svc",
        "fjd",
        "gip",
        "ggp",
        "hkd",
        "imp",
        "jmd",
        "jep",
        "mop",
        "nad",
        "nzd",
        "pab",
        "sgd",
        "ttd",
        "tvd",
        "xcd",
        "zwl",
        "brl",
        "mxn",
        "ars",
        "clp",
        "cop",
        "pen",
        "uyu",
        "bob",
        "ves",
        "chf",
        "aud",
        "sek",
        "nok",
        "dkk",
        "isk",
        "czk",
        "huf",
        "pln",
        "ron",
        "bgn",
        "hrk",
        "bam",
        "mkd",
        "rsd",
        "tnd",
        "dzd",
        "mad",
        "egp",
        "lbp",
        "lyd",
        "sdg",
        "ugx",
        "zar",
        "szl",
        "bwp",
        "mzn",
        "aoa",
        "etb",
        "xaf",
        "cve",
        "bif",
        "cdf",
        "djf",
        "ern",
        "gmd",
        "gnf",
        "lsl",
        "lrd",
        "mga",
        "mlf",
        "mro",
        "mur",
        "scr",
        "sll",
        "std",
        "tzs",
        "zmw",
        "afn",
        "azn",
        "amd",
        "bdt",
        "btn",
        "khr",
        "kpw",
        "kgs",
        "mmk",
        "mnt",
        "pkr",
        "pgk",
        "wst",
        "sbd",
        "lkr",
        "tjs",
        "uzs",
        "vuv",
        "ש״ח",
        "שח",
        "שקל",
    ];

    // Define thresholds for text length and child element count
    const MAX_TEXT_LENGTH = 20;
    const MAX_CHILDREN_COUNT = 5;
    /**
     * Detects whether the given element contains a sale-price.
     */
    class PerceivableComponentSalePrice extends PerceivableDetector {
        /** @inheritDoc */
        static id = "perceivable-component-sale-price";
        /** @inheritDoc */
        static skipChildrenWhen = "positive";
        /** @inheritDoc */
        static subsetOf = [PerceivableTraitVisible];
        /** @inheritDoc */
        static detect(element, classifier) {
            // Early exit if the element has too many child elements
            if (element.children.length > MAX_CHILDREN_COUNT) {
                return false;
            }
            const operations = classifier.getOperations(element);
            // Get the text content of the element and convert it to lowercase
            if (!isTextLengthInRange(operations.contentInfo.visibleTextGenerator, { max: MAX_TEXT_LENGTH })) {
                return false;
            }
            if (element.childElementCount === 1 && !operations.contentInfo.directText) {
                // current element is probably just a wrapper
                return false;
            }
            const text = operations.contentInfo.visibleText.toLowerCase();
            // Define a regular expression to match prices with optional surrounding text
            const regex = new RegExp("(.*?)\\s*(\\d{1,3}(?:[,.]\\d{3})*(?:[,.]\\d+)?)(?:\\s+)?(\\w+)?", "g");
            // Initialize a variable to count the number of valid prices found
            let pricesCount = 0;
            // Execute the regex on the text and store the match results
            let match;
            // Loop through all matches
            while ((match = regex.exec(text)) !== null) {
                // Extract parts of the match
                const beforeCurrency = match?.[1]?.trim().split(" ").pop();
                const number = match?.[2]?.replace(/\s+/g, "");
                const afterCurrency = match?.[3]?.trim();
                // Check if either part is a known currency symbol
                if (currencies.includes(beforeCurrency) || currencies.includes(afterCurrency)) {
                    // Normalize text by removing all whitespaces for comparison
                    const normalizedText = text.replace(/\s+/g, "");
                    const normalizedMatch1 = (beforeCurrency + number).replace(/\s+/g, "");
                    const normalizedMatch2 = `${number} ${afterCurrency}`.replace(/\s+/g, "");
                    // Increase count if a valid price match is found
                    if (normalizedMatch1 === normalizedText || normalizedMatch2 === normalizedText) {
                        pricesCount++;
                    }
                }
            }
            return pricesCount === 1;
        }
    }

    class TableContext extends Context {
        /** @inheritDoc */
        data = {
            elementStore: new WeakMap(),
        };
        /**
         * Sets the table data for the given element.
         * @param element - The element to set the data to.
         * @param data - The rows and cells of the table.
         */
        set({ element, data }) {
            this.data.elementStore.set(element, { ...this.data.elementStore.get(element), ...data });
        }
    }

    /**
     * Detects if an element can be perceived as a table element.
     * TODO: Implement detecting tables with only row borders (https://flowbite.com/docs/components/tables/).
     */
    class PerceivableComponentTable extends PerceivableDetector {
        /** @inheritDoc */
        static id = "perceivable-component-table";
        /** @inheritDoc */
        static skipChildrenWhen = "positive";
        /** @inheritDoc */
        static subsetOf = [PerceivableTraitVisible];
        /** @inheritDoc */
        static notSubsetOf = [PerceivableComponentImage, PerceivableComponentListMenu, CompliantComponentList, PerceivableTraitDirectText];
        /** @inheritDoc */
        static dependencies = [CompliantComponentFormField, PerceivableTraitVisible, PerceivableTraitDirectText, CompliantComponentTable, CompliantComponentTableRow];
        static contextType = TableContext;
        static classifier;
        /**
         * A reference to the dimension to check alignment depending on if the table is horizontal or vertical.
         * @private
         */
        static dimensionToCheck;
        static detect(element, classifier, _, context) {
            this.classifier = classifier;
            if (!element.children.length) {
                return false;
            }
            let rowCandidates;
            // If the element is a compliant table element, and it has compliant rows, we use them to detect the table
            if (this.classifier.assert(element, CompliantComponentTable) && this.classifier.getMatched([CompliantComponentTableRow], element).length) {
                rowCandidates = this.classifier.getMatched([CompliantComponentTableRow], element);
                this.dimensionToCheck = this.getTableDimension(rowCandidates);
                if (!this.dimensionToCheck) {
                    return false;
                }
            }
            else {
                const children = this.classifier.getMatchedDirect([PerceivableTraitVisible], element);
                if (!children.length) {
                    return false;
                }
                this.dimensionToCheck = this.getTableDimension(children);
                if (!this.dimensionToCheck) {
                    return false;
                }
                // Check if the element is a container
                if (this.isContainer(element, children)) {
                    return false;
                }
                rowCandidates = this.getRowCandidates(element);
            }
            // If there are less than 2 row candidates, it's probably not a table
            if (rowCandidates.length < 2) {
                return false;
            }
            // Check if the rows/columns are aligned
            const rowDimensions = rowCandidates.map((row) => this.classifier.getOperations(row).layoutInfo[this.dimensionToCheck]);
            if (rowDimensions.some((rowDimension) => rowDimension !== rowDimensions[0])) {
                return false;
            }
            const cells = [];
            const rows = [];
            for (const rowCandidate of rowCandidates) {
                const rowCells = this.getCells(rowCandidate);
                // If there are no cells in the row, we skip it because it's potentially a title or caption
                if (!rowCells.length) {
                    continue;
                }
                rows.push(rowCandidate);
                cells.push(...rowCells);
            }
            // If there are less than 2 rows, it's not a table
            if (rows.length < 2) {
                return false;
            }
            // All cells must not contain form fields
            if (cells.some((cell) => this.classifier.getMatched([CompliantComponentFormField], cell).length)) {
                return false;
            }
            // All cells must be visible
            if (cells.some((cell) => !this.classifier.assert(cell, PerceivableTraitVisible))) {
                return false;
            }
            context.set({ element, data: { cells, rows } });
            return true;
        }
        /**
         * Returns the dimension that should be used to check alignment depending on if the table is horizontal or vertical.
         * @param children
         */
        static getTableDimension(children) {
            const firstChildLayout = this.classifier.getOperations(children[0]).layoutInfo;
            if (children.every((child) => this.areDimensionsApproximatelyTheSame(firstChildLayout, this.classifier.getOperations(child).layoutInfo, "top"))) {
                // Columns contain cells
                return "height";
            }
            else if (children.every((child) => this.areDimensionsApproximatelyTheSame(firstChildLayout, this.classifier.getOperations(child).layoutInfo, "left"))) {
                // Rows contain cells
                return "width";
            }
        }
        /**
         * Recursively returns the elements which are potentially table rows under an element.
         * @param element
         * @param depth
         */
        static getRowCandidates(element, depth = 0) {
            // If the depth is more than 2, we stop looking for rows
            if (depth > 2) {
                return [];
            }
            const rowCandidates = this.getElementChildren(element);
            // If there are no row candidates, we stop looking for rows
            if (rowCandidates.length === 0) {
                return [];
            }
            // If there is only one row candidate, we check if it has children and if it does, we try to get the row candidates from it
            if (this.isContainer(element, rowCandidates)) {
                return this.getRowCandidates(rowCandidates[0], depth + 1);
            }
            // If the depth is greater than 0, we check if there is a row candidate with a smaller dimension than the element. In that case then we can assume that the element is a row itself
            if (depth > 0 &&
                rowCandidates.some((rowCandidate) => {
                    const rowCandidateDimension = this.classifier.getOperations(rowCandidate).layoutInfo[this.dimensionToCheck];
                    const elementDimension = this.classifier.getOperations(element).layoutInfo[this.dimensionToCheck];
                    return rowCandidateDimension < elementDimension;
                })) {
                return [element];
            }
            const rows = rowCandidates.reduce((currentRows, rowCandidate) => {
                // If the row candidate has direct text, we skip it
                if (this.classifier.assert(rowCandidate, PerceivableTraitDirectText)) {
                    return currentRows;
                }
                // If the row candidate has children without visible borders, we try to get the row candidates from it
                const rowCandidateChildren = this.getElementChildren(rowCandidate);
                if (!rowCandidateChildren.every((child) => this.classifier.getOperations(child).layoutInfo.hasVisibleBorder)) {
                    return [...currentRows, ...this.getRowCandidates(rowCandidate, depth + 1)];
                }
                return [...currentRows, rowCandidate];
            }, []);
            return rows;
        }
        /**
         * Recursively returns the elements which are potentially table cells under a row.
         * @param row
         * @param depth
         */
        static getCells(row, depth = 0) {
            // If the depth is greater than 2 or more, we stop looking for cells
            if (depth > 2) {
                return [];
            }
            // If the row has direct text then it's not valid table structure
            if (this.classifier.assert(row, PerceivableTraitDirectText)) {
                return [];
            }
            // If the row has no children, we stop looking for cells
            const cellCandidates = this.getElementChildren(row);
            if (cellCandidates.length === 0) {
                return [];
            }
            // If there is only one cell candidate then it's a container, and we try to get the cells from it
            if (this.isContainer(row, cellCandidates)) {
                return this.getCells(cellCandidates[0], depth + 1);
            }
            let emptyCells = 0;
            const cells = [];
            for (const cellCandidate of cellCandidates) {
                const cellCandidateChildren = this.getElementChildren(cellCandidate);
                // If the cell candidate children all have a border (except for the last ones vertically) then this is a container, and we try to get the cells from it
                if (cellCandidateChildren.length > 1 && cellCandidateChildren.every((child) => this.doesCellHaveValidStyling(child, cellCandidate))) {
                    cells.push(...this.getCells(cellCandidate, depth + 1));
                    continue;
                }
                // If the cell candidate is not last vertically, and it doesn't have a visible border, it's invalid cell structure and we skip this row
                if (!this.doesCellHaveValidStyling(cellCandidate, row)) {
                    return [];
                }
                // If the cell has more than 2 images, we skip it
                const images = this.classifier.getMatched([PerceivableComponentImage], cellCandidate);
                if (images.length > 2) {
                    return [];
                }
                // If the cell has a large amount of text, we skip it
                const contentInfo = this.classifier.getOperations(cellCandidate).contentInfo;
                // If the cell has no images and no visible text, we skip it
                if (images.length === 0 && !contentInfo.hasVisibleText) {
                    emptyCells++;
                    // If there are more than 2 empty cells, we skip this row
                    if (emptyCells > 2) {
                        return [];
                    }
                }
                const hasSimpleContent = isTextLengthInRange(contentInfo.visibleTextGenerator, { max: 300 });
                if (!hasSimpleContent) {
                    return [];
                }
                cells.push(cellCandidate);
            }
            // If the row is complaint, we don't need to check alignment and we return the cells
            if (this.classifier.assert(row, CompliantComponentTableRow)) {
                return cells;
            }
            const rowLayout = this.classifier.getOperations(row).layoutInfo;
            // If the cells are not aligned, we skip this row
            if (!this.areCellsAligned(cells, rowLayout)) {
                return [];
            }
            // check if the sum of all the cell width/heights in the row is less than the width/height of the row
            const rowCellsDimension = cells.reduce((acc, cell) => acc + this.classifier.getOperations(cell).layoutInfo[this.dimensionToCheck], 0);
            if (!this.areDimensionsApproximatelyTheSame(rowLayout, { [this.dimensionToCheck]: rowCellsDimension }, this.dimensionToCheck)) {
                return [];
            }
            return cells;
        }
        /**
         * Checks if all the cells are aligned with the table direction.
         * @param cells
         * @param rowLayout
         * @private
         */
        static areCellsAligned(cells, rowLayout) {
            const sideToCheck = this.dimensionToCheck === "width" ? "top" : "left";
            return cells.every((cell) => {
                const cellLayout = this.classifier.getOperations(cell).layoutInfo;
                return this.areDimensionsApproximatelyTheSame(rowLayout, cellLayout, sideToCheck);
            });
        }
        /**
         * Checks if the element is a container.
         * @param element
         * @param children
         */
        static isContainer(element, children) {
            if (children.length === 1) {
                const childLayout = this.classifier.getOperations(children[0]).layoutInfo;
                const elementLayout = this.classifier.getOperations(element).layoutInfo;
                // If the child has similar dimensions to the element, it's probably a table container
                if (this.areDimensionsApproximatelyTheSame(childLayout, elementLayout, "width") && this.areDimensionsApproximatelyTheSame(childLayout, elementLayout, "height")) {
                    return true;
                }
            }
            return false;
        }
        /**
         * Checks if the dimensions of two layouts are approximately the same.
         * @param layout1
         * @param layout2
         * @param dimension
         * @private
         */
        static areDimensionsApproximatelyTheSame(layout1, layout2, dimension) {
            return Math.abs(layout1[dimension] - layout2[dimension]) <= 15;
        }
        /**
         * Returns the children of an element that are HTMLElements.
         * @param element
         * @private
         */
        static getElementChildren(element) {
            const result = [];
            const children = element.children;
            for (let i = 0; i < children.length; i++) {
                const child = children[i];
                if (isSvgOrHtmlElement(child)) {
                    result.push(child);
                }
            }
            return result;
        }
        /**
         * Checks if the cell is in the lowest row (the row is the last child in a horizontal table or the cell is the last in the row in a vertical table) or if it has a visible border.
         * @param cell
         * @param row
         * @private
         */
        static doesCellHaveValidStyling(cell, row) {
            const isLastVertically = this.dimensionToCheck === "width" ? row.matches(":last-child") : cell.matches(":last-child");
            return isLastVertically || this.classifier.getOperations(cell).layoutInfo.hasVisibleBorder;
        }
    }

    /**
     * Detector whether the given element is a table cell.
     */
    class PerceivableComponentTableCell extends PerceivableDetector {
        /** @inheritDoc */
        static id = "perceivable-component-table-cell";
        /** @inheritDoc */
        static subsetOf = [PerceivableTraitVisible];
        /** @inheritDoc */
        static notSubsetOf = [CompliantComponentTableHeader, CompliantComponentTableBody, CompliantComponentTableFooter, CompliantComponentTableRow];
        /** @inheritDoc */
        static dependencies = [PerceivableComponentTable];
        static classifier;
        /** @inheritDoc */
        static detect(element, classifier) {
            this.classifier = classifier;
            // Filter out elements that a tagged as components that are not table cells
            if (this.isTaggedAsNotTableCell(element)) {
                return false;
            }
            // Get the table connected to this element - if none found this cannot be a table cell
            const connectedTable = this.getDirectParentTable(element);
            const tableContext = this.classifier.getContextData(PerceivableComponentTable);
            if (connectedTable && tableContext.elementStore.get(connectedTable)?.cells.includes(element)) {
                return true;
            }
            return false;
        }
        /**
         * We want to filter out elements that are 100% not table cells.
         * Elements that are tagged as other components within a table.
         * Also, there are some tags that are not table cells, but can be children of table cells - we want to avoid these as well
         *
         * @param element the element to check if it is tagged as not a table cell
         * @returns true if the element is tagged as not a table cell, false otherwise
         */
        static isTaggedAsNotTableCell(element) {
            const nonTableCellTags = ["COL", "COLGROUP", "CAPTION"];
            const nonTableCellRoles = ["rowgroup", "colgroup"];
            const isCellChild = !["TD", "TH"].includes(element.tagName) && (safeClosest(element, "th") || safeClosest(element, "td"));
            return isCellChild || nonTableCellTags.includes(element.tagName) || nonTableCellRoles.includes(element.role);
        }
        /**
         * Tables can sometimes be nested, so we want to find the table that the provided table is the direct descendant of.
         * This function does the check.
         *
         * @param element the element to check if it is a child of the table
         * @returns a boolean whether the table is the direct parent of the element
         */
        static getDirectParentTable(element) {
            let currentElement = element.parentElement;
            /**
             * Just a safety to prevent unnecessary loop runs.
             * Table cells are expected to be not further than 3-4 levels from the table, so 5 should be more than enough.
             * Example: table ->(3) tbody ->(2) tr ->(1) td
             */
            let safetyCounter = 5;
            while (currentElement && safetyCounter > 0) {
                const isTable = this.classifier.assert(currentElement, PerceivableComponentTable);
                if (isTable) {
                    return currentElement;
                }
                currentElement = currentElement.parentElement;
                safetyCounter--;
            }
            return null;
        }
    }

    /**
     * Detector whether the given element is a table column header.
     */
    class PerceivableComponentTableColumnHeader extends PerceivableDetector {
        /** @inheritDoc */
        static id = "perceivable-component-table-column-header";
        /** @inheritDoc */
        static subsetOf = [PerceivableComponentTableCell];
        /** @inheritDoc */
        static dependencies = [PerceivableComponentTable, CompliantComponentTable, CompliantComponentTableFooter, CompliantComponentTableRow];
        static classifier;
        /** @inheritDoc */
        static detect(element, classifier) {
            this.classifier = classifier;
            /**
             * <tfoot> elements will not have column header elements as children (NOTE: I didn't find counter examples but keep in mind technically this can happen)
             */
            if (classifier.getParent(element, CompliantComponentTableFooter)) {
                return false;
            }
            // Checking if this is a column header based on the elements tagging and how its siblings are tagged
            if (this.isElementColumnHeader(element)) {
                return true;
            }
            // Checking if the element is within a column headers row - mainly a style check to it is styled like a header, and so are all of is siblings
            if (this.isElementInColumnHeadersRow(element)) {
                return true;
            }
            return false;
        }
        /**
         * LOGIC: Usually, column headers rows would have all the cells have header-like styles.
         * All bold or all underlined.
         * So, if the candidate has "header styles", AND we found a row that contains it, AND all the cells in this row are similar in style (practically all are having "header styles"),
         * we can assume the candidate is a cell within a row of column headers (and is probably, also a column header)
         *
         * @param element The candidate for the check
         * @returns a boolean wether the element is contained in a column headers row
         */
        static isElementInColumnHeadersRow(element) {
            // Check if the element is header-like
            if (!this.isElementHeaderLike(element)) {
                return false;
            }
            /**
             * Expecting the parent of a column header to be a row element.
             * If it is not the element cannot be a column header
             */
            const relevantRow = element.parentElement;
            if (!this.classifier.assert(relevantRow, CompliantComponentTableRow)) {
                return false;
            }
            // Checking all cells in the row (including the element - the check is not heavy so we allow to do this twice) are header like cells
            const children = relevantRow.children;
            for (let i = 0; i < children.length; i++) {
                const el = children[i];
                if (!this.isElementHeaderLike(el)) {
                    return false; // Early exit if any child is not header-like
                }
            }
            return true; // All children are header-like
        }
        /**
         * Check whether the given element is header-like. This is determined by the following criteria:
         * - The text is reasonably short
         * And at least one of the following:
         * - The text is bold
         * - The text is underlined
         *
         * @param element the element to check
         * @returns a boolean whether the given element is header-like based on the criteria
         */
        static isElementHeaderLike(element) {
            const { contentInfo, typographyInfo } = this.classifier.getOperations(element);
            const isReasonablyShort = isTextLengthInRange(contentInfo.visibleTextGenerator, { max: 25 }); // Column headers are not expected to have sentences
            const isBold = typographyInfo.fontWeight > 500; // 500 is the largest value for normal
            const isUnderlined = typographyInfo.textDecoration.line.includes("underline"); // Underlined text is a common indicator for headers
            return (isUnderlined || isBold) && isReasonablyShort;
        }
        /**
         * A shorthand to check if an element is tagged like a column header.
         * This checks for the tag and the role of the element.
         *
         * @param element the candidate for the check
         * @returns a boolean for whether the element is tagged as a column-header and is likely to be a column header
         */
        static isTaggedAsColumnHeader(element) {
            return element.tagName === "TH" || element.role === "columnheader";
        }
        /**
         * Checking the tagging of the element and its siblings.
         * If the element and most of its siblings are tagged as column-headers, this is a strong indicator that the element is a column header.
         * Also checking there are no more than 2 rows that are siblings to these case.
         * Check pass example -> atomic-tests/pass/multiple-column-headers-rows.html and fail example -> atomic-tests/fail/table-of-phone-devices-only-names-no-column-header.html
         *
         * @param element the candidate for the check
         * @returns a boolean for whether the element and its siblings are all tagged as a column-header and are likely to be a column header
         */
        static isElementColumnHeader(element) {
            const isTaggedAsColumnHeader = this.isTaggedAsColumnHeader(element);
            if (!isTaggedAsColumnHeader) {
                return false;
            }
            /**
             * Why "most" are headers and not "all"?
             * In example atomic-tests/pass/multiple-column-headers-rows.html you can see a <td> used for structure, to have an empty cell before the headers.
             * We still want to catch these <th> cases.
             */
            const parent = element.parentElement;
            if (!parent)
                return false;
            let taggedCount = 0;
            let totalCount = 0;
            const siblings = parent.children;
            for (let i = 0; i < siblings.length; i++) {
                const sibling = siblings[i];
                totalCount++;
                if (this.isTaggedAsColumnHeader(sibling)) {
                    taggedCount++;
                }
            }
            const notTaggedCount = totalCount - taggedCount;
            const isMostSiblingsTaggedAsColumnHeader = taggedCount > notTaggedCount;
            if (!isMostSiblingsTaggedAsColumnHeader) {
                return false;
            }
            /**
             * Having more than 2 rows the same element under a table element, while the element is tagged as a column header (TH),
             * cancels the previous indication as the <th> elements might be mistakenly used as <td> elements.
             * Check example atomic-tests/fail/table-of-phone-devices-only-names-no-column-header.html
             */
            const grandparent = parent.parentElement;
            if (!grandparent)
                return false;
            let rowCount = 0;
            const children = grandparent.children;
            for (let i = 0; i < children.length; i++) {
                const child = children[i];
                if (this.classifier.assert(child, CompliantComponentTableRow)) {
                    rowCount++;
                    if (rowCount > 2) {
                        return false;
                    }
                }
            }
            return true;
        }
    }

    /**
     * Detector whether the given element is a table row header.
     */
    class PerceivableComponentTableRowHeader extends PerceivableDetector {
        /** @inheritDoc */
        static id = "perceivable-component-table-row-header";
        /** @inheritDoc */
        static subsetOf = [PerceivableComponentTableCell];
        /** @inheritDoc */
        static notSubsetOf = [PerceivableComponentTableColumnHeader];
        /** @inheritDoc */
        static dependencies = [PerceivableComponentTable, CompliantComponentTable, CompliantComponentTableHeader, CompliantComponentTableRow];
        static classifier;
        /** @inheritDoc */
        static detect(element, classifier) {
            this.classifier = classifier;
            // If this element has a <thead> parent, it cannot be a row header
            if (classifier.getParent(element, CompliantComponentTableHeader)) {
                return false;
            }
            // Since we removed all the table column headers (using not subset of) - we can assume any leftover TH elements are row headers.
            if (element.tagName === "TH" || element.role === "rowheader") {
                return true;
            }
            // Checking if the element has header styles while having siblings (other cells) that do not have header styles
            if (this.isElementRowHeader(element)) {
                return true;
            }
            // If the element is sticking out, meaning it's "closer" to being a header (e.g. font is bolder), it is probably a row header
            if (this.isElementStickingOut(element, this.classifier)) {
                return true;
            }
            return false;
        }
        /**
         * Check whether the given element is header-like. This is determined by the following criteria:
         * - The text is reasonably short
         * And at least one of the following:
         * - The text is bold
         * - The text is underlined
         *
         * @param element the element to check
         * @returns a boolean whether the given element is header-like based on the criteria
         */
        static isElementHeaderLike(element) {
            const { contentInfo, typographyInfo } = this.classifier.getOperations(element);
            const isReasonablyShort = isTextLengthInRange(contentInfo.visibleTextGenerator, { max: 25 }); // Row headers are not expected to have sentences
            const isBold = typographyInfo.fontWeight > 500; // 500 is the largest value for normal
            const isUnderlined = typographyInfo.textDecoration.line.includes("underline"); // Underlined text is a common indicator for headers
            return (isUnderlined || isBold) && isReasonablyShort;
        }
        /**
         * LOGIC: A row header cell must be 2 things:
         * - Header looking (style-wise)
         * - Has to be in a row where either there are no other cells, or there are any data-cells.
         *
         * @param element The candidate for the check
         * @returns a boolean wether the element is contained in a column headers row
         */
        static isElementRowHeader(element) {
            // Check if the element is header-like
            if (!this.isElementHeaderLike(element)) {
                return false;
            }
            /**
             * Expecting the parent of a row header to be a row element.
             * If it is not, the element cannot be a row header
             */
            const relevantRow = element.parentElement;
            if (!this.classifier.assert(relevantRow, CompliantComponentTableRow)) {
                return false;
            }
            /**
             * LOGIC: Since we already checked our element to be header-like, and we check that its row contains non-header cells (data-cells),
             * it is safe to assume the candidate, which is "header-like", is a row header.
             * Had there not been any data-cells, this row would have been considered as a column-headers-row, containing column headers alone - not what we're looking for.
             */
            const children = relevantRow.children;
            let hasSiblings = false;
            for (let i = 0; i < children.length; i++) {
                const child = children[i];
                if (child === element)
                    continue;
                hasSiblings = true;
                if (!this.isElementHeaderLike(child)) {
                    return true; // At least one sibling is not header-like
                }
            }
            return !hasSiblings; // True if no siblings at all
        }
        /**
         * Compare the contrast ratio between two colors, checking if the first one is darker than the second
         * @param {string} subjectColor - The first color in rgb format
         * @param {string} targetColor - The second color in rgb format
         * @returns {boolean} True if the subjects color is darker than the second, false otherwise
         */
        static isDarker = (subjectColor, targetColor) => {
            const [r1, g1, b1] = subjectColor;
            const [r2, g2, b2] = targetColor;
            const L1 = getRelativeLuminance(r1, g1, b1) + 0.05;
            const L2 = getRelativeLuminance(r2, g2, b2) + 0.05;
            // If the relative luminance of the second color is greater than the first, than the first color is darker
            return L2 > L1;
        };
        /**
         * Checking whether the given element is closer (style-wise) to be a header than its sibling element
         *
         * @param elementTypographyInfo
         * @param elementColorInfo
         * @param siblingTypographyInfo
         * @param siblingColorInfo
         * @returns
         */
        static isCloserToHeader(elementTypographyInfo, elementColorInfo, siblingTypographyInfo, siblingColorInfo) {
            const isBolder = elementTypographyInfo.fontWeight > siblingTypographyInfo.fontWeight;
            const isFontSizeBigger = elementTypographyInfo.fontSize > siblingTypographyInfo.fontSize;
            // Check example for darker row-header cell example -> atomic-tests/pass/table-row-darker-cells.html
            return isBolder || isFontSizeBigger || this.isDarker(elementColorInfo.aggregatedBackgroundColorParsed, siblingColorInfo.aggregatedBackgroundColorParsed);
        }
        /**
         * Checking whether the given element is sticking out from its siblings, mainly using styles for comparison.
         * Row header elements are usually styled differently from their siblings, usually styled as headers
         *
         * @param element the candidate element to check
         * @param classifier the engine classifier
         * @returns a boolean whether the element differs from its siblings, "sticking out"
         */
        static isElementStickingOut(element, classifier) {
            const parent = element.parentElement;
            if (!parent)
                return false;
            const children = parent.children;
            const siblings = [];
            // Collect siblings except element without allocating a full array up-front
            for (let i = 0; i < children.length; i++) {
                const child = children[i];
                if (child !== element)
                    siblings.push(child);
            }
            /**
             * If the table cell is not before all of its siblings, it cannot be a row header
             */
            for (let i = 0; i < siblings.length; i++) {
                if (element.compareDocumentPosition(siblings[i]) !== Node.DOCUMENT_POSITION_FOLLOWING) {
                    return false;
                }
            }
            let nonSimilarSiblings = 0;
            const treeWalker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, {
                acceptNode: (node) => {
                    if (!isSvgOrHtmlElement(node)) {
                        return NodeFilter.FILTER_SKIP;
                    }
                    if (!classifier.getOperations(node).contentInfo.directText) {
                        return NodeFilter.FILTER_SKIP;
                    }
                    return NodeFilter.FILTER_ACCEPT;
                },
            });
            do {
                const currentElement = treeWalker.currentNode;
                const { typographyInfo, colorInfo } = classifier.getOperations(currentElement);
                for (const sibling of siblings) {
                    const { typographyInfo: siblingTypographyInfo, colorInfo: siblingColorInfo } = classifier.getOperations(sibling);
                    // If the element is closer to a header than its sibling, we count it as a non-similar sibling
                    if (this.isCloserToHeader(typographyInfo, colorInfo, siblingTypographyInfo, siblingColorInfo)) {
                        // When there is only one sibling, and we find the element to be more header-like, we can assume it is a header
                        if (siblings.length === 1) {
                            return true;
                        }
                        nonSimilarSiblings++;
                    }
                    // We want our element to be more header-like than at least 2 of its siblings
                    if (nonSimilarSiblings > 1) {
                        return true;
                    }
                }
            } while (treeWalker.nextNode());
            return false;
        }
    }

    const MAX_RATING_TEXT_LENGTH = 80;
    const MAX_RATING_CONTEXT_LENGTH = 200;
    /**
     * Detects if an element is a user-rating component.
     */
    class PerceivableComponentUserRating extends PerceivableDetector {
        /** @inheritDoc */
        static id = "perceivable-component-user-rating";
        /** @inheritDoc */
        static skipChildrenWhen = "positive";
        /** @inheritDoc */
        static subsetOf = [CompliantTraitVisible];
        /** @inheritDoc */
        static notSubsetOf = [];
        /** @inheritDoc */
        static dependencies = [PerceivableTraitVisible, PerceivableTraitScreenReaderOnly];
        /** @inheritDoc */
        static detect(element, classifier) {
            if (!classifier.assert(element, PerceivableTraitVisible) && !classifier.assert(element, PerceivableTraitScreenReaderOnly)) {
                return false;
            }
            const containerSelector = '[class*="rating" i], [class*="rate" i], [class*="score" i]';
            if (element.matches(containerSelector)) {
                return true;
            }
            /**
             * Apparently some websites use the itemprop="ratingValue" attribute to indicate a rating.
             * It is popular with a meta tag, and also used in a meter element as in the example in the link below.
             * https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/itemprop#a_meter_element
             */
            const containsRatingValueItemPropChild = element.querySelector(':scope > [itemprop="ratingValue"]');
            if (containsRatingValueItemPropChild) {
                return true;
            }
            const { contentInfo, contextInfo } = classifier.getOperations(element);
            /**
             * If the text is too long, it's probably not a rating.
             */
            if (!isTextLengthInRange(contentInfo.visibleTextGenerator, { max: 25 })) {
                return false;
            }
            /**
             * Why are we using *= (attr value contains "star" sting)?
             * We are getting all the elements that are candidates to be stars.
             * We match classes like "a-star-yellow", "stars__1".
             * This can match false positives like "start".
             * This is why we filter out the elements later, searching for the exact words "star" and "stars".
             * Check if the element is a star rating system.
             * It's either a single star, 5 stars, or 10 stars in total.
             * A single star can occur when the rating is represented by a single star icon, thus making the container the only element with "star" in its classlist.
             * It can also be 6 or 11 stars, because we are counting the container as well.
             * For example:
             * <div class="stars-container">
             *   <img src="star.png" />
             *   <img src="star.png" />
             *   <img src="star.png" />
             *   <img src="star.png" />
             *   <img src="star.png" />
             * </div>
             */
            const starSelector = 'img[src*="star" i], [class*="star" i]';
            const starChildrenSelector = ':scope > img[src*="star" i], :scope > [class*="star" i]';
            const starElements = Array.from(element.querySelectorAll(starChildrenSelector));
            if (element.matches(starSelector)) {
                starElements.unshift(element);
            }
            const stars = starElements.filter((star) => {
                // Removing false positives where the attributes actually have the word "star" or "stars"
                const starClasses = star.getAttribute("class");
                const starSrc = star.getAttribute("src");
                // Removing non-alphanumeric characters, and wrapping wth spaces
                const relevantString = ` ${starClasses} ${starSrc} `.replace(/[\W_]+/g, " ").toLowerCase();
                return relevantString.includes(" star ") || relevantString.includes(" stars ");
            });
            const expectedAmountsOfStars = [1, 5, 6, 10, 11];
            if (expectedAmountsOfStars.includes(stars.length)) {
                return true;
            }
            const { directText, relatedText } = contentInfo;
            /**
             * Having text that is too long might indicate that the element is not a rating.
             * We would expect texts like "rated 4 out of 5", "rating: 4/5", "score: 4/5" etc.
             */
            const relevantContent = [directText, relatedText].filter(Boolean).join(" ").toLowerCase();
            if (relevantContent.length > MAX_RATING_TEXT_LENGTH) {
                return false;
            }
            /**
             * Regex to check for x/y rating (i.e. 5/5, 4/5, 3/5, etc.).
             * We are removing spaces to catch more cases like "5 / 5", "5/ 5", "5 /5" etc.
             */
            const ratingRegex = /\d+\/\d+/;
            const hasRating = ratingRegex.test(relevantContent.replaceAll(" ", "").toLowerCase());
            if (hasRating) {
                return true;
            }
            // Elements context like classlist or any attribute might contain the word "rating" or "rate"
            const { elementContexts } = contextInfo;
            // Check for specific words that are commonly used in ratings
            const suspectedWords = ["rating", "rated", "rate", "out of", "score", "scored"];
            for (const word of suspectedWords) {
                if (distExports.textContainsWord(relevantContent, word)) {
                    return true;
                }
                const context = elementContexts.next()?.value?.toLowerCase();
                if (context && context.length < MAX_RATING_CONTEXT_LENGTH && distExports.textContainsWord(context, word)) {
                    return true;
                }
            }
            return false;
        }
    }

    class PerceivableComponentCaptcha extends PerceivableDetector {
        /** @inheritDoc */
        static id = "perceivable-component-captcha";
        /** @inheritDoc */
        static skipChildrenWhen = "positive";
        /** @inheritDoc */
        static subsetOf = [PerceivableTraitVisible];
        /** @inheritDoc */
        static notSubsetOf = [PerceivableTraitClickable, CompliantTraitInteractable];
        /** @inheritDoc */
        static dependencies = [PerceivableComponentForm, CompliantComponentForm];
        /** @inheritDoc */
        static classifier;
        /** @inheritDoc */
        static detect(element, classifier) {
            this.classifier = classifier;
            return this.hasFormAncestor(element, classifier) && this.hasCaptchaContext(element);
        }
        /**
         * Check if the element has captcha context
         * @param element
         * @private
         */
        static hasCaptchaContext(element) {
            const { contextInfo } = this.classifier.getOperations(element);
            const { elementContexts } = contextInfo;
            for (const elementContext of elementContexts) {
                if (elementContext.includes("captcha") || elementContext.includes("cf-turnstile")) {
                    return true;
                }
            }
            return false;
        }
        /**
         * Check if the element has a form ancestor
         * @param element
         * @param classifier
         * @private
         */
        static hasFormAncestor(element, classifier) {
            return Boolean(classifier.getParent(element, PerceivableComponentForm) || classifier.getParent(element, CompliantComponentForm));
        }
    }

    const MAX_LINE_HEIGHT_DEVIATION = 3;
    const MAX_DISTANCE_FROM_TOP = 40;
    const MIN_TEXT_LENGTH = 3;
    /**
     * Detector whether the given element is a Paragraph.
     */
    class PerceivableComponentTextBlock extends PerceivableDetector {
        /** @inheritDoc */
        static id = "perceivable-component-text-block";
        /** @inheritDoc */
        static skipChildrenWhen = "positive";
        /** @inheritDoc */
        static subsetOf = [PerceivableTraitVisible];
        /** @inheritDoc */
        static notSubsetOf = [PerceivableTraitClickable, PerceivableComponentClickablesList];
        // We can't use Compliant regions because Perceivable regions are locators or don't exist.
        /** @inheritDoc */
        static notChildOf = [CompliantComponentFooter, CompliantComponentHeader, PerceivableTraitClickable];
        static dependencies = [PerceivableTraitDirectText, CompliantComponentInput];
        /** @inheritDoc */
        static detect(element, classifier) {
            const { contentInfo } = classifier.getOperations(element);
            if (!isTextLengthInRange(contentInfo.visibleTextGenerator, { min: 3, max: 2000 })) {
                return false;
            }
            // Check that the element does not contain any input elements
            if (classifier.getMatched([CompliantComponentInput], element).length > 0) {
                return false;
            }
            // Drill down if the element has no direct text and only one child or only one child with visible text
            if (!classifier.assert(element, PerceivableTraitDirectText)) {
                if (element.children.length === 1) {
                    return false;
                }
                if (this.hasOneChildWithVisibleText(element, classifier)) {
                    return false;
                }
            }
            // If the first line of text is not close to the top of the element, it's likely not a textblock
            const isTextCloseToTop = this.isFirstLineCloseToTop(element, classifier);
            if (!isTextCloseToTop) {
                return false;
            }
            const isAligned = this.areTextNodesAligned(element, classifier);
            return isAligned;
        }
        /**
         * Checks if the given element has exactly one child element with visible text.
         * @param element
         * @param classifier
         */
        static hasOneChildWithVisibleText(element, classifier) {
            let count = 0;
            for (const child of element.children) {
                if (!isSvgOrHtmlElement(child))
                    continue;
                if (classifier.getOperations(child).contentInfo.hasVisibleText) {
                    count++;
                    if (count > 1) {
                        return false;
                    }
                }
            }
            return count === 1;
        }
        /**
         * Checks if the first line of text within the given element is close to the top of the element.
         * @see src/perceivable/components/text-block/atomic-tests/fail/ably-apparel-image-before-textblock.html
         * @param element
         * @param classifier
         */
        static isFirstLineCloseToTop(element, classifier) {
            const textRange = document.createRange();
            const textNodeWalker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT);
            while (textNodeWalker.nextNode()) {
                const currentTextNode = textNodeWalker.currentNode;
                if (currentTextNode.data.trim().length) {
                    textRange.selectNode(currentTextNode);
                    break;
                }
            }
            const firstLineRect = textRange.getClientRects()[0];
            const { top: elementTop } = classifier.getOperations(element).layoutInfo;
            if (firstLineRect && firstLineRect.top - elementTop <= MAX_DISTANCE_FROM_TOP) {
                return true;
            }
            return false;
        }
        /**
         * Checks that all line rects from all text nodes within the given element are either on the same line or spaced evenly.
         * @param element
         * @param classifier
         */
        static areTextNodesAligned(element, classifier) {
            let previousTextNodeLastLineRect;
            let previousTextNode;
            let seenVisibleTextNode = false;
            const textNodeWalker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT);
            const textRange = document.createRange();
            while (textNodeWalker.nextNode()) {
                const currentTextNode = textNodeWalker.currentNode;
                // Ignore meaningless text nodes
                if (currentTextNode.length < MIN_TEXT_LENGTH) {
                    continue;
                }
                textRange.selectNode(currentTextNode);
                const currentTextNodeLineRects = textRange.getClientRects();
                if (currentTextNodeLineRects.length === 0) {
                    continue;
                }
                seenVisibleTextNode = true;
                if (!previousTextNodeLastLineRect || !previousTextNode) {
                    // This is the first visible text node we are checking, so we just set the previous text node and its last line rect
                    previousTextNode = currentTextNode;
                    previousTextNodeLastLineRect = currentTextNodeLineRects[currentTextNodeLineRects.length - 1];
                    continue;
                }
                const currentTextNodeFirstLineRect = currentTextNodeLineRects[0];
                const areRectsOnSameLine = this.rectsOnSameLine(previousTextNodeLastLineRect, currentTextNodeFirstLineRect);
                if (areRectsOnSameLine && !this.noEmptyTextNodesInBetween(previousTextNode, currentTextNode, element)) {
                    return false;
                }
                const container = currentTextNode.parentElement;
                const lineHeight = classifier.getOperations(container).typographyInfo.lineHeight;
                if (!areRectsOnSameLine && !this.areRectsSpacedEvenly(previousTextNodeLastLineRect, currentTextNodeFirstLineRect, lineHeight)) {
                    return false;
                }
                previousTextNode = currentTextNode;
                previousTextNodeLastLineRect = currentTextNodeLineRects[currentTextNodeLineRects.length - 1];
            }
            return seenVisibleTextNode;
        }
        /**
         * Checks if two DOMRect objects are on the same line.
         * @param rect1
         * @param rect2
         */
        static rectsOnSameLine(rect1, rect2) {
            // Round for subpixel safety
            const top1 = Math.round(rect1.top);
            const top2 = Math.round(rect2.top);
            const bottom1 = Math.round(rect1.bottom);
            const bottom2 = Math.round(rect2.bottom);
            return Math.abs(top2 - top1) < MAX_LINE_HEIGHT_DEVIATION || Math.abs(bottom2 - bottom1) < MAX_LINE_HEIGHT_DEVIATION;
        }
        /**
         * Empty text nodes are inorganic and are only results of rendering structural elements such as table headers, tab controls, etc...
         * This function checks if there are no empty text nodes between the two given text nodes.
         * @param previousTextNode - The previous visible text node in the tree walker.
         * @param currentTextNode - The current visible text node in the tree walker.
         * @param root - The root element of the tree walker.
         * @private
         * @returns true if there are no empty text nodes between the two text nodes otherwise false.
         */
        static noEmptyTextNodesInBetween(previousTextNode, currentTextNode, root) {
            // Set the walker to the first text node
            const textNodeWalker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT);
            textNodeWalker.currentNode = previousTextNode;
            while (textNodeWalker.nextNode()) {
                const textNode = textNodeWalker.currentNode;
                if (textNode === currentTextNode) {
                    break;
                }
                if (textNode.data.trim().length === 0) {
                    return false;
                }
            }
            return true;
        }
        /**
         * Checks if two text node rects are spaced evenly based on the computed line height of the second rect's parent element.
         * It first estimates the line height based on the space between the bottom of the first rect and the top of the second rect and the height of the second rect.
         * Then it checks if the estimated line height matches the computed line height.
         * It accounts for a small deviation to allow unnoticeably small differences.
         * @param rect1
         * @param rect2
         * @param computedLineHeight - The computed line-height of the second rect's parent (line-height * fontSize).
         * @returns true if the line-heights match up.
         */
        static areRectsSpacedEvenly(rect1, rect2, computedLineHeight) {
            // Round for subpixel safety
            const bottom1 = Math.round(rect1.bottom);
            const top2 = Math.round(rect2.top);
            const spaceBetween = top2 - bottom1;
            const estimatedLineHeight = spaceBetween + rect2.height;
            // If the estimated line height is too big, it means there is a large gap between the two text nodes, which is not acceptable.
            return Math.abs(estimatedLineHeight - computedLineHeight) <= MAX_LINE_HEIGHT_DEVIATION;
        }
    }

    /**
     * Detector whether the given element is a Paragraph.
     */
    class PerceivableComponentParagraph extends PerceivableDetector {
        /** @inheritDoc */
        static id = "perceivable-component-paragraph";
        /** @inheritDoc */
        static skipChildrenWhen = "positive";
        /** @inheritDoc */
        static subsetOf = [PerceivableComponentTextBlock];
        /** @inheritDoc */
        static detect(element, classifier) {
            const { contentInfo } = classifier.getOperations(element);
            if (!isTextLengthInRange(contentInfo.visibleTextGenerator, { min: 50, max: 2000 })) {
                return false;
            }
            return true;
        }
    }

    /**
     * Detector whether the given clickable element is an article.
     */
    class PerceivableComponentArticle extends PerceivableDetector {
        /** @inheritDoc */
        static id = "perceivable-component-article";
        /** @inheritDoc */
        static skipChildrenWhen = "positive";
        /** @inheritDoc */
        static subsetOf = [PerceivableTraitVisible, CompliantTraitVisible];
        /** @inheritDoc */
        static notSubsetOf = [];
        static dependencies = [PerceivableComponentParagraph, CompliantComponentParagraph];
        /** @inheritDoc */
        static detect(element, classifier) {
            const children = [];
            for (let i = 0; i < element.children.length; i++) {
                const child = element.children[i];
                if (isSvgOrHtmlElement(child)) {
                    children.push(child);
                }
            }
            // assuming that an article should have at least one heading and one body
            if (children.length < 2)
                return false;
            // TODO: in the future use the heading locator to find h1
            const headings = [];
            const nodeList = element.querySelectorAll("h1");
            for (let i = 0; i < nodeList.length; i++) {
                const heading = nodeList[i];
                if (classifier.getOperations(heading).contentInfo.hasVisibleText) {
                    headings.push(heading);
                }
            }
            if (headings.length === 0 || headings.length > 1)
                return false;
            const paragraphs = classifier.getMatchedInclusive([PerceivableComponentParagraph], element).concat(classifier.getMatchedInclusive([CompliantComponentParagraph], element));
            if (paragraphs.length < 2)
                return false;
            const lowestCommonAncestor = getLowestCommonAncestor(paragraphs[0], headings[0]);
            const metaSelector = ["[class*='author']", "[class*=' date']", "[class^='date']", "[class*='published']", "time[datetime]", "meta[name='author']", "meta[property='article:published_time']", "[itemprop='author']", "[itemprop='datePublished']"].join(", ");
            const hasMetadata = lowestCommonAncestor?.querySelector(metaSelector);
            if (!hasMetadata)
                return false;
            const { contentInfo: { visibleText }, } = classifier.getOperations(lowestCommonAncestor);
            const hasSignificantWordsLength = visibleText.trim().split(/\s+/).length > 200;
            if (!hasSignificantWordsLength)
                return false;
            return lowestCommonAncestor === element;
        }
    }

    /**
     * Detector whether the given element is a search form.
     */
    class PerceivableComponentSearchForm extends PerceivableDetector {
        /** @inheritDoc */
        static id = "perceivable-component-search-form";
        /** @inheritDoc */
        static skipChildrenWhen = "positive";
        /** @inheritDoc */
        static dependencies = [CompliantTraitInteractable];
        /** @inheritDoc */
        static notSubsetOf = [PerceivableTraitTabbable, CompliantTraitInteractable];
        /** @inheritDoc */
        static subsetOf = [PerceivableTraitVisible, PerceivableComponentForm];
        /** @inheritDoc */
        static detect(element, classifier) {
            const inputElements = classifier.getMatched([CompliantTraitInteractable], element).filter((interactableElement) => interactableElement !== element && interactableElement.matches("input, textarea, button, [role=button], [role=searchbox], [role=textbox]"));
            if (inputElements.length === 0) {
                return false;
            }
            const operations = classifier.getOperations(element);
            const width = operations.layoutInfo.width;
            if (width < 100 || width > 800) {
                return false;
            }
            let elementMatch = false;
            for (const match of operations.componentMatch.elements) {
                if (match.type === "search") {
                    elementMatch = true;
                    break;
                }
            }
            if (!elementMatch) {
                return false;
            }
            for (const inputElement of inputElements) {
                const { componentMatch } = classifier.getOperations(inputElement);
                for (const contentMatch of componentMatch.contents) {
                    if (contentMatch.type === "search") {
                        return true;
                    }
                }
                for (const elementMatch of componentMatch.elements) {
                    if (elementMatch.type === "search") {
                        return true;
                    }
                }
            }
            return false;
        }
    }

    /**
     * Detector whether HTML element is considered a background image.
     */
    class PerceivableComponentBackgroundImage extends PerceivableDetector {
        /** @inheritDoc */
        static id = "perceivable-component-background-image";
        /** @inheritDoc */
        static subsetOf = [PerceivableTraitVisible];
        /** @inheritDoc */
        static notSubsetOf = [PerceivableComponentGraphic];
        /** @inheritDoc */
        static detect(element, classifier) {
            const operations = classifier.getOperations(element);
            const backgroundImage = operations.colorInfo.backgroundImage;
            if (!backgroundImage.includes("url(")) {
                return false;
            }
            return operations.contentInfo.hasVisibleText;
        }
    }

    class PerceivableComponentSubmenu extends Detector {
        /** @inheritDoc */
        static id = "perceivable-component-submenu";
        static skipChildrenWhen = "never";
        static subsetOf = [PerceivableComponentClickablesList];
        static dependencies = [PerceivableComponentListMenu];
        static detect(element, classifier) {
            return Boolean(classifier.getParent(element, PerceivableComponentListMenu));
        }
    }

    /**
     * Locate the main content landmark in a Shopify store
     * @returns {SvgOrHtmlElement[] | null}
     */
    function locateShopifyMainContent(classifier) {
        if (CMSService.getCMSName() !== "shopify") {
            return null;
        }
        const main = getShopifyMainContent(classifier);
        return main ? [main] : null;
    }
    /**
     * Detect the main content element in a Shopify store
     * @returns {SvgOrHtmlElement | null}
     */
    function getShopifyMainContent(classifier) {
        // Method #1: Shopify-known main wrappers
        const explicitMain = getExplicitShopifyMain(classifier);
        if (explicitMain) {
            return explicitMain;
        }
        // Method #2: Section-based inference (core logic)
        const sectionBasedMain = getSectionBasedMain(classifier);
        if (sectionBasedMain) {
            return sectionBasedMain;
        }
        return null;
    }
    /**
     * Attempt to detect the main content element using explicit Shopify signals.
     *
     * This method prioritizes:
     * 1. Semantic / compliant main-content components detected by the classifier.
     * 2. Well-known Shopify DOM patterns and wrappers commonly used by themes.
     *
     * Candidates are filtered to ensure they are:
     * - Perceivably visible
     * - Not inside a compliant header or footer
     * - Not inside a perceivable footer
     *
     * This method is intentionally conservative and returns the first valid
     * high-confidence match, or `null` if none are found.
     *
     * @param classifier - The EngineClassifier instance used for semantic
     *                     and perceivable assertions.
     * @returns {SvgOrHtmlElement | null} The detected main content element, or `null`
     *                               if no suitable candidate exists.
     */
    function getExplicitShopifyMain(classifier) {
        const candidates = [
            ...classifier.getMatched([CompliantComponentMainContent]),
            ...document.querySelectorAll(`
    #MainContent,
    .content-for-layout,
    .shopify-section-group-main
  `),
        ];
        const perceivableFooter = classifier.getMatched([PerceivableComponentFooter])[0] ?? null;
        const uniqueCandidates = Array.from(new Set(candidates));
        for (const el of uniqueCandidates) {
            const isVisible = classifier.assert(el, PerceivableTraitVisible);
            if (!isVisible) {
                continue;
            }
            const isInsideHeader = classifier.getParent(el, CompliantComponentHeader);
            const isInsideFooter = classifier.getParent(el, CompliantComponentFooter);
            if (isInsideHeader || isInsideFooter) {
                continue;
            }
            const isInsidePerceivableFooter = perceivableFooter ? perceivableFooter.contains(el) : false;
            if (isInsidePerceivableFooter) {
                continue;
            }
            return el;
        }
        return null;
    }
    /**
     * Infer the main content element in a Shopify store using section-based analysis.
     *
     * This method:
     * 1. Collects Shopify content sections based on Shopify-specific identifiers.
     * 2. Filters out sections that are invisible or located inside headers or footers.
     * 3. Computes the lowest common ancestor (LCA) of the remaining sections.
     *
     * The resulting container is validated to ensure it:
     * - Is not the document body or root element
     * - Is perceivably visible
     *
     * If no valid section grouping can be determined, the method returns `null`,
     * allowing callers to fall back to more generic main-content detection logic.
     *
     * @param classifier - The EngineClassifier instance used to evaluate visibility
     *                     and semantic relationships.
     * @returns {SvgOrHtmlElement | null} The inferred main content container, or `null`
     *                               if inference is not possible.
     */
    function getSectionBasedMain(classifier) {
        const perceivableFooter = classifier.getMatched([PerceivableComponentFooter])[0] ?? null;
        // Collect Shopify content sections
        const sections = Array.from(document.querySelectorAll(`
        [id^="shopify-section-"],
        .shopify-section,
        section[id],
        section[data-section-id]
      `)).filter((el) => {
            if (!classifier.assert(el, PerceivableTraitVisible)) {
                return false;
            }
            if (classifier.getParent(el, CompliantComponentHeader)) {
                return false;
            }
            if (classifier.getParent(el, CompliantComponentFooter)) {
                return false;
            }
            if (perceivableFooter && perceivableFooter.contains(el)) {
                return false;
            }
            return true;
        });
        if (!sections.length) {
            return null;
        }
        const container = getLowestCommonAncestorOfMany(sections);
        if (container === document.body || container === document.documentElement) {
            return null;
        }
        const isVisible = classifier.assert(container, PerceivableTraitVisible);
        if (!isVisible) {
            return null;
        }
        return container;
    }

    /**
     * Locating the main content element.
     */
    class PerceivableComponentMainContent extends Locator {
        /** @inheritDoc */
        static id = "perceivable-component-main-content";
        /** @inheritDoc */
        static dependencies = [CompliantComponentFooter, CompliantComponentHeader, PerceivableTraitVisible, CompliantComponentMainContent];
        /**
         * List of tag names to skip when searching for the main content.
         */
        static tagNamesToSkip = ["nav", "aside", "body", "html"];
        /**
         * The classifier instance, used to match elements against compliant components.
         */
        static classifier;
        /**
         * The footer element detected as part of the perceivable components,
         * which should not be mistaken for the main content.
         * because it's a locator, we get it in advance
         */
        static perceivableFooter;
        static async doLocate(classifier) {
            this.classifier = classifier;
            const shopifyMainContent = locateShopifyMainContent(classifier);
            if (shopifyMainContent) {
                return shopifyMainContent;
            }
            const horizontalCenterPointX = window.innerWidth / 2; // X-coordinate centered on the screen.
            const startingPointY = window.innerHeight / 5; // Start search 20% down from the top of the screen.
            // Get the footer element to exclude it from the main content candidates.
            this.perceivableFooter = (await this.classifier.getMatched([PerceivableComponentFooter]))[0];
            // Start the search for the main content element from the screen's center.
            const candidate = this.getCandidate(horizontalCenterPointX, startingPointY);
            // Return the candidate element if found, otherwise return an empty array.
            if (candidate) {
                return [candidate];
            }
            const largestElement = this.getLargestVisibleElement(classifier);
            return largestElement ? [largestElement] : [];
        }
        /**
         * Recursively finds the best candidate for the main content element by checking elements at the given coordinates.
         *
         * @param {number} x - The X-coordinate to check (centered on the screen).
         * @param {number} y - The Y-coordinate to start checking (progressively increased on recursive calls).
         * @returns {SvgOrHtmlElement | null} - The most likely main content element, or `null` if no valid candidate is found.
         */
        static getCandidate(x, y) {
            // Search for elements at the given coordinates and filter using mainContentCriteria.
            let candidateFromScreenCenter = document
                .elementsFromPoint(x, y)
                .reverse()
                .filter((el) => isSvgOrHtmlElement(el))
                .find(this.mainContentCriteria.bind(this));
            // If no candidate is found, and we haven't reached the bottom of the screen, search further down.
            if (!candidateFromScreenCenter && y <= window.innerHeight) {
                candidateFromScreenCenter = this.getCandidate(x, y * 1.25);
            }
            return candidateFromScreenCenter;
        }
        /**
         * Criteria for validating if an element is the main content.
         *
         * This function checks that:
         * 1. The element is an `SvgOrHtmlElement`.
         * 2. It is not one of the tags to skip (e.g., `<nav>`, `<aside>`, `<body>`, or `<html>`).
         * 3. It is not the perceivable footer or other non-content components (like headers or footers).
         * 4. The element's height is smaller than the document's total scrollable height.
         * 5. The element occupies more than 40% of the total document height to ensure it is a significant content block.
         *
         * @param {Element} el - The element to validate.
         * @returns {boolean} - Returns `true` if the element matches all the criteria; otherwise, `false`.
         */
        static mainContentCriteria(el) {
            return (
            // Ensure the element is an instance of SvgOrHtmlElement to avoid errors.
            isSvgOrHtmlElement(el) &&
                // Ensure the element's tag is not in the list of tags to skip.
                !this.tagNamesToSkip.includes(el.tagName.toLowerCase()) &&
                // Ensure the element is not the footer detected as a perceivable component.
                el !== this.perceivableFooter &&
                // Ensure the element is not identified as a compliant footer or header.
                !this.classifier.assert(el, CompliantComponentFooter) &&
                !this.classifier.assert(el, CompliantComponentHeader) &&
                // Ensure the element's height is smaller than the total document scroll height.
                el.offsetHeight < el.ownerDocument.documentElement.scrollHeight &&
                // Ensure the element takes up more than 40% of the document’s total height.
                el.offsetHeight / el.ownerDocument.documentElement.scrollHeight > 0.4);
        }
        /**
         * Finds and returns the largest visible `SvgOrHtmlElement` within the document,
         * excluding the `<body>` and `<html>` elements. The visibility and layout
         * information of elements are determined using the provided `EngineClassifier`.
         *
         * @param classifier - An instance of `EngineClassifier` used to determine
         *                     the visibility (`PerceivableTraitVisible`) and obtain
         *                     layout information (`layoutInfo`) of elements.
         *
         * @returns The largest visible `SvgOrHtmlElement` found in the document, or `null`
         *          if no such element exists.
         */
        static getLargestVisibleElement(classifier) {
            // Get the dimensions of the <body> element to compare with other elements
            const { layoutInfo: { rect: bodyRect }, } = classifier.getOperations(document.body);
            const bodyWidth = bodyRect.width;
            const bodyHeight = bodyRect.height;
            let largestElement = null;
            let largestArea = 0;
            // Create a TreeWalker to traverse all element nodes within <body>
            const walker = document.createTreeWalker(document.body, NodeFilter.SHOW_ELEMENT, {
                acceptNode: (node) => {
                    // Only consider SvgOrHtmlElement instances
                    if (!isSvgOrHtmlElement(node)) {
                        return NodeFilter.FILTER_SKIP;
                    }
                    // Use the classifier to check if the element is perceivably visible
                    const isVisible = classifier.assert(node, PerceivableTraitVisible);
                    if (!isVisible) {
                        return NodeFilter.FILTER_SKIP;
                    }
                    return NodeFilter.FILTER_ACCEPT;
                },
            });
            // Traverse the DOM tree and evaluate each element
            // the tree walker filters out non HTML elements, so it is safe to cast the node to SvgOrHtmlElement
            let currentNode = walker.nextNode();
            while (currentNode) {
                // Obtain layout information from the classifier
                const { layoutInfo: { rect }, } = classifier.getOperations(currentNode);
                // Check if the element has a non-zero size, width not exceeding the body's width,
                // and height less than the body's height to exclude full-height containers like 'root'
                if (rect.width > 0 && rect.height > 0 && rect.width <= bodyWidth && rect.height < bodyHeight) {
                    const area = rect.width * rect.height;
                    // Update the largest element if the current one is larger
                    if (area > largestArea) {
                        largestElement = currentNode;
                        largestArea = area;
                    }
                }
                // Move to the next node in the TreeWalker
                currentNode = walker.nextNode();
            }
            return largestElement;
        }
    }

    const MAX_LEVEL = 6;
    const MIN_NON_PRIMARY_LEVEL = 2;
    /**
     * A context used to store perceivable heading and calculate the suggested hierarchy of the heading.
     * @extends Context<HeadingContextData>
     */
    class HeadingContext extends Context {
        /** @inheritDoc */
        data = {
            primaryHeading: null,
            headings: new Set(),
            elementLevels: new Map(),
        };
        /** @inheritDoc */
        set({ element }) {
            this.data.headings.add(element);
        }
        /** @inheritDoc */
        postDetect = () => {
            this.setPrimaryHeading();
            this.sortHeadingsByHierarchy();
        };
        /**
         * Gets the heading level of the compliant heading element. First it tries by the aria-level attribute and then
         * falls back to the level in the tagName.
         * @param heading
         */
        getCompliantHeadingLevel(heading) {
            const ariaLevel = heading.getAttribute("aria-level");
            if (ariaLevel) {
                return parseInt(ariaLevel);
            }
            return parseInt(heading.tagName[1]);
        }
        /**
         * Finds the primary heading of the page by filtering for only heading in the fold and then sorting by fontSize.
         * @private
         */
        setPrimaryHeading() {
            let primaryHeadingCandidates = [];
            for (const candidate of this.data.headings) {
                if (this.classifier.assert(candidate, PerceivableTraitScreenReaderOnly)) {
                    const isCompliantH1 = this.classifier.assert(candidate, CompliantComponentHeading) && this.getCompliantHeadingLevel(candidate) === 1;
                    if (isCompliantH1) {
                        primaryHeadingCandidates = [candidate];
                        break;
                    }
                }
                const { layoutInfo, windowInfo } = this.classifier.getOperations(candidate);
                const windowHeight = windowInfo.height;
                const rect = layoutInfo.rect;
                const scrollTop = windowInfo.scrollY;
                if (rect.top + scrollTop > windowHeight * 0.1 && rect.top + scrollTop < windowHeight * 0.9) {
                    primaryHeadingCandidates.push(candidate);
                }
            }
            primaryHeadingCandidates.sort((a, b) => {
                return this.classifier.getOperations(b).typographyInfo.fontSize - this.classifier.getOperations(a).typographyInfo.fontSize;
            });
            if (primaryHeadingCandidates.length) {
                this.data.elementLevels.set(primaryHeadingCandidates[0], 1);
                this.data.primaryHeading = primaryHeadingCandidates[0];
            }
        }
        /**
         * Sorts the heading by hierarchy based on the font size and position of the heading.
         */
        sortHeadingsByHierarchy() {
            const headingsBeforePrimaryHeading = [];
            const currentValues = {
                fontSize: 0,
                level: null,
            };
            const fontSizesByLevel = new Map([
                [1, []],
                [2, []],
                [3, []],
                [4, []],
                [5, []],
                [6, []],
            ]);
            for (const heading of this.data.headings) {
                const { fontSize } = this.classifier.getOperations(heading).typographyInfo;
                if (!currentValues.level) {
                    if (heading !== this.data.primaryHeading) {
                        headingsBeforePrimaryHeading.push(heading);
                    }
                    else {
                        this.initializeCurrentLevel(currentValues);
                    }
                    continue;
                }
                if (currentValues.fontSize > fontSize) {
                    this.incrementLevel(currentValues, fontSize);
                }
                else if (currentValues.fontSize < fontSize) {
                    this.setLevelToClosestLevelByFontSize(currentValues, fontSizesByLevel, fontSize);
                }
                this.setHeadingLevel(heading, currentValues, fontSizesByLevel);
            }
            for (const heading of headingsBeforePrimaryHeading) {
                this.setLevelOfHeadingBeforePrimaryHeading(heading, fontSizesByLevel);
            }
        }
        /**
         * Initializes the current level as 1 and the font size as Infinity.
         * @param currentValues
         * @private
         */
        initializeCurrentLevel(currentValues) {
            currentValues.level = 1;
            currentValues.fontSize = Infinity;
        }
        /**
         * Increments the level and sets the current font size as the new font size.
         * @param currentValues
         * @param newFontSize
         * @private
         */
        incrementLevel(currentValues, newFontSize) {
            currentValues.level = Math.min(currentValues.level + 1, MAX_LEVEL);
            currentValues.fontSize = newFontSize;
        }
        /**
         * Sets the level to the closest level by font size and sets the current font size as the new font size.
         * @param currentValues
         * @param fontSizesByLevel
         * @param newFontSize
         * @private
         */
        setLevelToClosestLevelByFontSize(currentValues, fontSizesByLevel, newFontSize) {
            const closestLevel = this.getClosestLevelByFontSize(newFontSize, fontSizesByLevel);
            currentValues.level = Math.max(closestLevel || MIN_NON_PRIMARY_LEVEL, MIN_NON_PRIMARY_LEVEL);
            currentValues.fontSize = newFontSize;
        }
        /**
         * Sets the level of the heading as the current level and adds the current font size to the current level in fontSizesByLevel map.
         * @param heading
         * @param currentValues
         * @param fontSizesByLevel
         * @private
         */
        setHeadingLevel(heading, currentValues, fontSizesByLevel) {
            fontSizesByLevel.get(currentValues.level).push(currentValues.fontSize);
            this.data.elementLevels.set(heading, currentValues.level);
        }
        /**
         * Sets the level of the prePrimary heading to the closest level by font size.
         * @param heading
         * @param fontSizesByLevel
         * @private
         */
        setLevelOfHeadingBeforePrimaryHeading(heading, fontSizesByLevel) {
            const fontSize = this.classifier.getOperations(heading).typographyInfo.fontSize;
            const closestLevel = this.getClosestLevelByFontSize(fontSize, fontSizesByLevel);
            this.data.elementLevels.set(heading, Math.max(closestLevel || MIN_NON_PRIMARY_LEVEL, MIN_NON_PRIMARY_LEVEL));
        }
        /**
         * Finds the level with the closest average fontSize.
         * @param fontSize
         * @param fontSizesByLevel
         * @private
         */
        getClosestLevelByFontSize(fontSize, fontSizesByLevel) {
            let closestLevel = 1;
            let smallestDiff = Infinity;
            for (const [level, fontSizes] of fontSizesByLevel) {
                if (fontSizes.length === 0)
                    continue;
                const avgFontSize = fontSizes.reduce((a, b) => a + b, 0) / fontSizes.length;
                const diff = Math.abs(avgFontSize - fontSize);
                if (diff < smallestDiff) {
                    smallestDiff = diff;
                    closestLevel = level;
                }
            }
            return closestLevel;
        }
    }

    /**
     * Detects if an element is a perceivable heading.
     */
    class PerceivableComponentHeading extends PerceivableDetector {
        /** @inheritDoc */
        static id = "perceivable-component-heading";
        /** @inheritDoc */
        static skipChildrenWhen = "positive";
        /** @inheritDoc */
        static notSubsetOf = [];
        /** @inheritDoc */
        static subsetOf = [PerceivableTraitRenderable];
        static contextType = HeadingContext;
        /** @inheritDoc */
        static dependencies = [CompliantComponentHeading, PerceivableTraitScreenReaderOnly];
        static potentialHeadingTags = ["DIV", "SPAN", "STRONG", "EM", "B", "I", "U", "DEL", "S", "P", "STRIKE", "BLOCKQUOTE", "FIGCAPTION", "LABEL", "LEGEND", "H1", "H2", "H3", "H4", "H5", "H6"];
        /** @inheritDoc */
        static detect(element, classifier, _, context) {
            if (!this.potentialHeadingTags.includes(element.tagName)) {
                return false;
            }
            /**
             * If the element is screen-reader only, we need to check if it is a compliant h1.
             */
            if (classifier.assert(element, PerceivableTraitScreenReaderOnly)) {
                const isCompliantH1 = classifier.assert(element, CompliantComponentHeading) && context.getCompliantHeadingLevel(element) === 1;
                if (isCompliantH1) {
                    context.set({ element });
                    return true;
                }
            }
            const { typographyInfo, contentInfo } = classifier.getOperations(element);
            if (!isTextLengthInRange(contentInfo.visibleTextGenerator, { min: 3, max: 70 })) {
                return false;
            }
            const { typographyInfo: { fontSize: baseFontSize, fontWeight: basefontWeight, lineHeight: baseLineHeight }, } = classifier.getOperations(document.body);
            const { fontSize, fontWeight, lineHeight, textTransform } = typographyInfo;
            const isUpperCase = textTransform === "uppercase";
            if (!(fontSize > baseFontSize && (fontWeight > basefontWeight || lineHeight > baseLineHeight || isUpperCase))) {
                return false;
            }
            context.set({ element });
            return true;
        }
    }

    /**
     * Detects superscript elements
     */
    class PerceivableComponentSuperscript extends CompliantDetector {
        /** @inheritDoc */
        static id = "perceivable-component-superscript";
        /** @inheritDoc */
        static subsetOf = [PerceivableTraitVisible];
        static dependencies = [];
        /** @inheritDoc */
        static detect(element, classifier) {
            const { verticalAlign, fontVariantPosition } = classifier.getOperations(element).resources.computedStyle;
            return verticalAlign === "super" || fontVariantPosition === "super";
        }
    }

    /**
     * Detects subscript elements
     */
    class PerceivableComponentSubscript extends CompliantDetector {
        /** @inheritDoc */
        static id = "perceivable-component-subscript";
        /** @inheritDoc */
        static subsetOf = [PerceivableTraitVisible];
        static dependencies = [];
        /** @inheritDoc */
        static detect(element, classifier) {
            const { verticalAlign, fontVariantPosition } = classifier.getOperations(element).resources.computedStyle;
            return verticalAlign === "sub" || fontVariantPosition === "sub";
        }
    }

    //TODO: X -  Make single itteration on the DOM?
    //TODO: support for iframes and shadow dom
    //TODO: support animationEnd and transitionEnd
    //TODO: handle click events to trigger instant update
    //TODO: complete event handling
    //TODO: write tests
    /**
     * @class EngineClassifier
     * @classdesc Classifies the elements in the given root element
     * @param root the root element to classify
     * @param detectors the detectors to classify the elements with
     * @example
     * const classifier = new EngineClassifier(document.body, [EngineClassifier.Traits.Visible, EngineClassifier.Traits.Clickable]);
     * //Get the matched elements
     * const matchedElements = classifier.getMatched([EngineClassifier.Traits.Visible, EngineClassifier.Traits.Clickable]);
     * //Get the matched elements within a custom root
     * const matchedElements = classifier.getMatched([EngineClassifier.Traits.Visible, EngineClassifier.Traits.Clickable], customRoot);
     * //Get the matched elements including the root
     * const matchedElements = classifier.getMatchedInclusive([EngineClassifier.Traits.Visible, EngineClassifier.Traits.Clickable]);
     * //Assert whether the element is visible
     * const isVisible = classifier.assert(element, EngineClassifier.Traits.Visible);
     */
    class EngineClassifier extends EventEmitter {
        root;
        /**
         * List of all the operations
         */
        static Operations = OperationService;
        /**
         * The stats service
         */
        stats = Stats;
        /**
         * The state of the detections
         * It contains the state of all the elements and the detectors they are detected by
         */
        state = new State();
        /**
         * The dependency graph that will be used to determine the order of the detectors
         */
        rulesDependencyGraph;
        /**
         * The context service in charge of managing the context instances
         */
        contextService = new ContextService();
        /**
         * List of all the locators in use
         */
        locators;
        /**
         * The debouncer for the mutations
         */
        mutationDebouncer;
        /**
         * The mutation observer that will be used to observe the mutations in the document
         */
        observer;
        /**
         * The service that will be used to manage and query modifications provided by the setOptions method
         * @see setOptions
         */
        modificationsService;
        /**
         * List of all available validators
         */
        validators = Validators;
        // Ensures the classification process is triggered only once
        isRunning = false;
        delay = 2000;
        /**
         * @constructor
         * @param root The root element that the processing will start from
         * @param detectorsOrLocators the detector to classify the elements with
         */
        constructor(root, detectorsOrLocators) {
            if (!window.document.body.contains(root)) {
                throw new Error("The root element must be a child of the document.body or the body itself");
            }
            super();
            this.root = root;
            const actualDetectors = detectorsOrLocators.filter((detectorOrLocator) => isDetector(detectorOrLocator));
            const actualLocators = detectorsOrLocators.filter((detectorOrLocator) => isLocator(detectorOrLocator));
            const combinedDetectors = [...new Set([...OperationService.dependencies, ...actualDetectors, ...actualLocators.map((locator) => locator.dependencies)].flat())];
            this.rulesDependencyGraph = new DependencyGraph(combinedDetectors);
            this.modificationsService = new ModificationsService$1(this.root);
            void LanguageService.detectAndSetLocale();
            this.mutationDebouncer = new Debounce(this.delay);
            this.observer = new MutationObserver((mutations) => {
                this.mutationDebouncer.execute((accumulatedMutations) => {
                    //Iterating the accumulated mutations in reverse order and creating a distinct accumulatedMutations based on the "target".
                    //Due to performance concerns/issues, we ensure only the last (and relevant) mutation is processed
                    const uniqueMutations = new Map();
                    for (const mutation of accumulatedMutations) {
                        OperationService.removeElementFromCache(mutation.target);
                        if (EngineClassifier.isRelevantNode(mutation.target)) {
                            uniqueMutations.set(mutation.target, mutation);
                        }
                    }
                    this.onMutation(root, this.rulesDependencyGraph.sortedDetectors, Array.from(uniqueMutations.values()));
                }, mutations);
            });
            document.addEventListener("animationend", (ev) => {
                this.requestMutation(ev.target);
            });
            document.addEventListener("transitionend", (ev) => {
                this.requestMutation(ev.target);
            });
            /**
             * We need to observe the following:
             * 1. subtree - to observe all the children of the root
             * 2. childList - to observe when children are added or removed
             * 3. attributes - to observe when attributes are changed
             */
            this.observer.observe(document.documentElement, {
                subtree: true,
                childList: true,
                attributes: true,
                attributeOldValue: true,
            });
            this.locators = actualLocators;
        }
        /**
         * Public method that allows to update the detectors and locators to be used by the classifier after the initialization
         */
        updateDetectors(detectorsOrLocators) {
            const actualDetectors = detectorsOrLocators.filter((detectorOrLocator) => isDetector(detectorOrLocator));
            const actualLocators = detectorsOrLocators.filter((detectorOrLocator) => isLocator(detectorOrLocator));
            const combinedDetectors = [...new Set([this.rulesDependencyGraph.sortedDetectors, ...OperationService.dependencies, ...actualDetectors, ...actualLocators.map((locator) => locator.dependencies)].flat())];
            this.rulesDependencyGraph = new DependencyGraph([...new Set(combinedDetectors)]);
        }
        /**
         * Starts the classification process.
         *
         * This method is intended to run only once —
         * subsequent calls will be ignored.
         */
        run() {
            if (this.isRunning)
                return Promise.resolve();
            return new Promise((res) => {
                this.isRunning = true;
                requestIdleCallback(() => {
                    const measurer = Stats.createMeasure("initial", { initial: true });
                    this.process(this.root, this.rulesDependencyGraph.sortedDetectors);
                    this.mutationDebouncer.resetAccumulatedMutations();
                    this.mutationDebouncer.resetLastInvocation();
                    measurer.end();
                    res();
                }, { timeout: this.delay });
            });
        }
        assert(node, detectorOrLocator) {
            if (isLocator(detectorOrLocator)) {
                const modification = this.modificationsService.getModificationByLocatorId(detectorOrLocator.id);
                if (modification) {
                    const { selectorMethod, selector } = modification;
                    const elements = selectorMethod ? selectorMethod(this.root, selector) : Array.from(document.querySelectorAll(selector));
                    return elements.includes(node);
                }
                else {
                    // TODO?: remove promise - locator are sync now
                    return new Promise((resolve) => {
                        detectorOrLocator.locate(this).then((elements) => resolve(elements.includes(node)));
                    });
                }
            }
            else {
                if (!this.rulesDependencyGraph.graph.has(detectorOrLocator)) {
                    throw new Error(`The classifier was not initialized with the given detector. [detector: ${detectorOrLocator.name}]`);
                }
                return Boolean(this.state.getByNode(detectorOrLocator, node));
            }
        }
        /**
         * Returns a list of all the elements that match the given detectors including the root element
         * @param detectors list of the detectors to match
         * @param root the root element to get all matching elements from within
         */
        getMatchedInclusive(detectors, root) {
            const matchingNodes = this.getMatchedNodes(detectors, root);
            const rootMatches = detectors.every((detector) => this.assert(root, detector));
            if (rootMatches) {
                matchingNodes.unshift(root);
            }
            return matchingNodes;
        }
        /**
         * Returns a list of all the direct children of the root element that match the given detectors
         * @param detectors list of the detectors to match
         * @param root the root element to get all matching children from within
         */
        getMatchedDirect(detectors, root) {
            const result = [];
            for (let i = 0; i < root.children.length; i++) {
                const child = root.children[i];
                // Filter only valid elements early
                if (!isSvgOrHtmlElement(child))
                    continue;
                // Fail fast: short-circuit if any detector doesn't match
                let matches = true;
                for (let j = 0; j < detectors.length; j++) {
                    if (!this.assert(child, detectors[j])) {
                        matches = false;
                        break;
                    }
                }
                if (matches)
                    result.push(child);
            }
            return result;
        }
        /**
         * Returns a list of all the elements that match the given detectors
         * The filter has three stages:
         * 1. sorting the dependency array from the deepest to the shallowest
         * 2. getting all the elements that match the first detector
         * 3. filtering the elements that don't match the rest of the detectors || are not within the custom root
         *
         * @param detectors list of the detectors to match
         * @param customRoot optional custom root to get all matching elements from within (other than getting all matched elements in the document.body)
         */
        getMatchedNodes(detectors, customRoot) {
            const subsets = detectors.map((detector) => this.state.getByDetector(detector));
            subsets.sort((a, b) => b.size - a.size);
            const useCustomRoot = customRoot && customRoot !== this.root;
            const children = useCustomRoot ? getAllDescendants(customRoot) : [];
            const results = [];
            const smallestSubset = subsets.pop();
            loop: for (const node of smallestSubset) {
                for (const subset of subsets) {
                    if (!subset.has(node)) {
                        continue loop;
                    }
                }
                if (!useCustomRoot || children.includes(node)) {
                    results.push(node);
                }
            }
            return results;
        }
        getMatched(detectorsOrLocator, customRoot) {
            const locator = detectorsOrLocator.find((detector) => detector["locate"]);
            if (locator && detectorsOrLocator.length > 1) {
                throw new Error("Locator can't be used with other detectors or locators");
            }
            else if (locator) {
                const modification = this.modificationsService.getModificationByLocatorId(locator.id);
                if (modification) {
                    const { selectorMethod, selector } = modification;
                    return selectorMethod ? selectorMethod(this.root, selector) : Array.from(document.querySelectorAll(selector));
                }
                else {
                    return locator.locate(this);
                }
            }
            return this.getMatchedNodes(detectorsOrLocator, customRoot);
        }
        /**
         * Returns the parent of a given node that matches given `Detector`
         * @param node the node to check
         * @param parentType the parent type to check
         */
        getParent(node, parentType) {
            let parentElement = getParentElement(node);
            while (parentElement) {
                if (this.state.getByNode(parentType, parentElement)) {
                    return parentElement;
                }
                parentElement = getParentElement(parentElement);
            }
            return null;
        }
        getOperations(element) {
            return new OperationService(element, this);
        }
        /**
         * Returns the context instance of the given detector from the context service
         * @param detector
         */
        getContext(detector) {
            return this.contextService.getContext(detector);
        }
        /**
         * Returns the data from the context instance of the given detector from the context service
         * @param detector
         */
        getContextData(detector) {
            return this.contextService.getContext(detector).get();
        }
        /**
         * Requests a mutation on the given element
         * It will trigger the re-classification of the element and all its children
         * @param element the element to request a mutation on
         */
        requestMutation(element) {
            const mockNodes = document.createElement("div").childNodes;
            const mutation = {
                target: element,
                attributeName: "requested-mutation",
                addedNodes: mockNodes,
                removedNodes: mockNodes,
                nextSibling: null,
                oldValue: "mock value",
                previousSibling: null,
                type: "attributes",
                attributeNamespace: null,
            };
            this.mutationDebouncer.execute((accumulatedMutations) => {
                //Iterating the accumulated mutations in reverse order and creating a distinct accumulatedMutations based on the "target".
                //Due to performance concerns/issues, we ensure only the last (and relevant) mutation is processed
                const uniqueMutations = new Map();
                for (const mutation of accumulatedMutations) {
                    OperationService.removeElementFromCache(mutation.target);
                    if (EngineClassifier.isRelevantNode(mutation.target)) {
                        uniqueMutations.set(mutation.target, mutation);
                    }
                }
                this.onMutation(this.root, this.rulesDependencyGraph.sortedDetectors, Array.from(uniqueMutations.values()));
            }, [mutation], { tail: true });
        }
        /**
         * Allows the user to set custom detection options.
         * The detection option is a map where the key is a CSS selector,
         * and the value is an object containing the detector and its expected result.
         * For each matching element in the root, this will set the state for the detector.
         */
        setOptions({ modifications }) {
            if (modifications) {
                this.modificationsService.setModifications(modifications);
                // The options are usually set before the initial run and don't require a mutation sync, in case the options are set after the initial run, we need to sync the mutations
                if (this.isRunning) {
                    const effectedNodes = this.modificationsService.getEffectedElements(modifications);
                    this.requestMutationSync(effectedNodes);
                }
            }
        }
        /**
         * Processes the given root element and all its children
         * It will apply the given detectors to all the elements
         * It will not apply the detectors to elements that are nested in elements that are already processed
         * It will not apply the detectors to elements that are nested in elements that are not interactable
         */
        process(processRoot, detectors, isPartial = false) {
            const modifications = this.modificationsService.getModifications();
            const additionRoots = new Map();
            for (const detector of detectors) {
                if (detector.contextType && !this.contextService.getContext(detector)) {
                    const context = new detector.contextType(this);
                    this.contextService.addContext(detector, context);
                }
                const acceptNodeFilter = (node) => {
                    if (node.nodeType !== Node.ELEMENT_NODE) {
                        return NodeFilter.FILTER_REJECT;
                    }
                    if (!isSvgOrHtmlElement(node)) {
                        return NodeFilter.FILTER_SKIP;
                    }
                    /**
                     * Handling modifications for the given node
                     */
                    if (modifications.getByElement(node, "ignore").length > 0) {
                        return NodeFilter.FILTER_REJECT;
                    }
                    /**
                     * if the node is a shadow root, we need to process its subtree
                     */
                    if (node.shadowRoot) {
                        if (!additionRoots.has(node.shadowRoot)) {
                            additionRoots.set(node.shadowRoot, detectors);
                        }
                    }
                    /**
                     * if the node is an iframe, we need to process its subtree
                     *
                     * NOTE:
                     * - the `defaultView.HTMLIFrameElement` is required for nested iframe element detection to work (since the context of the iframe is different from the parent document)
                     * - we need to check if we have access to the iframe's document to prevent cross-origin error
                     * - we should not pass a fallback top window to the `getOwnerWindow` function or it will re-enter the top-most window in an infinite loop
                     */
                    if (isInstanceOf(node, HTMLIFrameElement)) {
                        try {
                            const iframeContext = node.contentWindow; // the inner context to access the iframe's document.body
                            if (iframeContext && iframeContext.document.body) {
                                this.process(iframeContext.document.body, [detector]);
                            }
                        }
                        catch { }
                    }
                    for (const notChildOf of detector.notChildOf) {
                        if (this.getParent(node, notChildOf)) {
                            return NodeFilter.FILTER_REJECT;
                        }
                    }
                    if (this.state.detectorToNodes.get(detector)?.size >= detector.maxMatches) {
                        return NodeFilter.FILTER_REJECT;
                    }
                    for (const subsetOf of detector.subsetOf) {
                        if (!this.state.getByNode(subsetOf, node)) {
                            if (detector.skipChildrenWhen === "negative") {
                                return NodeFilter.FILTER_REJECT;
                            }
                            else {
                                return NodeFilter.FILTER_SKIP;
                            }
                        }
                    }
                    for (const notSubsetOf of detector.notSubsetOf) {
                        if (this.state.getByNode(notSubsetOf, node)) {
                            if (detector.skipChildrenWhen === "negative") {
                                return NodeFilter.FILTER_REJECT;
                            }
                            else {
                                return NodeFilter.FILTER_SKIP;
                            }
                        }
                    }
                    if (detector.ignoreUpdates && this.state.getByNode(detector, node) !== undefined) {
                        return NodeFilter.FILTER_REJECT;
                    }
                    /**
                     * In case of a partial update where the node's parent is not the root, we need to mimic the `skipChildrenWhen` by checking if a parent was already detected to be positive or negative.
                     * The `node.parentElement !== this.root` check is to prevent the detector from being applied to the root.
                     * This logic is tested in ~/src/perceivable/traits/renderable/atomic-tests/pass/main-div-update-role-presentation.html.
                     */
                    const parent = getParentElement(node);
                    if (isPartial && parent !== this.root) {
                        if (detector.skipChildrenWhen === "positive" && this.getParent(node, detector)) {
                            return NodeFilter.FILTER_REJECT;
                        }
                        if (detector.skipChildrenWhen === "negative" && !this.assert(parent, detector)) {
                            return NodeFilter.FILTER_REJECT;
                        }
                    }
                    let detection;
                    if (modifications.isDetectorIgnored(detector.id)) {
                        detection = false;
                    }
                    else {
                        const modification = modifications.getByElement(node, "detection");
                        const modificationForDetector = modification.find((modification) => modification.detectorId === detector.id);
                        if (modificationForDetector) {
                            detection = modificationForDetector.expected;
                        }
                        else {
                            // eslint-disable-next-line sonarjs/nested-control-flow
                            try {
                                detection = detector.detect(node, this, this.getOperations(node), this.getContext(detector));
                            }
                            catch (ex) {
                                console.error(ex);
                                this.emit("error", "Failed to run detector on element. [detector: " + detector.id + ", element: " + node.cloneNode(false).outerHTML + "]", ex);
                            }
                        }
                    }
                    this.state.set(node, detector, detection);
                    if (typeof detector.skipChildrenWhen === "function" && detector.skipChildrenWhen(node, this)) {
                        return NodeFilter.FILTER_REJECT;
                    }
                    if (detection === false && detector.skipChildrenWhen === "negative") {
                        return NodeFilter.FILTER_REJECT;
                    }
                    if (detection && detector.skipChildrenWhen === "positive") {
                        return NodeFilter.FILTER_REJECT;
                    }
                    return NodeFilter.FILTER_ACCEPT;
                };
                const walker = document.createTreeWalker(processRoot, NodeFilter.SHOW_ELEMENT, {
                    acceptNode: acceptNodeFilter,
                });
                /**
                 * We don't want to process the root (document.body), due to perfomance concerns and false positive detections
                 * Note: we do process any nested HTMLBodyElements inside iframes
                 *
                 * TODO: there are some concerns of inconsistency with this approach, but it's the way the classifier worked before and we want to preserve the same behavior while allowing partial updates to access nested roots
                 * we might re-visit this in the future to allow processing the root element as well.
                 */
                if (this.root !== processRoot) {
                    acceptNodeFilter(processRoot); // Ensures the root element is processed
                }
                while (walker.nextNode()) { }
                this.getContext(detector)?.postDetect?.();
            }
            const processedRoot = processRoot.getRootNode();
            if (!this.state.processedRoots.has(processedRoot)) {
                this.emit("rootProcessed", processedRoot);
            }
            this.state.processedRoots.add(processedRoot);
            for (const [additionRoot, detectors] of additionRoots) {
                this.process(additionRoot, Array.from(detectors));
            }
        }
        /**
         * Lists all the root elements that have been processed
         */
        get processedRoots() {
            return this.state.processedRoots;
        }
        /**
         * handler for mutations
         */
        onMutation(root, detectors, mutations) {
            const modifiedNodes = EngineClassifier.parseMutations(mutations);
            const topMostRecords = Array.from(EngineClassifier.getTopMostElements(modifiedNodes));
            const hasBodyMutation = topMostRecords.find((node) => node.node instanceof HTMLBodyElement);
            const hasGlobalMutation = hasBodyMutation || EngineClassifier.hasGlobalMutation(mutations, root);
            const measurer = Stats.createMeasure("update");
            if (hasGlobalMutation) {
                this.state.clear();
                OperationService.clearCache();
                this.invalidateLocatorsCache();
                this.process(root, detectors);
                this.emit("update", [{ action: "changed", node: root }]);
            }
            else {
                this.onPartialUpdate(detectors, topMostRecords);
                this.emit("update", topMostRecords);
            }
            measurer.end({
                type: hasGlobalMutation ? "global" : "partial",
                mutationCount: mutations.length,
            });
        }
        /**
         * handler for partial mutations
         * It will apply the given detectors to all the elements possibly affected by the mutations
         */
        onPartialUpdate(detectors, modifiedNodes) {
            if (modifiedNodes.length === 0) {
                return;
            }
            for (const parsedMutationRecord of modifiedNodes) {
                const elements = getAllDescendants(parsedMutationRecord.node).filter(isSvgOrHtmlElement);
                elements.unshift(parsedMutationRecord.node);
                for (const element of elements) {
                    this.state.removeNodeFromStateByDetectors(element, detectors);
                    OperationService.removeElementFromCache(element);
                    this.invalidateLocatorsCache(element);
                }
            }
            for (const { action, node } of modifiedNodes) {
                if (action === "added" || action === "changed") {
                    this.process(node, detectors, true);
                }
            }
        }
        /**
         * Disables the debouncer execution (while still accumulating mutations)
         */
        pause() {
            this.mutationDebouncer.disableExecution();
        }
        /**
         * Enables the debouncer execution
         */
        resume() {
            this.mutationDebouncer.enableExecution();
        }
        /**
         * Given an expected state for an element, it will wait for the state to be reached to resolve the promise with a true result or timeout with a false result if the state is not reached
         * @param expectedState the expected state for the element
         * @param element the element to assert the state against
         * @param timeout the timeout for the promise
         * @param interval the interval for the promise
         * @param comparisonMethod the method to use for the comparison, either "every" or "some"
         */
        waitForState(expectedState, element, { timeout = 700, interval = 100, comparisonMethod = "every", } = {}) {
            return new Promise((resolve) => {
                /**
                 * A function that checks if the classifier's state for a given element matches the expected state
                 * @param reprocess whether to reprocess the element or not, this prevents unnecessary reprocessing that can cause performance issues
                 */
                const isStateMatching = ({ reprocess }) => {
                    return expectedState.entries()[comparisonMethod](([expectedDetector, expectedValue]) => {
                        if (reprocess) {
                            this.requestMutationSync(new Set([element]), (detector) => detector === expectedDetector);
                        }
                        return this.state.nodeToDetectors.get(element)?.[expectedDetector.name] === expectedValue; // we check against state and not with 'assert' because we want to receive 'undefined' if the element is not in the state ('assert' will return false)
                    });
                };
                /** before the interval we check if the state is matching without reprocess */
                if (isStateMatching({ reprocess: false })) {
                    resolve(true);
                }
                const intervalId = setInterval(() => {
                    if (isStateMatching({ reprocess: true })) {
                        clearInterval(interval);
                        resolve(true);
                    }
                }, interval);
                setTimeout(() => {
                    clearInterval(intervalId);
                    resolve(false);
                }, timeout);
            });
        }
        /**
         * Checks if the given node has been processed by the classifier and exists in the state
         * @param node the node to check if it has been processed
         */
        hasBeenProcessed(node) {
            return typeof this.state.getByNode(PerceivableTraitRenderable, node) !== "undefined";
        }
        /**
         * A public method for notifying the classifier that a mutation has been made on the given `modifiedNodes`
         * It will trigger the re-classification of the elements and all its children
         * @param modifiedNodes the nodes that have been modified
         * @param predicate a predicate to filter the detectors
         */
        requestMutationSync(modifiedNodes, predicate = () => true) {
            /**
             * The types of elements being sent in `modifiedNodes` are not guaranteed to be connected to the DOM
             * The `modifiedNodes` are filtered to only include elements that are relevant to the classifier.
             *
             * NOTE: we are traversing the parent elements of each modified node to find the first relevant node that wasnn't processed by the classifier in a subtree, otherwise this would falsley skip in isPartial/skipChildrenWhen checks when checking against PerceivableTraitRenderable
             */
            const relevantNodes = [];
            for (const node of modifiedNodes) {
                let currentNode = node;
                while (currentNode) {
                    const parent = getParentElement(currentNode);
                    /**
                     * if the parent is null it's irrelevant because we don't want to process null elements, so we return the current node
                     * if the parent has been processed, we can stop traversing up the tree and get the current node, because we want the top-most node that hasn't been processed yet
                     * if the currentNode is the inital root, we can stop traversing up the tree and get the current node since we dont't want to process elements above the root
                     */
                    if (!parent || this.hasBeenProcessed(parent) || this.root === currentNode) {
                        break;
                    }
                    currentNode = parent;
                }
                relevantNodes.push(currentNode);
            }
            const parsedMutations = relevantNodes.map((node) => {
                return {
                    action: "changed",
                    node: node,
                };
            });
            /**
             * given a precidate, we need to find all the detectors that match the predicate as well as their dependencies according to the dependency graph
             */
            const graph = new DependencyGraph(this.rulesDependencyGraph.sortedDetectors.filter((detector) => predicate(detector)));
            this.onPartialUpdate(graph.sortedDetectors, parsedMutations);
            this.mutationDebouncer.resetLastInvocation();
        }
        /**
         * Returns a list of the top most elements
         * Meaning it will return the elements that are not nested in any element in the list
         */
        static getTopMostElements(records) {
            const topMostElements = [];
            for (const record of records) {
                let isNested = false;
                for (const otherRecord of records) {
                    if (record.node !== otherRecord.node && otherRecord.node.contains(record.node)) {
                        isNested = true;
                        break;
                    }
                }
                if (!isNested) {
                    topMostElements.push(record);
                }
            }
            // dedupe by action + node identity
            const actionsByNode = new Map();
            const deduped = new Set();
            for (const record of topMostElements) {
                if (!actionsByNode.has(record.node)) {
                    actionsByNode.set(record.node, new Set());
                }
                const recordActions = actionsByNode.get(record.node);
                if (!recordActions.has(record.action)) {
                    recordActions.add(record.action);
                    deduped.add(record);
                }
            }
            return deduped;
        }
        /**
         * Parses the given mutations and returns a list of all the modified nodes
         * @param mutations list of mutation to parse
         */
        static parseMutations(mutations) {
            const result = [];
            for (const mutation of mutations) {
                const addedNodes = this.getRelevantMutatedNodes(mutation.addedNodes);
                const removedNodes = this.getRelevantMutatedNodes(mutation.removedNodes);
                const nodesAddedOrRemoved = Boolean(addedNodes.length + removedNodes.length);
                if (mutation.type === "childList") {
                    for (const node of addedNodes) {
                        result.push({ action: "added", node });
                    }
                    for (const node of removedNodes) {
                        result.push({ action: "removed", node });
                    }
                    if (nodesAddedOrRemoved) {
                        result.push({ action: "changed", node: mutation.target });
                    }
                }
                /**
                 * the mutation target is added in order to cover coses where the change in child elements
                 * affects the detection status of the target itself (making it discernible, visible, etc.)
                 * we know it doesn't cover ALL potential cases (like when it should change the detection status of the target's ancestors)
                 * for now it's sufficient, we haven't encountered such problem yet
                 */
                if (mutation.type === "attributes" && this.isRelevantAttributeChangeMutation(mutation)) {
                    result.push({ action: "changed", node: mutation.target });
                }
            }
            return result;
        }
        /**
         * Filters the mutated nodes to only include relevant nodes
         * Meaning they are SvgOrHtmlElements and not legacy engine elements
         * @param mutatedNodes
         * @private
         */
        static getRelevantMutatedNodes(mutatedNodes) {
            const nodes = [];
            for (const node of mutatedNodes) {
                if (isSvgOrHtmlElement(node) && !this.isLegacyEngineElement(node)) {
                    nodes.push(node);
                }
            }
            return nodes;
        }
        /**
         * Determines whether the given mutation is a relevant attribute change mutation
         * Meaning it's an SvgOrHtmlElement and the attribute value has changed
         * @param mutation the mutation to check
         */
        static isRelevantAttributeChangeMutation(mutation) {
            if (!isSvgOrHtmlElement(mutation.target)) {
                return false;
            }
            // ignore all helper attributes set by the legacy code - the legacy code sets attributes excessively, it causes extra mutations and thus affect performance
            if (mutation.attributeName.includes("acsb")) {
                return false;
            }
            return mutation.oldValue !== mutation.target.getAttribute(mutation.attributeName);
        }
        /**
         * Determines whether the given mutations have a global effect
         * Meaning they affect the whole page, for example a style tag was added
         * @param mutations
         * @param root the root element
         */
        static hasGlobalMutation(mutations, root) {
            return mutations.some((mutation) => {
                if (mutation.type === "childList") {
                    for (let i = 0; i < mutation.addedNodes.length; i++) {
                        if (isInstanceOf(mutation.addedNodes[i], HTMLStyleElement)) {
                            return true;
                        }
                    }
                    return false;
                }
                if (mutation.type === "attributes" && this.isRelevantAttributeChangeMutation(mutation)) {
                    return isInstanceOf(mutation.target, HTMLStyleElement) || mutation.target === root;
                }
                return false;
            });
        }
        /**
         * Determines whether the given node is relevant.
         * Meaning it's an SvgOrHTMLElement & Renderable
         */
        static isRelevantNode(node) {
            return isSvgOrHtmlElement(node) && PerceivableTraitRenderable.detect(node);
        }
        /**
         * Determines whether the given node is an acsb element
         * @param node the node to check
         */
        static isLegacyEngineElement(node) {
            // what other classes should we include here? what are `.acsb-shown`, `acsb-ready`?
            return node.matches(".acsb-tooltip, .acsb-sr-only, .acsb-trigger, .acsb-trigger-hidden, .acsb-widget");
        }
        /**
         * Clears the cache of all the locators by given element
         * if no element is given, it will clear the cache of all the locators
         */
        invalidateLocatorsCache(element) {
            const locators = element ? this.locators.filter((loc) => loc.getCachedMatches().includes(element)) : this.locators;
            locators.forEach((locator) => locator.clearCache());
        }
    }

    /**
     * Responsible for managing modifications to the Audit Report.
     * Made to allow the `getReport` method in the `index.ts` easy way of getting the modifications and implementing the modifications
     */
    class ModificationsService {
        rootElement;
        modifications = [];
        resultArrays = ["passedNodes", "inapplicableNodes", "cantTellNodes", "failedNodes"];
        /**
         * Indicates whether to run the default audit report
         * If true, only the modifications will be used to generate the report.
         * @default false
         */
        manualOnly = false;
        constructor(rootElement) {
            this.rootElement = rootElement;
            this.rootElement = rootElement;
        }
        /**
         * Sets the modifications after validating them.
         * Only valid modifications will be stored.
         *
         * @param modifications - An array of Modification objects.
         */
        setModifications(modifications) {
            this.modifications = modifications.filter(this.validateModification.bind(this));
        }
        /**
         * Retrieves the currently stored, validated modifications.
         *
         * @returns An array of Modification objects.
         */
        getModifications() {
            return this.modifications;
        }
        /**
         * Retrieves a single modification associated with the given rule ID.
         *
         * Searches the stored modifications and returns the first one that matches the provided ruleId.
         *
         * @param ruleId - The ID of the rule to search for.
         * @returns The matching Modification object, or undefined if no match is found.
         */
        getModificationByRuleId(ruleId) {
            return this.modifications.find((modification) => modification.ruleId === ruleId);
        }
        /**
         * Applies a single modification to the given ValidationResult response.
         *
         * - Removes matching elements from all result arrays (passedNodes, failedNodes, etc.)
         * - If modification is "verdict", re-adds matching elements into the correct expected array.
         * - If modification is "ignore", simply removes without adding back.
         *
         * @param modification - The modification to apply.
         * @param response - A partial ValidationResult object to modify.
         */
        modifyResponse(modification, response) {
            const { selector, selectorMethod } = modification;
            for (const resultArray of this.resultArrays) {
                this.filterOutMatches(response[resultArray], selector, selectorMethod);
            }
            if (modification.type === "ignore") {
                return;
            }
            // The type is "verdict", so re-insert matching elements into the expected array
            const matches = selectorMethod ? selectorMethod(this.rootElement, selector) : Array.from(this.rootElement.querySelectorAll(selector));
            for (const element of matches) {
                if (!isSvgOrHtmlElement(element)) {
                    continue;
                }
                if (!response[modification.expected].includes(element)) {
                    // prevent duplications
                    response[modification.expected].push(element);
                }
            }
        }
        /**
         * Checks if a rule modification should be skipped.
         * if the rule is an "ignore" type and the selector is '*', it will be skipped.
         * @param ruleModification
         */
        shouldSkipRule(ruleModification) {
            return ruleModification.selector === "*" && ruleModification.type === "ignore";
        }
        /**
         * Filters out elements from the given array that match the selector,
         * or are included in the custom selector method results.
         *
         * Always fetches the matched elements first, and removes any elements in the array that are found in the matches.
         *
         * @param array - The array of elements to filter.
         * @param selector - The CSS selector to match against.
         * @param selectorMethod - Optional custom selector method to use instead of querySelectorAll.
         */
        filterOutMatches(array, selector, selectorMethod) {
            const matches = selectorMethod ? selectorMethod(this.rootElement, selector) : Array.from(this.rootElement.querySelectorAll(selector));
            const filtered = array.filter((node) => !matches.includes(node));
            array.length = 0; // Clear the original array
            array.push(...filtered); // Push in the filtered elements
        }
        /**
         * Validates a modification object to ensure it is well-formed and usable.
         *
         * - Checks type validity ("verdict" or "ignore").
         * - Ensures expected result is a valid result array if type is "verdict".
         * - Verifies that the selector is valid.
         * - Verifies the custom selector method (if provided) is valid, callable, and returns an array.
         *
         * @param modification - The modification object to validate.
         * @returns True if valid, false otherwise.
         */
        validateModification(modification) {
            if (!modification)
                return false;
            if (modification.type !== "verdict" && modification.type !== "ignore") {
                console.error("Invalid modification type", modification);
                return false;
            }
            if (modification.type === "verdict" && !this.resultArrays.includes(modification.expected)) {
                console.error(`Invalid expected result '${modification.expected}'`);
                return false;
            }
            try {
                document.querySelector(modification.selector);
            }
            catch (e) {
                console.error(`Invalid selector '${modification.selector}'`);
                return false;
            }
            if (modification.selectorMethod) {
                try {
                    if (typeof modification.selectorMethod !== "function") {
                        console.error("Invalid selector method provided - not a function");
                        return false;
                    }
                    const result = modification.selectorMethod(this.rootElement, modification.selector);
                    if (!Array.isArray(result)) {
                        console.error("Invalid selector method result - return value is not an array");
                        return false;
                    }
                }
                catch (e) {
                    console.error("Invalid selector method", e);
                    return false;
                }
            }
            return true;
        }
    }

    const RegionMainContent = {
        id: "region-main-content",
        metadata: {
            category: "Landmarks",
            profile: ["Blind"],
            wcagVersion: "2.0",
            wcagLevel: "A",
        },
        impact: "serious",
        title: "Each web page that uses landmark regions should have a main landmark",
        description: "A main landmark (e.g., <main>) lets screen reader users quickly skip past repeated elements and jump straight to the primary content, improving navigation and orientation.",
        advice: 'Enclose all of the primary content on the page in either a <main> element or any container with role="main".',
        associatedDetectors: [CompliantComponentMainContent],
        refs: [
            {
                type: "WCAG",
                id: "1.3.1",
                link: "https://www.w3.org/WAI/WCAG22/Understanding/info-and-relationships.html",
                level: "A",
            },
            {
                type: "WCAG Technique",
                link: "https://www.w3.org/TR/wai-aria-1.2/#main",
            },
            {
                type: "W3C",
                link: "https://www.w3.org/TR/html-main-element/",
            },
            {
                type: "WAI",
                link: "https://w3.org/WAI/ARIA/apg/patterns/landmarks/examples/main.html",
            },
        ],
        passCondition: PassCondition.PassedNodesAndNoFailedNodes,
        async validate({ response, classifier }) {
            const elements = classifier.getMatched([CompliantComponentMainContent]);
            /**
             * The case of "more than one main content region" is being handled by a separate rule - main-content-single.
             * This rule is only concerned with the case of "no main content region".
             */
            if (elements[0]) {
                response.passedNodes.push(elements[0]);
            }
        },
    };

    const RegionMainContentSingle = {
        id: "region-main-content-single",
        metadata: {
            category: "Landmarks",
            profile: ["Blind"],
            wcagVersion: "2.0",
            wcagLevel: "A",
        },
        impact: "serious",
        title: "Each page should include at most one main landmark",
        description: "A page typically presents one central subject, so a single main landmark establishes the boundaries of the primary content for screen reader users. Multiple main landmarks create uncertainty about the scope, leading to confusion and difficulty navigating the page.",
        advice: 'Keep only the true primary area as <main> or role="main", and change others to suitable elements—such as <section>, <nav>, or a neutral <div>. In modular or single-page apps, only the active view should expose a main landmark; remove the role or unmount inactive modules, or hide them with hidden or display:none.',
        associatedDetectors: [CompliantComponentMainContent],
        refs: [
            {
                type: "WCAG",
                id: "1.3.1",
                link: "https://www.w3.org/WAI/WCAG22/Understanding/info-and-relationships.html",
                level: "A",
            },
            {
                type: "WCAG Technique",
                link: "https://www.w3.org/TR/wai-aria-1.2/#main",
            },
            {
                type: "WAI",
                link: "https://w3.org/WAI/ARIA/apg/patterns/landmarks/examples/main.html",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ response, classifier }) {
            const elements = classifier.getMatched([CompliantComponentMainContent]);
            /**
             * The case of "no main content elements" is being handled by a separate rule, which will validate there is a main content region.
             * main-content-single rule validates there are no more than one main content region.
             * If there is no main content region, this rule should not fail.
             */
            if (elements.length > 1) {
                response.failedNodes.push(...elements.slice(1));
            }
        },
    };

    const SVGDiscernible = {
        id: "svg-discernible",
        metadata: {
            category: "General",
            profile: ["Cognitive Disability"],
            wcagVersion: "2.0",
            wcagLevel: "A",
        },
        impact: "critical",
        title: "SVG discernible",
        description: "All SVGs that are not used in the context of button icons must have discernible text.",
        advice: "Add a text alternative to the SVG.",
        associatedDetectors: [PerceivableTraitDiscernibleText, CompliantComponentButton, CompliantComponentLink, CompliantTraitExposed],
        refs: [
            {
                type: "WCAG",
                id: "1.1.1",
                level: "A",
                link: "https://www.w3.org/WAI/WCAG22/quickref/?versions=2.0#non-text-content",
            },
            {
                type: "WAI",
                link: "https://design-system.w3.org/styles/svg-icons.html#svg-accessibility",
            },
            {
                type: "ACT",
                ruleId: "7d6734",
                link: "https://act-rules.github.io/rules/7d6734",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ classifier, response, document }) {
            //TODO: make everything receive SVGElements
            const svgs = document.querySelectorAll("svg");
            for (const svg of svgs) {
                const isExposed = classifier.assert(svg, CompliantTraitExposed);
                const isPerceivableTraitVisible = classifier.assert(svg, PerceivableTraitVisible);
                const isCompliantTraitDiscernibleText = classifier.assert(svg, PerceivableTraitDiscernibleText);
                if (!isPerceivableTraitVisible) {
                    continue;
                }
                /**
                 * If the SVG is a child of a button or link, it's likely an icon and doesn't need discernible text.
                 * Button/link discernible text is validated in the button/link discernible rules.
                 */
                if (classifier.getParent(svg, CompliantComponentLink) || classifier.getParent(svg, CompliantComponentButton)) {
                    continue;
                }
                if (isCompliantTraitDiscernibleText || !isExposed) {
                    response.passedNodes.push(svg);
                }
                else {
                    response.failedNodes.push(svg);
                }
            }
        },
    };

    const HeadingH1 = {
        id: "heading-h1",
        metadata: {
            category: "General",
            profile: ["Blind"],
            wcagVersion: "2.0",
            wcagLevel: "A",
        },
        impact: "serious",
        title: "Each page should have a main heading",
        description: "There should be one h1 heading element that defines the subject of the main content on the page.",
        advice: "Add a h1 element at the start of the main content on the page.",
        associatedDetectors: [],
        refs: [
            {
                type: "WCAG",
                id: "1.3.1",
                level: "A",
                link: "https://www.w3.org/WAI/WCAG22/Understanding/info-and-relationships.html",
            },
            {
                type: "WCAG Technique",
                link: "https://www.w3.org/TR/2008/REC-WCAG20-20081211/#content-structure-separation-programmatic",
            },
        ],
        passCondition: PassCondition.PassedNodesAndNoFailedNodes,
        async validate({ root, response }) {
            const H1Heading = root.querySelector(`h1:not([aria-level]), [role=heading][aria-level='1'], h1[aria-level='1'], h2[aria-level='1'], h3[aria-level='1'], h4[aria-level='1'], h5[aria-level='1'], h6[aria-level='1']`);
            if (H1Heading) {
                response.passedNodes.push(H1Heading);
            }
        },
    };

    const HeadingSingleH1 = {
        id: "heading-single-h1",
        metadata: {
            category: "General",
            profile: ["Blind"],
            wcagVersion: "2.0",
            wcagLevel: "A",
        },
        impact: "moderate",
        title: "A page should not have more than one main heading",
        description: "Each web page should have only one h1 element so that screen reader users can identify the main topic or purpose of the page. Multiple h1s can confuse users by suggesting there are multiple primary topics, disrupting navigation by headings and making it harder to understand the overall page structure.",
        advice: "Make sure that each web page has exactly one h1 element so that screen reader users can identify the main subject of the page.",
        associatedDetectors: [],
        refs: [
            {
                type: "WCAG",
                id: "1.3.1",
                level: "A",
                link: "https://www.w3.org/WAI/WCAG22/Understanding/info-and-relationships.html",
            },
            {
                type: "WCAG Technique",
                link: "https://www.w3.org/TR/2008/REC-WCAG20-20081211/#content-structure-separation-programmatic",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ response, root }) {
            const H1Headings = root.querySelectorAll("h1:not([aria-level='2'], [aria-level='3'], [aria-level='4'], [aria-level='5'], [aria-level='6']), [role=heading][aria-level='1']");
            if (H1Headings.length > 0) {
                response.passedNodes.push(Array.from(H1Headings)[0]);
                response.failedNodes.push(...Array.from(H1Headings).slice(1));
            }
        },
    };

    const HtmlLang = {
        id: "html-lang",
        metadata: {
            category: "Metadata",
            profile: ["Blind"],
            wcagVersion: "2.0",
            wcagLevel: "A",
        },
        impact: "serious",
        title: "Default page language should be defined",
        description: "Specifying a default page language ensures screen readers apply the correct pronunciation rules, voices, and braille output. Without it, screen readers may guess the language incorrectly, causing mispronunciations, confusion, and reduced comprehension for users.",
        advice: "Define the default language for the page by assigning a lang attribute to the <html> element.",
        associatedDetectors: [],
        refs: [
            {
                type: "WCAG",
                id: "3.1.1",
                level: "A",
                link: "https://www.w3.org/WAI/WCAG22/Understanding/language-of-page.html",
            },
            {
                type: "ACT",
                ruleId: "bf051a",
                link: "https://act-rules.github.io/rules/bf051a",
            },
            {
                type: "ACT",
                ruleId: "b5c3f8",
                link: "https://act-rules.github.io/rules/b5c3f8",
            },
            {
                type: "ACT",
                ruleId: "off6ek",
                link: "https://act-rules.github.io/rules/off6ek",
            },
        ],
        passCondition: PassCondition.PassedNodesAndNoFailedNodes,
        async validate({ response, document }) {
            if (document.documentElement.lang) {
                response.passedNodes.push(document.documentElement);
            }
            else {
                response.failedNodes.push(document.documentElement);
            }
        },
    };

    const HtmlLangValid = {
        id: "html-lang-valid",
        metadata: {
            category: "Metadata",
            profile: ["Blind"],
            wcagVersion: "General Guidelines",
            wcagLevel: "N/A",
        },
        impact: "serious",
        title: "HTML lang attribute should have a valid value",
        description: "Assigning a valid ISO language value to the <html> lang attribute ensures that screen readers use the correct pronunciation rules, browsers apply proper spell-checking and translation, and search engines index the content in the appropriate language.",
        advice: "Make sure that the lang attribute on the <html> element is assigned a valid ISO language code that matches the default language of the page.",
        associatedDetectors: [],
        refs: [
            {
                type: "ACT",
                ruleId: "bf051a",
                link: "https://act-rules.github.io/rules/bf051a",
            },
            {
                type: "Non-Standard",
                link: "https://en.wikipedia.org/wiki/IETF_language_tag",
            },
            {
                type: "ACT",
                ruleId: "off6ek",
                link: "https://act-rules.github.io/rules/off6ek",
            },
        ],
        passCondition: PassCondition.PassedNodesAndNoFailedNodes,
        async validate({ response, document }) {
            const langValue = document.documentElement.lang;
            if (!langValue) {
                response.inapplicableNodes.push(document.documentElement);
                return;
            }
            //BCP-47 language tag regex
            //eslint-disable-next-line security/detect-unsafe-regex
            const langRegex = /^([a-zA-Z]{2,3})(?:-([a-zA-Z]{4}))?(?:-([a-zA-Z]{2}|\d{3}))?(?:-([a-zA-Z\d]{5,8}|\d[a-zA-Z\d]{3}))?$/;
            if (langRegex.test(langValue)) {
                response.passedNodes.push(document.documentElement);
            }
            else {
                response.failedNodes.push(document.documentElement);
            }
        },
    };

    const LinkNavigationDiscernible = {
        id: "link-navigation-discernible",
        metadata: {
            category: "Interactive Content",
            profile: ["Blind"],
            wcagVersion: "2.0",
            wcagLevel: "A",
        },
        impact: "critical",
        title: "Navigation links should have a descriptive label",
        description: "Activating navigation links enables users to navigate to a different page within the site. Links that do not contain visible text or labeled images should be assigned labels that inform screen reader users of their destination.",
        associatedDetectors: [PerceivableTraitDiscernibleText, PerceivableComponentLinkNavigation, CompliantTraitVisible],
        refs: [
            {
                type: "WCAG",
                id: "1.3.1",
                level: "A",
                link: "https://www.w3.org/WAI/WCAG22/Understanding/info-and-relationships.html",
            },
            {
                type: "WCAG",
                id: "4.1.2",
                level: "A",
                link: "https://www.w3.org/WAI/WCAG22/Understanding/name-role-value.html",
            },
            {
                type: "ACT",
                ruleId: "c487ae",
                link: "https://act-rules.github.io/rules/c487ae",
            },
        ],
        advice: "If a navigation link does not contain a labeled image or visible text, assign an aria-label that describes the destination of the link.",
        passCondition: PassCondition.NoFailedNodes,
        async validate({ response, classifier }) {
            const links = classifier.getMatched([PerceivableComponentLinkNavigation, CompliantTraitVisible]);
            for (const link of links) {
                if (classifier.assert(link, PerceivableTraitDiscernibleText)) {
                    response.passedNodes.push(link);
                }
                else {
                    response.failedNodes.push(link);
                }
            }
        },
    };

    const LinkAnchorDiscernible = {
        id: "link-anchor-discernible",
        metadata: {
            category: "Interactive Content",
            profile: ["Blind"],
            wcagVersion: "2.0",
            wcagLevel: "A",
        },
        impact: "critical",
        title: "Anchor links should have a descriptive label",
        description: "Activating anchor links enables users to navigate to a different section within the same page by scrolling and moving keyboard focus. Anchor links that do not contain visible text or labeled images should be assigned labels that inform screen reader users of their destination.",
        associatedDetectors: [PerceivableTraitDiscernibleText, PerceivableComponentLinkAnchor, CompliantTraitVisible],
        refs: [
            {
                type: "WCAG",
                id: "4.1.2",
                level: "A",
                link: "https://www.w3.org/WAI/WCAG22/Understanding/name-role-value.html",
            },
            {
                type: "WCAG",
                id: "1.3.1",
                level: "A",
                link: "https://www.w3.org/WAI/WCAG22/Understanding/info-and-relationships.html",
            },
            {
                type: "ACT",
                ruleId: "c487ae",
                link: "https://act-rules.github.io/rules/c487ae",
            },
        ],
        advice: "If an anchor link does not contain a labeled image or visible text, assign an aria-label that describes the destination of the link.",
        passCondition: PassCondition.NoFailedNodes,
        async validate({ response, classifier }) {
            const links = classifier.getMatched([PerceivableComponentLinkAnchor, CompliantTraitVisible]);
            for (const link of links) {
                if (classifier.assert(link, PerceivableTraitDiscernibleText)) {
                    response.passedNodes.push(link);
                }
                else {
                    response.failedNodes.push(link);
                }
            }
        },
    };

    const LinkNewWindowWarning = {
        id: "link-new-window-warning",
        metadata: {
            category: "Interactive Content",
            profile: ["Blind"],
            wcagVersion: "General Guidelines",
            wcagLevel: "N/A",
        },
        impact: "minor",
        title: "Warning a user when a link triggers a new browser window is recommended",
        description: "It's good practice to warn users about the expected behavior when activating a link triggers a new window.",
        advice: "Add a visibly hidden text element that contains 'Opens new window'. Assign a unique id attribute to the element and add aria-describedby to the link, referencing the text element's id. Alternatively, nest a visibly hidden element that contains additional context inside of the link.",
        associatedDetectors: [CompliantComponentLink],
        refs: [],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ classifier, response }) {
            const links = classifier.getMatched([CompliantComponentLink]);
            for (const link of links) {
                const isTargetBlank = link.getAttribute("target") === "_blank";
                if (!isTargetBlank) {
                    continue;
                }
                const { contentInfo } = classifier.getOperations(link);
                const linkText = contentInfo.allText.toLowerCase();
                if (linkText && distExports.textContainsWords(linkText, ["new_window", "separate_window", "new_tab", "separate_tab"])) {
                    response.passedNodes.push(link);
                }
                else {
                    response.failedNodes.push(link);
                }
            }
        },
    };

    const PageMetaViewport = {
        id: "had-meta-viewport",
        metadata: {
            category: "Metadata",
            profile: ["Vision Impaired"],
            wcagVersion: "General Guidelines",
            wcagLevel: "N/A",
        },
        impact: "minor",
        title: "Page has a meta viewport",
        description: "Providing a meta viewport to control layout and scaling on mobile devices",
        advice: "Add a meta viewport to the page",
        associatedDetectors: [],
        refs: [
            {
                type: "W3C",
                link: "https://www.w3.org/TR/mobile-accessibility-mapping/#use-viewport-meta-tag-to-identify-visual-scale-properties",
            },
        ],
        passCondition: PassCondition.PassedNodesAndNoFailedNodes,
        async validate({ response, document }) {
            const metaViewport = document.querySelector("head > meta[name=viewport]");
            if (metaViewport) {
                response.passedNodes.push(metaViewport);
            }
        },
    };

    /**
     * Checks if the content of a meta viewport tag is valid.
     *
     * Validates the content by ensuring that:
     * - `user-scalable` is not set to `no`
     * - `maximum-scale` is not less than 2
     *
     * @param {string} content - The content attribute of the meta viewport tag.
     * @returns {boolean} - Returns true if the content is valid, otherwise false.
     */
    function isContentMetaViewportValid(content) {
        const pairs = content.split(",").map((pair) => pair.trim());
        for (const pair of pairs) {
            const [key, value] = pair.split("=").map((part) => part.trim());
            if (key === "user-scalable" && value === "no") {
                return false;
            }
            if (key === "maximum-scale" && Number(value) < 2) {
                return false;
            }
        }
        return true;
    }
    const PageMetaViewportValid = {
        id: "page-meta-viewport-valid",
        metadata: {
            category: "Metadata",
            profile: ["Vision Impaired"],
            wcagVersion: "2.0",
            wcagLevel: "AA",
        },
        impact: "critical",
        title: "Meta viewport should allow content scaling",
        description: "The meta viewport should allow scalability, typically with width=device-width, initial-scale=1, so text can be resized up to 200% without loss of functionality. Using user-scalable=no or maximum-scale=1 prevents users from enlarging content, making it difficult for people with low vision to read or interact.",
        advice: 'Set content="width=device-width, initial-scale=1" on the meta viewport element and avoid values like user-scalable=no or maximum-scale=1 to preserve zoom and text scaling.',
        associatedDetectors: [],
        refs: [
            {
                type: "WCAG",
                id: "2.4.11",
                level: "AA",
                link: "https://www.w3.org/WAI/WCAG22/Understanding/resize-text.html",
            },
            {
                type: "W3C",
                link: "https://www.w3.org/TR/mobile-accessibility-mapping/#use-viewport-meta-tag-to-identify-visual-scale-properties",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ response, document }) {
            const metaViewport = document.querySelector("meta[name=viewport]");
            const content = metaViewport ? metaViewport.getAttribute("content") : "";
            if (metaViewport) {
                if (content && isContentMetaViewportValid(content)) {
                    response.passedNodes.push(metaViewport);
                }
                else {
                    response.failedNodes.push(metaViewport);
                }
            }
        },
    };

    const PageTitle = {
        id: "page-title",
        metadata: {
            category: "Metadata",
            profile: ["Blind"],
            wcagVersion: "2.0",
            wcagLevel: "A",
        },
        impact: "serious",
        title: "Page should have a title",
        description: "A missing page title makes it difficult for screen reader users and sighted users with multiple tabs open to identify the page, reducing orientation and usability.",
        advice: "Make sure each page has a unique, descriptive <title> element inside the <head> that reflects the purpose of the page.",
        associatedDetectors: [],
        refs: [
            {
                type: "WCAG",
                id: "2.4.2",
                level: "A",
                link: "https://www.w3.org/WAI/WCAG22/Understanding/page-titled.html",
            },
            {
                type: "ACT",
                ruleId: "c4a8a4",
                link: "https://act-rules.github.io/rules/c4a8a4",
            },
        ],
        passCondition: PassCondition.PassedNodesAndNoFailedNodes,
        async validate({ response, document }) {
            const title = document.querySelector("head > title");
            if (title) {
                response.passedNodes.push(title);
            }
        },
    };

    const PageTitleValid = {
        id: "page-title-valid",
        metadata: {
            category: "Metadata",
            profile: ["Blind"],
            wcagVersion: "2.0",
            wcagLevel: "A",
        },
        impact: "moderate",
        title: "Page title should be descriptive",
        description: "Screen readers rely heavily on page titles to announce the purpose of a page. If titles aren’t descriptive, users with low or no vision may not understand the context until they start navigating the page.",
        advice: "Make sure the title element inside the <head> is unique and describes the purpose of the page.",
        associatedDetectors: [],
        refs: [
            {
                type: "WCAG",
                id: "2.4.2",
                level: "A",
                link: "https://www.w3.org/WAI/WCAG22/Understanding/page-titled.html",
            },
            {
                type: "ACT",
                ruleId: "2779a5",
                link: "https://act-rules.github.io/rules/2779a5",
            },
            {
                type: "ACT",
                ruleId: "c4a8a4",
                link: "https://act-rules.github.io/rules/c4a8a4",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ response, document }) {
            const title = document.querySelector("head > title");
            if (title) {
                const wordCount = countWords(title.textContent);
                if (wordCount > 1) {
                    response.passedNodes.push(title);
                }
                else {
                    response.failedNodes.push(title);
                }
            }
        },
    };
    /**
     * Count the number of words in a given input string while ignoring numbers.
     * @param input
     */
    function countWords(input) {
        const withoutNumbers = input.replace(/\d+/g, "");
        const normalized = withoutNumbers.replace(/\s+/g, " ").trim();
        const words = normalized.split(" ").filter((word) => word.length > 0);
        // Step 4: Return the word count
        return words.length;
    }

    const NoAutofocus = {
        id: "no-autofocus",
        metadata: {
            category: "Interactive Content",
            profile: ["Blind", "Motor Impaired"],
            wcagVersion: "2.0",
            wcagLevel: "A",
        },
        impact: "serious",
        title: "Avoid using autofocus",
        description: "Make sure that no element has an autofocus attribute.",
        advice: "Remove the autofocus attribute from the failing element.",
        associatedDetectors: [],
        refs: [
            {
                type: "WCAG",
                id: "2.4.3",
                level: "A",
                link: "https://www.w3.org/WAI/WCAG22/Understanding/focus-order.html",
            },
            {
                type: "WCAG",
                id: "1.3.2",
                level: "A",
                link: "https://www.w3.org/WAI/WCAG22/Understanding/meaningful-sequence.html",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ response, root }) {
            const candidates = root.querySelectorAll("[autofocus]");
            for (const candidate of candidates) {
                if (!(candidate instanceof HTMLElement)) {
                    continue;
                }
                response.failedNodes.push(candidate);
            }
        },
    };

    const MarqueeDeprecated = {
        id: "marquee-deprecated",
        metadata: {
            category: "General",
            profile: ["Cognitive Disability"],
            wcagVersion: "2.0",
            wcagLevel: "A",
        },
        impact: "minor",
        title: "<marquee> elements are deprecated",
        description: "<marquee> elements are obsolete and should not be used. They are not part of any HTML or WAI-ARIA specification. They are not responsive or supported by any browsers.",
        advice: "Remove the <marquee> element from the page. If you need to display scrolling text, use CSS animations or JavaScript to create a similar effect.",
        associatedDetectors: [],
        refs: [
            {
                type: "WCAG",
                id: "2.2.2",
                level: "A",
                link: "https://www.w3.org/WAI/WCAG22/Understanding/pause-stop-hide.html",
            },
            {
                type: "W3C",
                link: "https://developer.mozilla.org/en-US/docs/Web/HTML/Element/marquee",
            },
            {
                type: "W3C",
                link: "https://www.w3.org/TR/html52/obsolete.html#the-marquee-element",
            },
            {
                type: "ACT",
                ruleId: "efbfc7",
                link: "https://act-rules.github.io/rules/efbfc7",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ response, root }) {
            const marqueeElements = root.querySelectorAll("marquee");
            for (const marquee of marqueeElements) {
                response.failedNodes.push(marquee);
            }
        },
    };

    const HeadingLengthy = {
        id: "heading-lengthy",
        metadata: {
            category: "General",
            profile: ["Cognitive Disability"],
            wcagVersion: "General Guidelines",
            wcagLevel: "N/A",
        },
        impact: "serious",
        title: "Heading should be concise",
        description: "The main heading of the document should be concise and descriptive. It should not be too lengthy (less than 160 chars).",
        advice: "Add a <h1> element to define the main heading of the document.",
        associatedDetectors: [CompliantComponentHeading],
        refs: [
            {
                type: "ACT",
                ruleId: "047fe0",
                link: "https://act-rules.github.io/rules/047fe0",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ classifier, response }) {
            const headings = classifier.getMatched([CompliantComponentHeading]);
            for (const heading of headings) {
                const sanitizedText = heading.textContent.replace(/\s+/g, " ").trim();
                if (sanitizedText.length > 160) {
                    response.failedNodes.push(heading);
                }
                else {
                    response.passedNodes.push(heading);
                }
            }
        },
    };

    /**
     * Notes:
     * - Although the tabindex value greated than 0 is considered valid by the HTML specification, it is not recommended to use it. hence, consider it as a failure.
     */
    const TabindexValid = {
        id: "tabindex-valid",
        metadata: {
            category: "General",
            profile: ["Motor Impaired"],
            wcagVersion: "2.0",
            wcagLevel: "A",
        },
        impact: "serious",
        title: "The tabindex attribute should be assigned a valid value",
        description: "Invalid tabindex values are ignored by browsers, while positive values override the natural focus order. Applying the tabindex attribute incorrectly can break the expected navigation flow for keyboard users.",
        advice: 'Restrict use of tabindex values to "0" or "-1", avoiding positive numbers and invalid value types, such as letters or decimals.',
        associatedDetectors: [],
        refs: [
            {
                type: "WCAG",
                id: "2.1.1",
                level: "A",
                link: "https://www.w3.org/WAI/WCAG22/Understanding/keyboard.html",
            },
            {
                type: "W3C",
                link: "https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ response, root }) {
            const candidates = root.querySelectorAll("[tabindex]");
            for (const candidate of candidates) {
                if (!(candidate instanceof HTMLElement)) {
                    response.inapplicableNodes.push(candidate);
                    continue;
                }
                const value = candidate.getAttribute("tabindex");
                if (value) {
                    if (value === "0" || value === "-1") {
                        response.passedNodes.push(candidate);
                    }
                    else {
                        response.failedNodes.push(candidate);
                    }
                }
            }
        },
    };

    const ImageDiscernible = {
        id: "image-discernible",
        metadata: {
            category: "Graphics",
            profile: ["Blind"],
            wcagVersion: "2.0",
            wcagLevel: "A",
        },
        impact: "critical",
        title: "Functional images should have a text alternative",
        description: "Images require a text alternative when the image conveys meaningful content or serves a functional purpose. If the image is decorative, it must be hidden from assistive technology.",
        advice: 'If the image is meaningful, assign a text alternative with a description of the image content using the alt attribute for image elements, or aria-label for elements with role="img". If the image is decorative, provide an empty alt attribute for image elements, or role="presentation" for elements with role="img".',
        associatedDetectors: [PerceivableTraitDiscernibleText, CompliantComponentImage],
        refs: [
            {
                type: "WCAG",
                id: "1.1.1",
                level: "A",
                link: "https://www.w3.org/WAI/WCAG22/Understanding/non-text-content.html",
            },
            {
                type: "ACT",
                ruleId: "23a2a8",
                link: "https://act-rules.github.io/rules/23a2a8",
            },
            {
                type: "ACT",
                ruleId: "qt1vmo",
                link: "https://act-rules.github.io/rules/qt1vmo",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ classifier, response }) {
            const images = classifier.getMatched([CompliantComponentImage]);
            /**
             * Because the backend resource doesnt support base64, svg etc. this rule will always fail in these cases.
             * TODO:
             * - copy-paste from remediator/image-resource, need to be shared.
             * - we set these images as inapplicable nodes, this will need to change once the backend supports these resources.
             */
            const isIrelevantImage = (url) => url.match(/data:image\/.*;base64,/) || url.match(/data:image\/svg\+xml/) || url.match(/([<.])svg/) || url.match(/linear-gradient\(/);
            for (const image of images) {
                if (classifier.assert(image, PerceivableTraitDiscernibleText)) {
                    response.passedNodes.push(image);
                }
                else if (isIrelevantImage(image.getAttribute("src") || "")) {
                    response.inapplicableNodes.push(image);
                }
                else {
                    response.failedNodes.push(image);
                }
            }
        },
    };

    const LetterSpacingPositive = {
        id: "letter-spacing-positive",
        metadata: {
            category: "General",
            profile: ["Vision Impaired"],
            wcagVersion: "2.1",
            wcagLevel: "AA",
        },
        impact: "minor",
        title: "Letter spacing should scale to at least 0.12 times the font size without loss of content or functionality",
        description: "When letter spacing is increased to 0.12 times the font size, text may be clipped, overlap, or overflow its container if styles like fixed widths, fixed heights, hidden overflow, or forced no-wrap prevent proper reflow.",
        advice: "Use flexible heights and widths, position elements in ways that allow text reflow, enable text wrapping, and avoid hidden overflow to ensure text remains readable when letter spacing is scaled to 0.12 times the font size.",
        associatedDetectors: [PerceivableTraitDirectText, PerceivableTraitVisible],
        refs: [
            {
                type: "WCAG",
                id: "1.4.12",
                level: "AA",
                link: "https://www.w3.org/WAI/WCAG22/Understanding/text-spacing.html",
            },
            {
                type: "ACT",
                ruleId: "24afc2",
                link: "https://act-rules.github.io/rules/24afc2",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ classifier, response }) {
            const candidates = classifier.getMatched([PerceivableTraitVisible, PerceivableTraitDirectText]);
            for (const candidate of candidates) {
                const { typographyInfo } = classifier.getOperations(candidate);
                if (typographyInfo.letterSpacing < -1) {
                    response.failedNodes.push(candidate);
                }
                else {
                    response.passedNodes.push(candidate);
                }
            }
        },
    };

    const IframeDiscernible = {
        id: "iframe-discernible",
        metadata: {
            category: "General",
            profile: ["Blind"],
            wcagVersion: "2.0",
            wcagLevel: "A",
        },
        impact: "critical",
        title: "Iframes should have a descriptive label",
        description: "An iframe needs a label that describes its purpose to screen reader users.",
        advice: "Assign an aria-label to the iframe element.",
        associatedDetectors: [CompliantComponentIframe, PerceivableTraitDiscernibleText],
        refs: [
            {
                type: "WCAG",
                id: "4.1.2",
                level: "A",
                link: "https://www.w3.org/WAI/WCAG22/Understanding/name-role-value.html",
            },
            {
                type: "ACT",
                ruleId: "cae760",
                link: "https://act-rules.github.io/rules/cae760",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ classifier, response }) {
            const iframes = classifier.getMatched([CompliantComponentIframe]);
            for (const iframe of iframes) {
                if (classifier.assert(iframe, PerceivableTraitDiscernibleText)) {
                    response.passedNodes.push(iframe);
                }
                else {
                    response.failedNodes.push(iframe);
                }
            }
        },
    };

    const ButtonMismatch = {
        id: "button-mismatch",
        metadata: {
            category: "Interactive Content",
            profile: ["Blind"],
            wcagVersion: "2.0",
            wcagLevel: "A",
        },
        impact: "critical",
        title: "Buttons should be tagged for assistive technology",
        description: "If interactive elements cannot be identified as buttons, screen reader users may not realize the element is actionable, which can stop them from submitting forms, opening dialogs, or performing other intended actions.",
        advice: 'Add role="button" to the custom interactive element, or use a HTML <button> element.',
        associatedDetectors: [PerceivableComponentButton, CompliantComponentButton, CompliantTraitVisible, CompliantComponentMenuItem, CompliantComponentTab, CompliantComponentSwitch],
        refs: [
            {
                type: "WCAG",
                id: "1.3.1",
                level: "A",
                link: "https://www.w3.org/WAI/WCAG22/Understanding/info-and-relationships.html",
            },
            {
                type: "WCAG",
                id: "4.1.2",
                level: "A",
                link: "https://www.w3.org/WAI/WCAG22/Understanding/name-role-value.html",
            },
            {
                type: "ACT",
                ruleId: "97a4e1",
                link: "https://act-rules.github.io/rules/97a4e1",
            },
            {
                type: "ACT",
                ruleId: "59796f",
                link: "https://act-rules.github.io/rules/59796f",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ classifier, response }) {
            const buttons = classifier.getMatched([PerceivableComponentButton, CompliantTraitVisible]);
            for (const button of buttons) {
                /**
                 * If the perceived button is a heading then it does not need to be tagged as a button but as interactable (InteractiveNotTabbable).
                 */
                if (classifier.assert(button, CompliantComponentHeading)) {
                    continue;
                }
                const isCompliantButtonSubtype = classifier.assert(button, CompliantComponentMenuItem) || classifier.assert(button, CompliantComponentTab) || classifier.assert(button, CompliantComponentSwitch);
                if (isCompliantButtonSubtype) {
                    continue;
                }
                const isValid = classifier.assert(button, CompliantComponentButton);
                if (isValid) {
                    response.passedNodes.push(button);
                }
                else {
                    response.failedNodes.push(button);
                }
            }
        },
    };

    const FontSizes = {
        id: "font-sizes",
        metadata: {
            category: "General",
            profile: ["Vision Impaired"],
            wcagVersion: "2.0",
            wcagLevel: "AA",
        },
        impact: "minor",
        title: "Text should be scalable to 200% without loss of content or functionality",
        description: "When text is scaled to 200%, content may be clipped, overlap, or overflow its container if styles like fixed heights, fixed widths, hidden overflow, or absolute positioning prevent proper reflow.",
        advice: "Use flexible heights and widths, position elements in ways that allow text reflow, enable text wrapping, and avoid hidden overflow to ensure content remains readable when text is scaled to 200%.",
        associatedDetectors: [PerceivableTraitVisible, PerceivableTraitDirectText, CompliantComponentSuperscript, PerceivableComponentSuperscript, CompliantComponentSubscript, PerceivableComponentSubscript],
        refs: [
            {
                type: "WCAG",
                id: "2.4.11",
                level: "AA",
                link: "https://www.w3.org/WAI/WCAG22/Understanding/resize-text.html",
            },
            {
                type: "Non-Standard",
                link: "https://www.section508.gov/develop/fonts-typography/",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ response, classifier }) {
            const elements = classifier.getMatched([PerceivableTraitVisible, PerceivableTraitDirectText]);
            /** TODO: When something like getMatchedAny() is available, replace this spread with that method */
            const subscriptAndSuperscriptElements = new Set([...classifier.getMatched([CompliantComponentSuperscript]), ...classifier.getMatched([PerceivableComponentSuperscript]), ...classifier.getMatched([CompliantComponentSubscript]), ...classifier.getMatched([PerceivableComponentSubscript])]);
            for (const element of elements) {
                /*
                  Superscript and subscript elements (for example <sup>®</sup>) are valid semantic HTML and are
                  expected to render smaller by design. WCAG does not require a minimum font size for <sup> or
                  <sub> content, as long as text scales with zoom.
          
                  Flagging these as “too small” is a false positive and remediating them can override
                  intentional typography. So we exempt <sup> and <sub> from font size checks.
                */
                if (subscriptAndSuperscriptElements.has(element)) {
                    response.passedNodes.push(element);
                    continue;
                }
                const { typographyInfo: { fontSize }, } = classifier.getOperations(element);
                /**
                 * History about font-size <= 1:
                 * Original code contained a check for font-size <= 1 as well.
                 * After researching, we found there are cases where font size is 1px, and then developers use em as 1px = 1em (so that for 16px they would use 16em).
                 * This is bad practice on the developers side, but doesn't break the rule.
                 * TODO: Consider creating another rule for the font-sizes unit. It is recommended to use rem/em for font-sizes for easier scaling.
                 */
                if (fontSize > 11) {
                    response.passedNodes.push(element);
                }
                else {
                    response.failedNodes.push(element);
                }
            }
        },
    };

    const NoRoleApplication = {
        id: "no-role-application",
        metadata: {
            category: "General",
            profile: ["Blind"],
            wcagVersion: "2.0",
            wcagLevel: "A",
        },
        impact: "critical",
        title: 'Avoid using role="application"',
        description: 'Using role="application" is generally discouraged because it disables standard screen reader modes and forces users into an application mode. This removes familiar navigation shortcuts, such as heading or landmark navigation, and requires them to interact in ways they may not expect.',
        advice: 'Remove role="application" from the failing element.',
        associatedDetectors: [],
        refs: [
            {
                type: "WCAG",
                id: "1.3.1",
                level: "A",
                link: "https://www.w3.org/WAI/WCAG22/Understanding/info-and-relationships.html",
            },
            {
                type: "Non-Standard",
                link: "https://stackoverflow.com/a/61693580",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ response, document }) {
            response.failedNodes = Array.from(document.querySelectorAll("[role=application]"));
        },
    };

    const CaptchaAccessibleProvider_v2_2 = {
        id: "captcha-accessible-provider-v2.2",
        metadata: {
            category: "General",
            profile: ["Cognitive Disability"],
            wcagVersion: "2.2",
            wcagLevel: "AA",
        },
        impact: "critical",
        title: "CAPTCHA used in authentication should not involve cognitive function tests",
        description: "With the exception of challenges that require recognition of  objects that are generally familiar to users, CAPTCHA used during authentication should not require users to perform cognitive function tests, such as recalling site-specific passwords or solving a puzzle.",
        advice: "Provide an alternative authentication method that avoids cognitive tasks, such as a two-factor verification step. If CAPTCHA is required, use services that offer strong accessibility support, such as Google reCAPTCHA v3.",
        associatedDetectors: [PerceivableComponentCaptcha],
        refs: [
            {
                type: "WCAG",
                id: "3.3.8",
                level: "AA",
                link: "https://www.w3.org/WAI/WCAG22/Understanding/accessible-authentication-minimum.html",
            },
            {
                type: "WCAG Technique",
                link: "https://www.w3.org/WAI/WCAG22/Techniques/general/G218",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ response, classifier }) {
            //TODO: Get type for accessibleCaptchaProviders from classifier
            const accessibleCaptchaProviders = ["recaptcha", "hCaptcha", "friendlyCaptcha"];
            const elements = classifier.getMatched([PerceivableComponentCaptcha]);
            for (const element of elements) {
                const { componentMatch } = classifier.getOperations(element);
                const elementType = componentMatch.element.type;
                if (!accessibleCaptchaProviders.includes(elementType)) {
                    response.failedNodes.push(element);
                }
                else {
                    response.passedNodes.push(element);
                }
            }
        },
    };

    const RequiredFormFieldAriaRequired = {
        id: "required-form-field-aria-required",
        metadata: {
            category: "Forms",
            profile: ["Blind"],
            wcagVersion: "2.0",
            wcagLevel: "A",
        },
        impact: "serious",
        title: "Mandatory form fields should indicate that they are required",
        description: 'If a field is marked as required only through visual cues, but lacks the required attribute or aria-required="true", screen readers will not announce it as mandatory. As a result, users may experience unnecessary delays or confusion when trying to submit the form.',
        advice: 'Add required or aria-required="true" to required input fields.',
        associatedDetectors: [PerceivableComponentFormFieldRequired],
        refs: [
            {
                type: "WCAG",
                id: "3.3.1",
                level: "A",
                link: "https://www.w3.org/WAI/WCAG22/Understanding/error-identification.html",
            },
            {
                type: "WCAG Technique",
                link: "https://www.w3.org/TR/WCAG20-TECHS/ARIA2.html",
            },
            {
                type: "WAI",
                link: "https://www.w3.org/WAI/tutorials/forms/validation/#validating-required-input",
            },
            {
                type: "Non-Standard",
                link: "https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-required",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ response, classifier }) {
            const elements = classifier.getMatched([PerceivableComponentFormFieldRequired, PerceivableTraitVisible]);
            for (const element of elements) {
                /**
                 * Skip hidden fields as they are not visible to the user or screen-reader and hence not required to be tagged as such.
                 */
                if (element instanceof HTMLInputElement && element.type === "hidden") {
                    continue;
                }
                /**
                 * In case of native elements, 'required' attribute is sufficient to indicate that the field is required
                 * and will be detected by screen readers.
                 */
                if (element instanceof HTMLSelectElement || element instanceof HTMLTextAreaElement || element instanceof HTMLInputElement) {
                    if (element.required) {
                        response.passedNodes.push(element);
                        continue;
                    }
                }
                /**
                 * For non-native elements, we need to check for 'aria-required=true'
                 */
                if (element.getAttribute("aria-required") !== "true") {
                    response.failedNodes.push(element);
                }
                else {
                    response.passedNodes.push(element);
                }
            }
        },
    };

    const AriaDescribedByHasReference = {
        id: "aria-describedby-has-reference",
        metadata: {
            category: "General",
            profile: ["Blind"],
            wcagVersion: "General Guidelines",
            wcagLevel: "N/A",
        },
        impact: "serious",
        title: "aria-describedby should reference a valid element id",
        description: "If an element’s aria-describedby attribute points to an id that does not exist or is not valid, assistive technologies will not convey the intended description, causing users to miss important context.",
        advice: "Ensure aria-describedby references an existing, unique id on the page. Remove or update the attribute if the target element is missing or no longer relevant.",
        associatedDetectors: [],
        refs: [
            {
                type: "WCAG Technique",
                link: "https://www.w3.org/WAI/WCAG22/Techniques/aria/ARIA1",
            },
            {
                type: "WCAG Technique",
                link: "https://www.w3.org/WAI/WCAG22/Techniques/aria/ARIA16",
            },
            {
                type: "ACT",
                ruleId: "in6db8",
                link: "https://act-rules.github.io/rules/in6db8",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ response, document }) {
            const elements = document.querySelectorAll("[aria-describedby]");
            for (const element of elements) {
                const ariaDescribedBy = element.getAttribute("aria-describedby").replaceAll(/\s+/g, " ");
                const hasBrokenReference = ariaDescribedBy
                    .trim()
                    .split(" ")
                    .some((id) => !document.getElementById(id));
                if (hasBrokenReference) {
                    response.failedNodes.push(element);
                }
                else {
                    response.passedNodes.push(element);
                }
            }
        },
    };

    const AriaLabelledByHasReference = {
        id: "aria-labelledby-has-reference",
        metadata: {
            category: "General",
            profile: ["Blind"],
            wcagVersion: "General Guidelines",
            wcagLevel: "N/A",
        },
        impact: "serious",
        title: "aria-labelledby should reference a valid element id",
        description: "Since aria-labelledby relies on valid id references, screen readers can only announce the label if the target exists. If the id is missing or invalid, the label will not be conveyed, causing users to miss important context.",
        advice: "Ensure aria-labelledby references an existing, unique id on the page. Remove or update the attribute if the target element is missing or no longer relevant.",
        associatedDetectors: [],
        refs: [
            {
                type: "WCAG Technique",
                link: "https://www.w3.org/WAI/WCAG22/Techniques/aria/ARIA1",
            },
            {
                type: "WCAG Technique",
                link: "https://www.w3.org/WAI/WCAG22/Techniques/aria/ARIA16",
            },
            {
                type: "ACT",
                ruleId: "in6db8",
                link: "https://act-rules.github.io/rules/in6db8",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ response, document }) {
            const elements = document.querySelectorAll("[aria-labelledby]");
            for (const element of elements) {
                const ariaLabelledBy = element.getAttribute("aria-labelledby").replaceAll(/\s+/g, " ");
                const hasBrokenReference = ariaLabelledBy
                    .trim()
                    .split(" ")
                    .some((id) => !document.getElementById(id));
                if (hasBrokenReference) {
                    response.failedNodes.push(element);
                }
                else {
                    response.passedNodes.push(element);
                }
            }
        },
    };

    const ListItemWithinList = {
        id: "list-item-within-list",
        metadata: {
            category: "Lists",
            profile: ["Blind"],
            wcagVersion: "2.0",
            wcagLevel: "A",
        },
        impact: "serious",
        title: "List items should not exist outside of a list element",
        description: "When list items are not contained in a list element, screen readers will not announce them as list items, preventing users from understanding the content as part of a structured list.",
        advice: 'Enclose the list items in an <ol>, <ul>, or an element with role="list".',
        associatedDetectors: [CompliantComponentList, CompliantComponentListItem],
        refs: [
            {
                type: "WCAG",
                id: "1.3.1",
                level: "A",
                link: "https://www.w3.org/WAI/WCAG22/Understanding/info-and-relationships.html",
            },
            {
                type: "Non-Standard",
                link: "https://dequeuniversity.com/rules/axe/4.1/listitem",
            },
            {
                type: "WCAG Technique",
                link: "https://www.w3.org/WAI/WCAG21/Techniques/html/H48.html",
            },
            {
                type: "W3C",
                link: "https://www.w3.org/TR/html401/struct/lists.html",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ response, classifier }) {
            const listItems = classifier.getMatched([CompliantComponentListItem]);
            for (const listItem of listItems) {
                if (!classifier.getParent(listItem, CompliantComponentList)) {
                    response.failedNodes.push(listItem);
                }
                else {
                    response.passedNodes.push(listItem);
                }
            }
        },
    };

    const NoExtraInformationInTitle = {
        id: "no-extra-information-in-title",
        metadata: {
            category: "General",
            profile: ["Blind"],
            wcagVersion: "General Guidelines",
            wcagLevel: "N/A",
        },
        impact: "minor",
        title: "The title attribute should not be the only method used to provide information",
        description: "The title attribute is announced inconsistently across screen readers and browsers, making it unreliable for labeling interactive controls. Because many users may never hear the content, reliance on the attribute risks loss of information. Instead, it should be used to provide extra help text in addition to a valid label.",
        advice: "Make sure that the title attribute is not the only means of providing a label by assigning an aria-label or aria-labelledby attribute to the interactive control.",
        associatedDetectors: [CompliantTraitVisible],
        refs: [
            {
                type: "Non-Standard",
                link: "https://www.a11yproject.com/posts/title-attributes/",
            },
            {
                type: "Non-Standard",
                link: "https://www.tpgi.com/html5-accessibility-chops-title-attribute-use-and-abuse/",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ response, document, classifier }) {
            const elements = document.querySelectorAll("[title]");
            for (const element of elements) {
                if (!classifier.assert(element, CompliantTraitVisible)) {
                    response.inapplicableNodes.push(element);
                    continue;
                }
                const title = element.getAttribute("title").trim();
                const { contentInfo: { accessibleName }, } = classifier.getOperations(element);
                const titleInSrVisibleText = accessibleName.includes(title);
                if (titleInSrVisibleText) {
                    response.passedNodes.push(element);
                }
                else {
                    response.failedNodes.push(element);
                }
            }
        },
    };

    const FigureDiscernible = {
        id: "figure-discernible",
        metadata: {
            category: "General",
            profile: ["Cognitive Disability"],
            wcagVersion: "General Guidelines",
            wcagLevel: "N/A",
        },
        impact: "minor",
        title: "Figure elements should receive text description or lose figure role",
        description: "Figure elements are often incorrectly used to display images on the screen. Incorrectly using the figure tag, without providing a proper figcaption, adds unnecessary clutter to the screen reader user's experience.",
        advice: "Standard images should be coded regularly without having a figure parent element. The figure tag should only be used for images you wish to provide additional visual descriptions for, like the date and time a photo was taken or other metadata. To make a figure tag non-cluttering for screen-readers, add the role=presentation attribute to replace it with another element like DIV. Alternatively, if you did intend to use the figure tag, make sure to add a figcaption tag with the additional metadata",
        associatedDetectors: [CompliantComponentFigure, PerceivableTraitDiscernibleText],
        refs: [
            {
                type: "Non-Standard",
                link: "https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/figure_role",
            },
            {
                type: "Non-Standard",
                link: "https://www.tpgi.com/html5-accessibility-chops-the-figure-and-figcaption-elements/",
            },
            {
                type: "W3C",
                link: "https://www.w3.org/TR/2011/WD-html5-author-20110809/the-figure-element.html",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ response, classifier }) {
            const figures = classifier.getMatched([CompliantComponentFigure]);
            for (const figure of figures) {
                const isDiscernible = classifier.assert(figure, PerceivableTraitDiscernibleText);
                const hasDiscernible = classifier.getMatched([PerceivableTraitDiscernibleText], figure);
                if (isDiscernible || hasDiscernible.length) {
                    response.passedNodes.push(figure);
                }
                else {
                    response.failedNodes.push(figure);
                }
            }
        },
    };

    const VisibilityMisuse = {
        id: "visibility-misuse",
        metadata: {
            category: "General",
            profile: ["Blind"],
            wcagVersion: "2.0",
            wcagLevel: "A",
        },
        impact: "critical",
        title: "Visibly hidden content should not be exposed to assistive technology",
        description: "When elements are visually hidden but still exposed to assistive technology, screen reader users may encounter content that should not be available in the current interface. This can obscure the current state of the page and lead to confusion about what information or controls are available.",
        advice: 'Use aria-hidden="true" to remove elements from the accessibility tree when they should not be exposed to assistive technology. Consider using CSS techniques, such as display:none or visibility:hidden when the content should be hidden from all users.',
        associatedDetectors: [PerceivableTraitHidden, PerceivableTraitVisible, PerceivableTraitRenderable, CompliantTraitVisible, PerceivableTraitScreenReaderOnly, CompliantTraitInteractable, CompliantTraitExplicitlyHidden],
        refs: [
            {
                type: "WCAG",
                id: "1.3.2",
                level: "A",
                link: "https://www.w3.org/WAI/WCAG22/Understanding/meaningful-sequence.html",
            },
            {
                type: "Non-Standard",
                link: "https://guides.18f.gov/accessibility/hidden-content/#:~:text=Hiding%20content%20is%20very%20useful,can%20hide%20content%20from%20both.",
            },
            {
                type: "Non-Standard",
                link: "https://a11y-guidelines.orange.com/en/articles/accessible-hiding/",
            },
            {
                type: "Non-Standard",
                link: "https://www.tpgi.com/html5-accessibility-chops-hidden-and-aria-hidden/",
            },
            {
                type: "ACT",
                ruleId: "6cfa84",
                link: "https://act-rules.github.io/rules/6cfa84",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ response, classifier }) {
            const hiddenElements = classifier.getMatched([PerceivableTraitRenderable, PerceivableTraitHidden]);
            for (const hiddenElement of hiddenElements) {
                if (!classifier.assert(hiddenElement, CompliantTraitVisible)) {
                    response.passedNodes.push(hiddenElement);
                    continue;
                }
                // if the element or any of its ancestors or descendants are screen reader only, then it is inapplicable for this rule because it's purposfully hidden from sighted users but available to screen reader users
                if (classifier.getMatchedInclusive([PerceivableTraitScreenReaderOnly], hiddenElement).length > 0 || classifier.getParent(hiddenElement, PerceivableTraitScreenReaderOnly)) {
                    response.inapplicableNodes.push(hiddenElement);
                    continue;
                }
                // If the element has perceivable visible descendants, then we want to prevent it from being marked as failed because the remediation will hide visible descendants from screen readers
                if (classifier.getMatched([PerceivableTraitVisible], hiddenElement).length > 0) {
                    response.inapplicableNodes.push(hiddenElement);
                    continue;
                }
                if (isPartOfSrVisibleText(hiddenElement, classifier)) {
                    response.inapplicableNodes.push(hiddenElement);
                    continue;
                }
                if (classifier.getParent(hiddenElement, CompliantTraitExplicitlyHidden)) {
                    response.inapplicableNodes.push(hiddenElement);
                    continue;
                }
                const isNestedFailNode = response.failedNodes.some((node) => node.contains(hiddenElement));
                if (!isNestedFailNode) {
                    response.failedNodes.push(hiddenElement);
                }
            }
        },
    };
    /**
     * checks if the element is part of the accessible name of its interactable parent
     * e.g. alt attribute of an image inside a button
     */
    function isPartOfSrVisibleText(element, classifier) {
        const interactableParent = classifier.getParent(element, CompliantTraitInteractable);
        if (!interactableParent) {
            return false;
        }
        const hiddenElementSrVisibleText = classifier.getOperations(element).contentInfo.srVisibleText;
        const interactableParentSrVisibleText = classifier.getOperations(interactableParent).contentInfo.srVisibleText;
        return interactableParentSrVisibleText === hiddenElementSrVisibleText;
    }

    /**
     * Refactoring notes:
     * ------------------
     * The aflw version of this rule is using [data-aflw-group-table] to find nested tables.
     * This group-table includes role=tree and role=grid tables, which are not necessarily nested tables.
     * We still have to determine whether the above types should be included in this rule.
     *
     * Notes about the old code:
     * -------------------------
     *  1. The aflw rule does not test for role=grid or role=tree tables.
     *
     * References:
     * -----------
     * @see https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/tree_role
     * @see https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/grid_role
     * @see https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/table_role
     */
    const TableNotNested = {
        id: "table-not-nested",
        metadata: {
            category: "Tables",
            profile: ["Blind"],
            wcagVersion: "2.0",
            wcagLevel: "A",
        },
        impact: "serious",
        title: "Tables should not be nested",
        description: "Nested tables are often misinterpreted by screen readers, making it hard for users to follow the intended structure and meaning of the data.",
        advice: 'Avoid nesting tables. Use separate tables with clear headings, and if tables are used for layout, assign role="presentation" or role="none" to each table element.',
        associatedDetectors: [CompliantComponentTable],
        refs: [
            {
                type: "WCAG",
                id: "1.3.1",
                level: "A",
                link: "https://www.w3.org/WAI/WCAG22/Understanding/info-and-relationships.html",
            },
            {
                type: "Non-Standard",
                link: "https://developer.mozilla.org/en-US/docs/Learn/HTML/Tables/Advanced#nesting_tables",
            },
            {
                type: "WCAG Technique",
                link: "https://www.w3.org/TR/WCAG20-TECHS/F49.html",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ response, classifier }) {
            const tables = classifier.getMatched([CompliantComponentTable]);
            for (const table of tables) {
                if (classifier.getParent(table, CompliantComponentTable)) {
                    response.failedNodes.push(table);
                }
                else {
                    response.passedNodes.push(table);
                }
            }
        },
    };

    const TabbableNonInteractive = {
        id: "tabbable-non-interactive",
        metadata: {
            category: "General",
            profile: ["Motor Impaired"],
            wcagVersion: "2.0",
            wcagLevel: "A",
        },
        impact: "serious",
        title: "Non-interactive elements should not be keyboard navigable",
        description: "Allowing static content to receive keyboard focus creates unnecessary stops in the tab order, forcing users to tab through elements that provide no action and making keyboard navigation less intuitive.",
        advice: "Remove the tabindex attribute from the static element.",
        associatedDetectors: [PerceivableTraitTabbable, CompliantTraitInteractable],
        refs: [
            {
                type: "WCAG",
                id: "2.4.3",
                level: "A",
                link: "https://www.w3.org/WAI/WCAG22/Understanding/focus-order.html",
            },
            {
                type: "Non-Standard",
                link: "https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex#accessibility_concerns",
            },
            {
                type: "Non-Standard",
                link: "https://www.a11yproject.com/posts/how-to-use-the-tabindex-attribute/",
            },
            {
                type: "Non-Standard",
                link: "https://dequeuniversity.com/rules/axe/4.4/tabindex",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ response, classifier }) {
            const tabbables = classifier.getMatched([PerceivableTraitTabbable]);
            for (const tabbable of tabbables) {
                const isInteractable = classifier.assert(tabbable, CompliantTraitInteractable);
                if (!isInteractable) {
                    response.failedNodes.push(tabbable);
                }
                else {
                    response.passedNodes.push(tabbable);
                }
            }
        },
    };

    const InteractiveNotTabbable = {
        id: "interactive-not-tabbable",
        metadata: {
            category: "Interactive Content",
            profile: ["Motor Impaired"],
            wcagVersion: "2.0",
            wcagLevel: "A",
        },
        impact: "critical",
        title: "Interactive elements should be keyboard navigable",
        description: "Interactive elements should be keyboard navigable. If a custom interactive element is not keyboard navigable, keyboard users will not be able to interact with it.",
        advice: 'Add tabindex="0" to the custom interactive element.',
        associatedDetectors: [PerceivableTraitTabbable, CompliantTraitInteractable, PerceivableTraitClickable, PerceivableTraitVisible],
        refs: [
            { type: "WCAG", id: "2.1.1", level: "A", link: "https://www.w3.org/WAI/WCAG22/Understanding/keyboard.html" },
            {
                type: "Non-Standard",
                link: "https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex#accessibility_concerns",
            },
            {
                type: "Non-Standard",
                link: "https://www.a11yproject.com/posts/how-to-use-the-tabindex-attribute/",
            },
            {
                type: "Non-Standard",
                link: "https://dequeuniversity.com/rules/axe/4.4/tabindex",
            },
            {
                type: "ACT",
                ruleId: "46ca7f",
                link: "https://act-rules.github.io/rules/46ca7f",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ response, classifier }) {
            const interactables = new Set(classifier.getMatched([CompliantTraitInteractable]).concat(classifier.getMatched([PerceivableTraitClickable])));
            for (const interactable of interactables) {
                if (!classifier.assert(interactable, PerceivableTraitVisible)) {
                    response.inapplicableNodes.push(interactable);
                    continue;
                }
                // If an element has a clickable parent, it is considered inapplicable because
                // the parent likely handles the interaction, making the child redundant for accessibility purposes.
                const hasParentClickable = classifier.getParent(interactable, CompliantTraitInteractable) ?? classifier.getParent(interactable, PerceivableTraitClickable);
                if (hasParentClickable) {
                    response.inapplicableNodes.push(interactable);
                    continue;
                }
                const isTabbable = classifier.assert(interactable, PerceivableTraitTabbable);
                if (isTabbable) {
                    response.passedNodes.push(interactable);
                }
                else {
                    response.failedNodes.push(interactable);
                }
            }
        },
    };

    const VisibleTextPartOfAccessibleName = {
        id: "visible-text-part-of-accessible-name",
        metadata: {
            category: "ARIA",
            profile: ["Blind"],
            wcagVersion: "2.1",
            wcagLevel: "A",
        },
        impact: "critical",
        title: "Aria labels should not override or replace visible text",
        description: "Aria labels should describe elements that don't have proper text, like icons and field labels. It should not be used to override element texts. Screen reader users need to receive the exact text as visually on the screen, with more context if it is ambiguous. An exception applies to landmarks such as nav or other landmarks: here, ARIA labels can provide additional context or clarification.",
        advice: "Remove the aria-label. If you need to add context for screen reader users only because of the ambiguity of the text, use the screen-reader-only technique.",
        associatedDetectors: [PerceivableComponentIcon, CompliantComponentMenuItem, CompliantComponentSelectOption, CompliantComponentTab, CompliantComponentLink, CompliantComponentCheckbox, CompliantComponentRadioButton, CompliantComponentSwitch],
        refs: [
            {
                type: "WCAG",
                id: "2.5.3",
                level: "A",
                link: "https://www.w3.org/WAI/WCAG21/Understanding/label-in-name.html",
            },
            {
                type: "Non-Standard",
                link: "https://www.useragentman.com/enable/screen-reader-only-text.php",
            },
            {
                type: "ACT",
                ruleId: "2ee8b8",
                link: "https://act-rules.github.io/rules/2ee8b8",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ response, classifier }) {
            /**
             * This rule applies to elements with a widget role that support name from content.
             * This includes the following: button, checkbox, gridcell, link, menuitem, menuitemcheckbox, menuitemradio, option, radio, searchbox, switch, tab, treeitem - @see https://www.w3.org/WAI/standards-guidelines/act/rules/2ee8b8/proposed/#background
             *
             * TODO: instead of specifying each detector here and calling getMatched multiple times, create 2 new detectors and do `classifier.getMatched([CompliantTraitWidget, CompliantTraitNameFromContent])` instead.
             * @see https://www.w3.org/TR/wai-aria-1.1/#namefromcontent
             * @see https://www.w3.org/TR/wai-aria-1.2/#widget_roles
             */
            const elements = new Set([
                ...classifier.getMatched([CompliantComponentButton]),
                ...classifier.getMatched([CompliantComponentCheckbox]),
                ...classifier.getMatched([CompliantComponentTab]),
                ...classifier.getMatched([CompliantComponentLink]),
                ...classifier.getMatched([CompliantComponentMenuItem]),
                ...classifier.getMatched([CompliantComponentRadioButton]),
                ...classifier.getMatched([CompliantComponentSelectOption]),
                ...classifier.getMatched([CompliantComponentSwitch]),
                // TODO: missing the following detectors for this to fully work these detectors need to be implemented in classifier
                // ...classifier.getMatched([CompliantComponentSearchbox]),
                // ...classifier.getMatched([CompliantComponentMenuitemradio]),
                // ...classifier.getMatched([CompliantComponentMenuitemcheckbox]),
                // ...classifier.getMatched([CompliantComponentGridCell]),
                // ...classifier.getMatched([CompliantComponentTreeItem]),
            ]);
            for (const el of elements) {
                const { contentInfo: { visibleText: contentInfoVisibleText, labelText, ariaLabelText }, } = classifier.getOperations(el);
                /**
                 * elements that don't have visible text but can have associate labels such as inputs need to be taken into account
                 * NOTE: the associated labels logic wasn't extracted from WAI's guidelines but rather from IBM Equal Access Accessibility Checker
                 */
                const visibleText = contentInfoVisibleText || labelText;
                /**
                 * applicable only to elements with aria-label or aria-labelledby (not srVisibleText)
                 * @see https://www.w3.org/WAI/standards-guidelines/act/rules/2ee8b8/proposed/#applicability
                 */
                if (!visibleText || !ariaLabelText) {
                    response.inapplicableNodes.push(el);
                    continue;
                }
                /**
                 * if the visibleText is considered non-text content (https://www.w3.org/TR/WCAG22/#dfn-non-text-content) it shouldn't be contained within the ariaLabelText
                 * @see https://www.w3.org/WAI/standards-guidelines/act/rules/2ee8b8/proposed/#test-cases - Passed Example 5
                 *
                 * TODO: as of now, we don't have a way to detect non-text content, we have isTextAmbiguous, but it's not the same thing.
                 * non-text content means that it's not expressing anything in human language.
                 *
                 * other a11y testing libraries use vague huerstics to add this logic such as:
                 * - if the string is a single character (IBM equal access): @see https://github.com/IBMa/equal-access/blob/2f83430a4c6de6421b1b81792a18b0eede738274/accessibility-checker-engine/src/v4/rules/label_name_visible.ts#L169
                 * - if the string is either "X" or "I" it's considered an icon (QualWeb): @see https://github.com/qualweb/qualweb/blob/bfb12040382d390397875af0ddf3b58ed966d1cd/packages/act-rules/src/rules/QW-ACT-R30.ts#L37
                 *
                 */
                // if (classifier.validators.isTextAmbiguous(visibleText)) {
                //   response.passedNodes.push(el);
                //   continue;
                // }
                if (classifier.assert(el, PerceivableComponentIcon)) {
                    /**
                     * if the visibleText is rendered as a non-text content such as icon, it shouldn't be contained within the ariaLabelText
                     * @see https://www.w3.org/WAI/standards-guidelines/act/rules/2ee8b8/proposed/#test-cases - Passed Example 6
                     *
                     * related e2e test: @see file://./atomic-tests/pass/button-visible-text-is-rendered-as-icon.html
                     */
                    response.passedNodes.push(el);
                    continue;
                }
                if (ariaLabelText.toLowerCase().includes(visibleText.toLowerCase())) {
                    /**
                     * if ariaLabelText is longer than visibleText and contains most words from visibleText it should pass
                     */
                    response.passedNodes.push(el);
                }
                else {
                    response.failedNodes.push(el);
                }
            }
        },
    };

    const BreadcrumbsNav = {
        id: "breadcrumbs-in-nav",
        metadata: {
            category: "General",
            profile: ["Cognitive Disability"],
            wcagVersion: "2.0",
            wcagLevel: "A",
        },
        impact: "serious",
        title: "Breadcrumbs navigation should be tagged properly",
        description: "Breadcrumb navigation regions are essential for user orientation. If not appropriately tagged, screen reader users will not know that such an option exists on the page and will face more difficulties browsing around.",
        advice: "Add a role=navigation or code the breadcrumbs using the HTML NAV tag. This will indicate to screen readers that it is a navigation region. Lastly, add an aria-label=Breadcrumbs attribute so screen readers can announce that to users.",
        associatedDetectors: [CompliantComponentNavigation, PerceivableComponentBreadcrumb],
        refs: [
            {
                type: "WAI",
                link: "https://www.w3.org/WAI/ARIA/apg/patterns/breadcrumb/examples/breadcrumb/",
            },
            {
                type: "Non-Standard",
                link: "https://www.aditus.io/patterns/breadcrumbs/",
            },
            {
                type: "Non-Standard",
                link: "https://www.magentaa11y.com/checklist-web/breadcrumbs/",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ response, classifier }) {
            const breadcrumbs = classifier.getMatched([PerceivableComponentBreadcrumb]);
            for (const breadcrumb of breadcrumbs) {
                const isNav = classifier.assert(breadcrumb, CompliantComponentNavigation);
                const navParent = classifier.getParent(breadcrumb, CompliantComponentNavigation);
                if (!isNav && !navParent) {
                    response.failedNodes.push(breadcrumb);
                }
                else {
                    response.passedNodes.push(breadcrumb);
                }
            }
        },
    };

    const VisibilityMismatch = {
        id: "visibility-mismatch",
        metadata: {
            category: "General",
            profile: ["Blind"],
            wcagVersion: "2.0",
            wcagLevel: "A",
        },
        impact: "critical",
        title: "Visible content should not be hidden from assistive technology",
        description: 'If content remains visible on the screen but assigned aria-hidden="true", it will be excluded from the accessibility tree. As a result, screen reader users will not have access to the same information as sighted users.',
        advice: 'Remove aria-hidden="true" from visible elements. Make sure that the attribute is only used to hide redundant or inactive content.',
        associatedDetectors: [PerceivableTraitVisible, CompliantTraitVisible, PerceivableComponentGraphic, CompliantTraitExplicitlyHidden, PerceivableTraitDiscernibleText, PerceivableTraitTabbable],
        refs: [
            {
                type: "WCAG",
                id: "1.3.2",
                level: "A",
                link: "https://www.w3.org/WAI/WCAG22/Understanding/meaningful-sequence.html",
            },
            {
                type: "Non-Standard",
                link: "https://www.tpgi.com/html5-accessibility-chops-hidden-and-aria-hidden/",
            },
            {
                type: "ACT",
                ruleId: "6cfa84",
                link: "https://act-rules.github.io/rules/6cfa84",
            },
            {
                type: "ACT",
                ruleId: "e88epe",
                link: "https://act-rules.github.io/rules/e88epe",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ response, classifier }) {
            const elements = classifier.getMatched([PerceivableTraitVisible]);
            for (const element of elements) {
                if (classifier.assert(element, CompliantTraitVisible)) {
                    response.passedNodes.push(element);
                    continue;
                }
                const { visibilityInfo } = classifier.getOperations(element);
                if (!visibilityInfo.isExplicitlyHiddenFromScreenReader) {
                    response.inapplicableNodes.push(element);
                    continue;
                }
                /**
                 * if the element has a parent with discernible text, then it is likely that the aria-hidden attribute is being used to hide a decorative element within a interactive component
                 *
                 * related tests:
                 * - @see file://./atomic-tests/pass/aria-hidden-logo-labelled-by-parent.html
                 * - @see file://./atomic-tests/fail/aria-hidden-logo-labelled-by-parent-main.html
                 */
                const tabbableParent = classifier.getParent(element, PerceivableTraitTabbable);
                const parentHasContent = tabbableParent && classifier.assert(tabbableParent, PerceivableTraitDiscernibleText);
                if (parentHasContent) {
                    response.inapplicableNodes.push(element);
                    continue;
                }
                // If the element has no perceivable visible content, it should not be considered for visibility mismatch
                if (!hasVisibleContent(element, classifier)) {
                    response.inapplicableNodes.push(element);
                    continue;
                }
                response.failedNodes.push(element);
            }
            /**
             * Check for elements that are explicitly hidden but have visible descendants, they should also fail so we remove the aria-hidden attribute from them
             */
            const compliantHiddenElements = classifier.getMatched([CompliantTraitExplicitlyHidden]);
            for (const element of compliantHiddenElements) {
                /**
                 * If the element is already marked as failed, skip it to prevent duplicates
                 */
                if (response.failedNodes.includes(element)) {
                    continue;
                }
                const hasVisibleDescendants = classifier.getMatched([PerceivableTraitVisible], element).length > 0;
                if (hasVisibleDescendants) {
                    response.failedNodes.push(element);
                }
            }
        },
    };
    function hasVisibleContent(element, classifier) {
        const { contentInfo, colorInfo } = classifier.getOperations(element);
        const hasGraphicContent = classifier.assert(element, PerceivableComponentGraphic) || classifier.getMatched([PerceivableComponentGraphic], element).length > 0;
        if (hasGraphicContent) {
            return true;
        }
        const hasBackgroundImage = colorInfo.backgroundImage && colorInfo.backgroundImage !== "none";
        if (hasBackgroundImage) {
            return true;
        }
        const hasTextContent = contentInfo.hasVisibleText;
        if (hasTextContent) {
            return true;
        }
        return false;
    }

    const BreadcrumbsMismatch = {
        id: "breadcrumbs-mismatch",
        metadata: {
            category: "Landmarks",
            profile: ["Blind"],
            wcagVersion: "2.0",
            wcagLevel: "A",
        },
        impact: "serious",
        title: "Breadcrumb navigation region should have a label",
        description: 'A breadcrumb region presents a trail of links showing the user’s current page in relation to higher-level pages on a site. Without a label, it may be announced by screen reades simply as "navigation", making it hard to distinguish from other navigation regions on the page.',
        advice: 'Assign aria-label="Breadcrumbs" to the navigation landmark that contains the breadcrumb links.',
        associatedDetectors: [CompliantComponentBreadcrumb, PerceivableComponentBreadcrumb],
        refs: [
            {
                type: "WCAG",
                id: "1.3.1",
                level: "A",
                link: "https://www.w3.org/WAI/WCAG22/Understanding/info-and-relationships.html",
            },
            {
                type: "WAI",
                link: "https://www.w3.org/WAI/ARIA/apg/patterns/breadcrumb/examples/breadcrumb/",
            },
            {
                type: "Non-Standard",
                link: "https://www.aditus.io/patterns/breadcrumbs/",
            },
            {
                type: "Non-Standard",
                link: "https://www.magentaa11y.com/checklist-web/breadcrumbs/",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ response, classifier }) {
            const breadcrumbs = classifier.getMatched([PerceivableComponentBreadcrumb]);
            for (const breadcrumb of breadcrumbs) {
                const isLabeled = classifier.assert(breadcrumb, CompliantComponentBreadcrumb);
                const labeledParent = classifier.getParent(breadcrumb, CompliantComponentBreadcrumb);
                if (isLabeled || labeledParent) {
                    response.passedNodes.push(breadcrumb);
                }
                else {
                    response.failedNodes.push(breadcrumb);
                }
            }
        },
    };

    const SkipLinkExists = {
        id: "skip-link-exists",
        metadata: {
            category: "Landmarks",
            profile: ["Blind", "Motor Impaired"],
            wcagVersion: "2.0",
            wcagLevel: "A",
        },
        impact: "moderate",
        title: "Skip links are the preferred technique for bypassing repeated content",
        description: "Skip links let keyboard and screen reader users bypass repetitive navigation and jump directly to important sections such as main content, navigation, or footer. This improves efficiency, reduces keystrokes, and makes pages easier to use for those relying on assistive technology.",
        advice: 'Add skip links as the first focusable elements on the page, directing users to regions marked with unique ids and appropriate landmarks such as <main>, <nav>, or <footer>. Keep them visually hidden until focused so they don’t clutter the layout, but ensure they remain accessible to screen readers by avoiding aria-hidden="true" or CSS display:none.',
        associatedDetectors: [PerceivableComponentSkipLink],
        refs: [
            { type: "WCAG", id: "2.4.1", level: "A", link: "https://www.w3.org/WAI/WCAG22/Understanding/bypass-blocks.html" },
            {
                type: "Non-Standard",
                link: "https://dequeuniversity.com/rules/axe/4.7/skip-link",
            },
            {
                type: "Non-Standard",
                link: "https://a11y-101.com/development/skip-link",
            },
            {
                type: "WAI",
                link: "https://www.w3.org/WAI/WCAG22/Understanding/bypass-blocks.html",
            },
            {
                type: "W3C",
                link: "https://www.w3.org/WAI/test-evaluate/easy-checks/skip-link/",
            },
        ],
        passCondition: PassCondition.PassedNodesAndNoFailedNodes,
        async validate({ response, classifier }) {
            const skipLinks = classifier.getMatched([PerceivableComponentSkipLink]);
            if (skipLinks.length > 0) {
                response.passedNodes.push(...skipLinks);
            }
        },
    };

    /**
     * Aria labels should not be used on elements that have name-prohibited roles
     *
     * If an element has no text content and no accessibility role, the aria-label
     * attribute will not have any effect because the element is not recognized by
     * screen readers as needing an accessible name or description.
     *
     * @see https://www.w3.org/TR/wai-aria-1.3/#namefromprohibited
     * @see https://www.w3.org/TR/accname-1.2/#dfn-accessible-name
     * @see https://www.w3.org/TR/accname-1.2/#mapping_additional_nd_name
     * @see https://www.w3.org/WAI/ARIA/apg/practices/names-and-descriptions/#name_calculation
     */
    const NameProhibitedNoAriaLabel = {
        id: "name-prohibited-no-aria-label",
        metadata: {
            category: "General",
            profile: ["Blind"],
            wcagVersion: "General Guidelines",
            wcagLevel: "N/A",
        },
        impact: "serious",
        title: "aria-label should be used with compatible roles",
        description: "Using aria-label on elements that do not support the attribute can lead to the label being ignored, leaving users without the intended information.",
        advice: "Use a visually hidden element to provide the name or description instead of an aria-label.",
        associatedDetectors: [CompliantTraitNameProhibited, CompliantTraitVisible],
        refs: [
            {
                type: "W3C",
                link: "https://www.w3.org/TR/html-aria/#docconformance",
            },
            {
                type: "Non-Standard",
                link: "https://www.freecodecamp.org/news/web-accessibility-common-aria-mistakes-to-avoid/#:~:text=Example%20of%20misusing%20ARIA%20labels%3A&text=In%20the%20first%20code%20snippet,the%20text%20inside%20it%20already.",
            },
            {
                type: "Non-Standard",
                link: "https://www.tpgi.com/short-note-on-aria-label-aria-labelledby-and-aria-describedby/",
            },
            {
                type: "W3C",
                link: "https://www.w3.org/TR/wai-aria-1.2/#aria-label",
            },
            {
                type: "W3C",
                link: "https://www.w3.org/TR/using-aria/#practical-support-aria-label-aria-labelledby-and-aria-describedby",
            },
            {
                type: "Non-Standard",
                link: "https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-label",
            },
            {
                type: "ACT",
                ruleId: "5c01ea",
                link: "https://act-rules.github.io/rules/5c01ea",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ response, classifier }) {
            const elementsWithProhibitedNaming = classifier.getMatched([CompliantTraitNameProhibited]);
            for (const el of elementsWithProhibitedNaming) {
                const operations = classifier.getOperations(el);
                if (operations.contentInfo.ariaText && classifier.assert(el, CompliantTraitVisible)) {
                    response.failedNodes.push(el);
                }
                else {
                    response.passedNodes.push(el);
                }
            }
        },
    };

    const DialogModalMismatch = {
        id: "dialog-modal-mismatch",
        metadata: {
            category: "Interactive Content",
            profile: ["Blind"],
            wcagVersion: "2.0",
            wcagLevel: "A",
        },
        impact: "critical",
        title: "Modal dialogs should be tagged for assistive technology",
        description: "Content behind active modal dialogs should not be navigable, otherwise screen reader users may still encounter hidden or unrelated content, disrupting the intended workflow and making it harder to focus on the dialog’s purpose.",
        advice: 'Add aria-modal="true" alongside role="dialog" to indicate to screen readers that the dialog is modal and that content outside of it should be treated as inactive. Screen readers will recognize this and adjust their behavior to keep the user’s focus inside the dialog.',
        refs: [
            {
                type: "WCAG",
                id: "4.1.2",
                level: "A",
                link: "https://www.w3.org/WAI/WCAG22/Understanding/name-role-value.html",
            },
            {
                type: "Non-Standard",
                link: "https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dialog",
            },
            {
                type: "Non-Standard",
                link: "https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-modal",
            },
            {
                type: "WAI",
                link: "https://www.w3.org/WAI/ARIA/apg/patterns/dialog-modal/examples/dialog/",
            },
        ],
        associatedDetectors: [PerceivableComponentDialogModal, CompliantComponentDialogModal],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ response, classifier }) {
            const elements = classifier.getMatched([PerceivableComponentDialogModal]);
            for (const element of elements) {
                if (classifier.assert(element, CompliantComponentDialogModal)) {
                    response.passedNodes.push(element);
                }
                else {
                    response.failedNodes.push(element);
                }
            }
        },
    };

    const DialogModalFocus = {
        id: "dialog-modal-focus",
        metadata: {
            category: "Interactive Content",
            profile: ["Motor Impaired"],
            wcagVersion: "2.0",
            wcagLevel: "A",
        },
        impact: "critical",
        title: "Keyboard focus should move into and lock inside active dialogs",
        description: "Dialogs that appear on pages without receiving keyboard focus immediately on interaction often leave users navigating content behind the dialog and make it difficult or impossible for keyboard and screen reader users to access the dialog itself.",
        advice: 'When a dialog opens, use JavaScript to place keyboard focus on the first interactive element within the dialog. If static content, such as lists, tables, or paragraphs, appears before any interactive elements and it needs to be perceived in order to easily understand the content, tabindex="-1" can be added to a static element at the start of the content to initially focus that element.',
        refs: [
            {
                type: "WCAG",
                id: "2.4.3",
                level: "A",
                link: "https://www.w3.org/WAI/WCAG22/Understanding/focus-order.html",
            },
            {
                type: "WAI",
                link: "https://www.w3.org/WAI/ARIA/apg/patterns/dialog-modal/examples/dialog/",
            },
            {
                type: "W3C",
                link: "https://www.w3.org/TR/UNDERSTANDING-WCAG20/keyboard-operation-trapping.html",
            },
        ],
        associatedDetectors: [PerceivableComponentDialogModal, CompliantComponentDialogModal],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ response, classifier, document }) {
            const activeElement = document.activeElement;
            /**
             * We're looking for the activeElement somewhere in the dialog.
             * Combine matches for different dialog types (PerceivableComponentDialog and CompliantComponentDialog)
             */
            const dialogs = [...new Set(classifier.getMatched([PerceivableComponentDialogModal]).concat(classifier.getMatched([CompliantComponentDialogModal])))];
            const topElementsArray = [];
            // If there are multiple dialog matches, filter out nested dialogs and only keep top-level ones.
            if (dialogs.length > 1) {
                for (const element of dialogs) {
                    // Check if the current dialog is not contained by any other dialog, i.e., it's a top-level dialog.
                    if (dialogs.filter((el) => el !== element).every((el) => !el.contains(element))) {
                        topElementsArray.push(element);
                    }
                }
            }
            else {
                // If only one dialog is found, it's considered top-level, so we add it to the array.
                topElementsArray.push(...dialogs);
            }
            if (activeElement) {
                // For each top-level dialog, check if it contains the activeElement.
                for (const element of topElementsArray) {
                    if (element.contains(activeElement)) {
                        // If the active element is inside the dialog, mark it as passed.
                        response.passedNodes.push(element);
                    }
                    else {
                        // Otherwise, mark it as failed.
                        response.failedNodes.push(element);
                    }
                }
            }
        },
    };

    const NavigationMisuse = {
        id: "navigation-misuse",
        metadata: {
            category: "Landmarks",
            profile: ["Blind"],
            wcagVersion: "2.0",
            wcagLevel: "A",
        },
        associatedDetectors: [CompliantComponentNavigation, PerceivableComponentNavigation, PerceivableComponentBreadcrumb, PerceivableComponentMainNavigation],
        impact: "serious",
        title: "An element without navigation links is tagged as a navigation landmark",
        description: "Screen readers rely on accurate tagging and labeling to provide necessary context. If an element that does not contain navigation links is tagged as a navigation landmark, screen reader users may lose orientation and find the page's structure difficult to understand.",
        advice: 'Add role="presentation" to the incorrect <nav> element or remove role="navigation" if a different element is used.',
        refs: [
            {
                type: "WCAG",
                id: "1.3.1",
                level: "A",
                link: "https://www.w3.org/WAI/WCAG22/Understanding/info-and-relationships.html",
            },
            {
                type: "WAI",
                link: "https://www.w3.org/WAI/ARIA/apg/patterns/menubar/examples/menubar-navigation/",
            },
            {
                type: "WAI",
                link: "https://www.w3.org/WAI/ARIA/apg/patterns/treeview/examples/treeview-navigation/",
            },
            {
                type: "WAI",
                link: "https://www.w3.org/WAI/ARIA/apg/patterns/landmarks/examples/navigation.html",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ classifier, response }) {
            // Getting all compliant navigation elements (<nav> tag and [role=navigation] and whatever else is considered a nav compliant element)
            const elements = classifier.getMatched([CompliantComponentNavigation]);
            const mainNavigation = (await classifier.getMatched([PerceivableComponentMainNavigation]))[0];
            for (const element of elements) {
                const isElementPerceivedAsNavigation = classifier.assert(element, PerceivableComponentNavigation);
                if (!isElementPerceivedAsNavigation) {
                    if (classifier.assert(element, PerceivableComponentBreadcrumb) || (mainNavigation && mainNavigation.parentElement === element) || mainNavigation === element) {
                        // To avoid conflicts with the BreadcrumbsNav and MainNavigationMismatch rules, we will not mark it as failed
                        response.inapplicableNodes.push(element);
                    }
                    else {
                        response.failedNodes.push(element);
                    }
                }
                else {
                    response.passedNodes.push(element);
                }
            }
        },
    };

    const TableColumnHeader = {
        id: "table-column-header",
        metadata: {
            category: "Tables",
            profile: ["Blind"],
            wcagVersion: "2.0",
            wcagLevel: "A",
        },
        impact: "critical",
        title: "Table column headers should be tagged for assistive technology",
        description: "If a column header is not marked up with the correct role or scope, screen reader users cannot determine which header applies to each cell.",
        advice: 'Use <th scope="col"> or assign role="columnheader" when building custom tables. Make sure each data cell is programmatically associated with the correct header so relationships are clear to assistive technology.',
        associatedDetectors: [CompliantComponentTableColumnHeader, PerceivableComponentTableColumnHeader],
        refs: [
            {
                type: "WCAG",
                id: "1.3.1",
                level: "A",
                link: "https://www.w3.org/WAI/WCAG22/Understanding/info-and-relationships.html",
            },
            {
                type: "W3C",
                link: "https://www.w3.org/WAI/GL/wiki/Failure_of_Success_Criterion_1.3.1_for_not_correctly_marking_up_table_headers",
            },
            {
                type: "Non-Standard",
                link: "https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/columnheader_role",
            },
            {
                type: "ACT",
                ruleId: "d0f69e",
                link: "https://act-rules.github.io/rules/d0f69e",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ response, classifier }) {
            const elements = classifier.getMatched([PerceivableComponentTableColumnHeader]);
            for (const element of elements) {
                if (classifier.assert(element, CompliantComponentTableColumnHeader)) {
                    response.passedNodes.push(element);
                }
                else {
                    response.failedNodes.push(element);
                }
            }
        },
    };

    const TableRowHeader = {
        id: "table-row-header",
        metadata: {
            category: "Tables",
            profile: ["Blind"],
            wcagVersion: "2.0",
            wcagLevel: "A",
        },
        impact: "critical",
        title: "Table row headers should be tagged for assistive technology",
        description: "If a table row header is not marked up with the correct role or scope, screen reader users cannot determine which header applies to each cell.",
        advice: 'Use <th scope="row"> or assign role="rowheader" when building custom tables. Make sure each data cell is programmatically associated with the correct header so relationships are clear to assistive technology.',
        associatedDetectors: [CompliantComponentTableRowHeader, PerceivableComponentTableRowHeader],
        refs: [
            {
                type: "WCAG",
                id: "1.3.1",
                level: "A",
                link: "https://www.w3.org/WAI/WCAG22/Understanding/info-and-relationships.html",
            },
            {
                type: "W3C",
                link: "https://www.w3.org/WAI/GL/wiki/Failure_of_Success_Criterion_1.3.1_for_not_correctly_marking_up_table_headers",
            },
            {
                type: "Non-Standard",
                link: "https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/rowheader_Role",
            },
            {
                type: "ACT",
                ruleId: "d0f69e",
                link: "https://act-rules.github.io/rules/d0f69e",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ response, classifier }) {
            const elements = classifier.getMatched([PerceivableComponentTableRowHeader]);
            for (const element of elements) {
                if (classifier.assert(element, CompliantComponentTableRowHeader)) {
                    response.passedNodes.push(element);
                }
                else {
                    response.failedNodes.push(element);
                }
            }
        },
    };

    const LinkContext = {
        id: "link-context",
        metadata: {
            category: "General",
            profile: ["Cognitive Disability"],
            wcagVersion: "2.0",
            wcagLevel: "A",
        },
        impact: "serious",
        title: "Links should indicate their functionality and destination to assistive technology",
        description: "Visual cues on pages provide context to links or hint functionality to users with sight, even if the links aren't fully descriptive. Screen reader users need to know where a link will take them based on the anchor text without additional context.",
        advice: "Examples include links to the shopping cart, to the company's Facebook page, to the site's search page, or to other similar destinations. If the link's anchor text doesn't explicitly describe those destinations, add screen-reader only text describing the destination",
        associatedDetectors: [CompliantComponentLink],
        refs: [
            {
                type: "WCAG",
                id: "2.4.4",
                level: "A",
                link: "https://www.w3.org/WAI/WCAG21/quickref/?showtechniques=211#link-purpose-in-context",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ classifier, response }) {
            const elements = classifier.getMatched([CompliantComponentLink]);
            for (const element of elements) {
                const { contextInfo: { hasContextualText }, } = classifier.getOperations(element);
                // If both visible and related text do not have context, that means the link is not descriptive enough
                if (!hasContextualText) {
                    response.failedNodes.push(element);
                }
                else {
                    response.passedNodes.push(element);
                }
            }
        },
    };

    const LinkAnchorAmbiguous = {
        id: "link-anchor-ambiguous",
        metadata: {
            category: "General",
            profile: ["Cognitive Disability"],
            wcagVersion: "2.0",
            wcagLevel: "A",
        },
        impact: "serious",
        title: "Ambiguous links should have additional descriptions for screen readers.",
        description: 'Ambiguous links like "Learn More", "Shop Now" and "Start Here" are often used as a call to action. However, screen-reader users, while using link navigation, do not interact with content above or below the link and therefore don\'t have the same context as to what they will learn more about.',
        advice: "Add a screen-reader only text which gives additional context to the destination of the link. You can use the `aria-label` attribute to provide a description of the link's purpose.",
        associatedDetectors: [PerceivableComponentLinkAnchor],
        refs: [
            {
                type: "WCAG",
                id: "2.4.4",
                level: "A",
                link: "https://www.w3.org/WAI/WCAG21/quickref/?showtechniques=211#link-purpose-in-context",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ classifier, response }) {
            const links = classifier.getMatched([PerceivableComponentLinkAnchor]);
            for (const link of links) {
                const { contentInfo: { srVisibleText }, contextInfo: { isAmbiguous }, } = classifier.getOperations(link);
                if (!srVisibleText) {
                    response.inapplicableNodes.push(link);
                    continue;
                }
                if (isAmbiguous) {
                    response.failedNodes.push(link);
                }
                else {
                    response.passedNodes.push(link);
                }
            }
        },
    };

    const NavigationNotNested = {
        id: "navigation-not-nested",
        metadata: {
            category: "Landmarks",
            profile: ["Blind"],
            wcagVersion: "2.0",
            wcagLevel: "A",
        },
        impact: "moderate",
        title: "Avoid using nested navigation structure",
        description: "Complex navigation components can be difficult for screen readers to handle. This is especially true if submenus or other complex structures exist. Nesting navigation regions makes it harder for screen reader users to understand a page's structure and disrupts orientation.",
        advice: 'If the failing element is a custom navigation region, remove role="navigation". If the failing element is coded using a HTML <nav> tag, apply role="presentation" or a role that is suitable for the function of the element.',
        associatedDetectors: [CompliantComponentNavigation],
        refs: [
            {
                type: "WCAG",
                id: "1.3.1",
                level: "A",
                link: "https://www.w3.org/WAI/WCAG22/Understanding/info-and-relationships.html",
            },
            {
                type: "W3C",
                link: "https://www.w3.org/WAI/tutorials/menus/structure/",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ response, classifier }) {
            const navs = classifier.getMatched([CompliantComponentNavigation]);
            for (const nav of navs) {
                if (classifier.getParent(nav, CompliantComponentNavigation)) {
                    response.failedNodes.push(nav);
                }
                else {
                    response.passedNodes.push(nav);
                }
            }
        },
    };

    const MenuAvoid = {
        id: "menu-avoid",
        metadata: {
            category: "Interactive Content",
            profile: ["Blind"],
            wcagVersion: "2.0",
            wcagLevel: "A",
        },
        impact: "serious",
        title: 'Avoid using role="menu" for web navigation links',
        description: "In most cases, using role=menu on navigation elements within a web page can negatively impact screen reader users, especially those using JAWS. The attribute should be used for menu types that function like those found in desktop applications.",
        advice: 'Remove role="menu" from the failing element.',
        associatedDetectors: [CompliantComponentMenu],
        refs: [
            {
                type: "WCAG",
                id: "1.3.1",
                level: "A",
                link: "https://www.w3.org/WAI/WCAG22/Understanding/info-and-relationships.html",
            },
            {
                type: "W3C",
                link: "https://www.w3.org/WAI/tutorials/menus/structure/",
            },
            {
                type: "W3C",
                link: "https://www.w3.org/WAI/tutorials/menus/application-menus/",
            },
            {
                type: "W3C",
                link: "https://www.w3.org/WAI/ARIA/apg/patterns/menubar/",
            },
            {
                type: "Non-Standard",
                link: "https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/menu_role",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ response, classifier }) {
            response.failedNodes = classifier.getMatched([CompliantComponentMenu]);
        },
    };

    const MenuBarAvoid = {
        id: "menu-bar-avoid",
        metadata: {
            category: "Interactive Content",
            profile: ["Blind"],
            wcagVersion: "2.0",
            wcagLevel: "A",
        },
        impact: "serious",
        title: 'Avoid using role="menubar" for web navigation links',
        description: "In most cases, using role=menubar on navigation elements within a web page can negatively impact screen reader users, especially those using JAWS. The attribute should be used for menu types that function like those found in desktop applications.",
        advice: 'Remove role="menubar" from the failing element.',
        associatedDetectors: [CompliantComponentMenubar],
        refs: [
            {
                type: "WCAG",
                id: "1.3.1",
                level: "A",
                link: "https://www.w3.org/WAI/WCAG22/Understanding/info-and-relationships.html",
            },
            {
                type: "W3C",
                link: "https://www.w3.org/WAI/tutorials/menus/structure/",
            },
            {
                type: "W3C",
                link: "https://www.w3.org/WAI/tutorials/menus/application-menus/",
            },
            {
                type: "W3C",
                link: "https://www.w3.org/WAI/ARIA/apg/patterns/menubar/",
            },
            {
                type: "Non-Standard",
                link: "https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/menu_role",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ response, classifier }) {
            response.failedNodes = classifier.getMatched([CompliantComponentMenubar]);
        },
    };

    const MenuItemAvoid = {
        id: "menu-item-avoid",
        metadata: {
            category: "Interactive Content",
            profile: ["Blind"],
            wcagVersion: "2.0",
            wcagLevel: "A",
        },
        impact: "serious",
        title: 'Avoid using role="menuitem" for web navigation links',
        description: 'In most cases, using ARIA menu roles within a web page can negatively impact screen reader users, especially those using JAWS. role="menuitem" should be used for menu items in menu types that function like those found in desktop applications.',
        advice: 'Use standard lists with links and buttons (or custom buttons with role="button") and remove role="menuitem".',
        associatedDetectors: [CompliantComponentMenuItem],
        refs: [
            {
                type: "WCAG",
                id: "1.3.1",
                level: "A",
                link: "https://www.w3.org/WAI/WCAG22/Understanding/info-and-relationships.html",
            },
            {
                type: "WAI",
                link: "https://www.w3.org/WAI/tutorials/menus/structure/",
            },
            {
                type: "Non-Standard",
                link: "https://www.boia.org/blog/avoiding-common-mistakes-with-arias-menu-role",
            },
            {
                type: "Non-Standard",
                link: "https://adrianroselli.com/2017/10/dont-use-aria-menu-roles-for-site-nav.html",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ classifier, response }) {
            response.failedNodes = classifier.getMatched([CompliantComponentMenuItem]);
        },
    };

    const TableHeaders = {
        id: "table-headers",
        metadata: {
            category: "General",
            profile: ["Cognitive Disability"],
            wcagVersion: "2.0",
            wcagLevel: "A",
        },
        impact: "serious",
        title: "Tables should include table header tags",
        description: "Screen readers can't match columns and cells without properly coded table header tags (TH). Without table headers, screen readers won't announce the table's content properly to users, leaving them unable to consume information.",
        advice: "Add a THEAD element to indicate a table heading section, and include TH elements for every column, describing the purpose of that table column.",
        associatedDetectors: [CompliantComponentTable, CompliantComponentTableColumnHeader, CompliantComponentTableRowHeader],
        refs: [
            {
                type: "WCAG",
                id: "1.3.1",
                level: "A",
                link: "https://www.w3.org/WAI/WCAG21/quickref/?showtechniques=131#info-and-relationships",
            },
            {
                type: "WAI",
                link: "https://www.w3.org/WAI/tutorials/tables/",
            },
            {
                type: "Non-Standard",
                link: "https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/columnheader_role",
            },
            {
                type: "Non-Standard",
                link: "https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/rowheader_role",
            },
            {
                type: "ACT",
                ruleId: "d0f69e",
                link: "https://act-rules.github.io/rules/d0f69e",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ response, classifier }) {
            const tables = classifier.getMatched([CompliantComponentTable]);
            for (const table of tables) {
                const columnHeaders = classifier.getMatched([CompliantComponentTableColumnHeader], table);
                const rowHeaders = classifier.getMatched([CompliantComponentTableRowHeader], table);
                if (!columnHeaders.length && !rowHeaders.length) {
                    response.failedNodes.push(table);
                }
                else {
                    response.passedNodes.push(table);
                }
            }
        },
    };

    const FocusNoticeable = {
        id: "focus-noticeable",
        metadata: {
            category: "Interactive Content",
            profile: ["Motor Impaired"],
            wcagVersion: "2.2",
            wcagLevel: "AA",
        },
        isBackendOnly: true,
        impact: "serious",
        title: "Focused elements should not be obscured by a sticky header",
        description: "All focusable elements must have a visible focus indicator when they receive keyboard focus.",
        advice: "Add a CSS outline or other visual indicator to focusable elements to ensure the currently focused element can be visibly distinguished.",
        associatedDetectors: [PerceivableTraitTabbable],
        refs: [
            {
                type: "WCAG",
                id: "2.4.7",
                level: "AA",
                link: "https://www.w3.org/WAI/WCAG21/Understanding/focus-visible.html",
            },
            {
                type: "W3C",
                link: "https://www.w3.org/TR/WCAG21/#focus-visible",
            },
            {
                type: "ACT",
                ruleId: "oj04fd",
                link: "https://act-rules.github.io/rules/oj04fd",
            },
            {
                type: "ACT",
                ruleId: "80af7b",
                link: "https://act-rules.github.io/rules/80af7b",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ response, classifier }) {
            const focusableElements = classifier.getMatched([PerceivableTraitTabbable]);
            if (focusableElements.length === 0) {
                return;
            }
            const cachedActiveElement = document.activeElement;
            const cachedScroll = [window.scrollX, window.scrollY];
            let cleanupFunction = null;
            for (const element of focusableElements) {
                // TODO: Use improved operation after operations enhancement
                const { stateStyleInfo: { focusStyle, cleanup }, } = classifier.getOperations(element);
                if (!cleanupFunction) {
                    cleanupFunction = cleanup;
                }
                if (Object.keys(focusStyle).length === 0) {
                    response.failedNodes.push(element);
                }
                else {
                    response.passedNodes.push(element);
                }
            }
            // If provided, running the cleanup function to cleanup any side effects of the operation
            if (cleanupFunction) {
                cleanupFunction(cachedActiveElement, cachedScroll);
            }
        },
    };

    const NavigationItemLink = {
        id: "navigation-item-link",
        metadata: {
            category: "Lists",
            profile: ["Blind"],
            wcagVersion: "2.0",
            wcagLevel: "A",
        },
        impact: "serious",
        title: "List items in a navigation region should not be interactive",
        description: "Adding interactive behavior to <li> elements within a navigation list may prevent screen reader users from identifying the element as actionable, since <li> elements are announced as list items and expected to be static.",
        advice: "In order to maintain the semantic structure of the list, a properly formed <a> element should be nested inside the <li>.",
        associatedDetectors: [CompliantComponentNavigation, CompliantComponentListItem, CompliantComponentLink],
        refs: [
            {
                type: "WCAG",
                id: "1.3.1",
                level: "A",
                link: "https://www.w3.org/WAI/WCAG22/Understanding/info-and-relationships.html",
            },
            {
                type: "W3C",
                link: "https://www.w3.org/WAI/ARIA/apg/patterns/landmarks/examples/navigation.html",
            },
            {
                type: "W3C",
                link: "https://www.w3.org/WAI/ARIA/apg/patterns/treeview/examples/treeview-navigation/",
            },
            {
                type: "Non-Standard",
                link: "https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/navigation_role",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ response, classifier }) {
            const navigationElements = classifier.getMatched([CompliantComponentNavigation]);
            for (const navElement of navigationElements) {
                const innerListItems = classifier.getMatched([CompliantComponentListItem], navElement);
                for (const listItem of innerListItems) {
                    const hasLinkChild = classifier.getMatched([CompliantComponentLink], listItem).length > 0;
                    const { contentInfo } = classifier.getOperations(listItem);
                    const hasVisibleText = contentInfo.visibleText !== "";
                    if (!hasLinkChild && hasVisibleText) {
                        response.failedNodes.push(listItem);
                    }
                    else {
                        response.passedNodes.push(listItem);
                    }
                }
            }
        },
    };

    const NavigationSubmenuRegion = {
        id: "navigation-submenu-region",
        metadata: {
            category: "Landmarks",
            profile: ["Blind"],
            wcagVersion: "General Guidelines",
            wcagLevel: "N/A",
        },
        impact: "minor",
        title: "Tagging submenus is recommended",
        description: 'Complex menu structures often contain multiple groups of links that can feel like undifferentiated page content to screen reader users. Assigning role="region" with a label makes each submenu a distinct, named section, clarifying its relationship to the trigger and improving orientation.',
        advice: 'Assign role="region" to each menu panel so screen reader users can distinguish submenus from surrounding page content. Adding a label (e.g., with aria-labelledby) helps users quickly identify each panel within a complex menu structure.',
        associatedDetectors: [CompliantComponentNavigation, PerceivableComponentSubmenu],
        refs: [],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ response, classifier }) {
            const navs = classifier.getMatched([CompliantComponentNavigation]);
            for (const nav of navs) {
                const submenus = classifier.getMatched([PerceivableComponentSubmenu], nav);
                for (const submenu of submenus) {
                    if (submenu.getAttribute("role") === "region") {
                        response.passedNodes.push(submenu);
                        continue;
                    }
                    response.failedNodes.push(submenu);
                }
            }
        },
    };

    const UserRatingDiscernible = {
        id: "user-rating-discernible",
        metadata: {
            category: "Graphics",
            profile: ["Blind"],
            wcagVersion: "2.0",
            wcagLevel: "A",
        },
        impact: "serious",
        title: "User ratings should be tagged and labeled for assistive technology",
        description: "When a static star rating is presented using unlabeled icons, screen readers cannot interpret the symbols as meaningful content. Assigning a role and text alternative ensures the rating value is conveyed clearly, allowing non-visual users to understand the information.",
        advice: 'Assign role="img" with an aria-label, such as “4 out of 5 stars,” to the image element, or to an enclosing container if each star is presented as a separate element.',
        associatedDetectors: [PerceivableTraitDiscernibleText, PerceivableComponentUserRating],
        refs: [
            {
                type: "WCAG",
                id: "1.1.1",
                level: "A",
                link: "https://www.w3.org/WAI/WCAG22/Understanding/non-text-content.html",
            },
            {
                type: "WAI",
                link: "https://www.w3.org/WAI/ARIA/apg/patterns/radio/examples/radio-rating/",
            },
            {
                type: "WAI",
                link: "https://www.w3.org/WAI/tutorials/forms/custom-controls/",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ response, classifier }) {
            const elements = classifier.getMatched([PerceivableComponentUserRating]);
            for (const element of elements) {
                const discernibleElements = classifier.getMatchedInclusive([PerceivableTraitDiscernibleText], element);
                if (!discernibleElements.length) {
                    response.failedNodes.push(element);
                }
                else {
                    response.passedNodes.push(element);
                }
            }
        },
    };

    const SalePriceDiscernible = {
        id: "sale-price-discernible",
        metadata: {
            category: "General",
            profile: ["Blind"],
            wcagVersion: "2.0",
            wcagLevel: "A",
        },
        impact: "serious",
        title: "Original and discounted prices should be indicated to assistive technology",
        description: "Discounted prices often appear next to the original and distinguished with visual cues like strikethroughs or color changes. Both prices must also be conveyed by screen readers in a way that enables users to differentiate between the values, ensuring they can understand when a discount is applied.",
        advice: "Add visually hidden text that explicitly identifies each value as the original price or the discounted price.",
        associatedDetectors: [CompliantTraitCrossedOutText, PerceivableComponentSalePrice, PerceivableTraitCrossedOutText, PerceivableTraitScreenReaderOnly],
        refs: [
            {
                type: "WCAG",
                id: "1.3.1",
                level: "A",
                link: "https://www.w3.org/WAI/WCAG22/Understanding/info-and-relationships.html",
            },
            {
                type: "Non-Standard",
                link: "https://www.includia.com/blog/posts/strikethrough-accessibility",
            },
            {
                type: "Non-Standard",
                link: "https://www.webaxe.org/strikethrough-html-accessibility/",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ classifier, response }) {
            const priceElements = classifier.getMatched([PerceivableComponentSalePrice]);
            for (const priceElement of priceElements) {
                const isCrossedOut = classifier.assert(priceElement, PerceivableTraitCrossedOutText) || classifier.assert(priceElement, CompliantTraitCrossedOutText);
                if (isCrossedOut) {
                    if (someElementsImplySalePrice([priceElement], classifier)) {
                        response.passedNodes.push(priceElement);
                        continue;
                    }
                    const nestedSrOnly = classifier.getMatched([PerceivableTraitScreenReaderOnly], priceElement);
                    if (someElementsImplySalePrice(nestedSrOnly, classifier)) {
                        response.passedNodes.push(priceElement);
                        continue;
                    }
                    const siblingSrOnly = classifier.getMatched([PerceivableTraitScreenReaderOnly], priceElement.parentElement);
                    if (someElementsImplySalePrice(siblingSrOnly, classifier)) {
                        response.passedNodes.push(priceElement);
                        continue;
                    }
                    response.failedNodes.push(priceElement);
                }
            }
        },
    };
    const keywords = ["original_price", "was", "before", "old_price", "previously", "formerly", "reduced_from", "discounted_from", "was_originally", "last_sold_at", "marked_down_from", "sale_from", "originally_priced_at", "pre_sale_price", "previous_price", "used_to_be"];
    /**
     *  Check if the text implies a sale price by checking if the text contains any of the keywords in the dictionary
     * */
    function impliesSalePrice(text) {
        const lowerCaseText = text.toLowerCase();
        return keywords.some((keyword) => distExports.textContainsWord(lowerCaseText, keyword));
    }
    /**
     *  Check if any of the elements imply a sale price by checking if the text of the element contains any of the keywords in the dictionary
     * */
    function someElementsImplySalePrice(elements, classifier) {
        return elements.some((element) => {
            const srVisibleText = classifier.getOperations(element).contentInfo.srVisibleText;
            return impliesSalePrice(srVisibleText);
        });
    }

    const MenuTriggerCorrectState = {
        id: "menu-trigger-correct-state",
        metadata: {
            category: "Interactive Content",
            profile: ["Blind"],
            wcagVersion: "2.0",
            wcagLevel: "A",
        },
        impact: "critical",
        title: "Triggers that expand additional content should expose their state to assistive technology",
        description: "When components such as accordions or navigation menus do not expose their state, screen reader users may not realize that additional content can be revealed or know whether it is currently visible.",
        advice: "Assign aria-expanded to common triggers, such as <button> or custom select elements to indicate whether their associated content is collapsed (false) or expanded (true). Ensure the value is updated as the state changes.",
        associatedDetectors: [CompliantComponentMenuTrigger, PerceivableTraitVisible],
        refs: [
            {
                type: "WCAG",
                id: "4.1.2",
                level: "A",
                link: "https://www.w3.org/WAI/WCAG22/Understanding/name-role-value.html",
            },
            {
                type: "Non-Standard",
                link: "https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-expanded",
            },
            {
                type: "Non-Standard",
                link: "https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-haspopup",
            },
            {
                type: "Non-Standard",
                link: "https://dequeuniversity.com/rules/axe/4.3/aria-required-attr",
            },
            {
                type: "Non-Standard",
                link: "https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-controls",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ classifier, response, document }) {
            const elements = classifier.getMatched([CompliantComponentMenuTrigger]);
            for (const element of elements) {
                const ariaControls = element.getAttribute("aria-controls");
                /**
                 * We cannot determine the state of the related element if the aria-controls attribute is not present.
                 * Since aria-controls is not a required attribute for menu-triggers, we do not push this element to failed nodes
                 */
                if (!ariaControls) {
                    continue;
                }
                const connectedMenu = document.getElementById(ariaControls);
                /**
                 * The controlled element does not exist, so we cannot determine the state of the menu.
                 * If this is a failure, we should make this a separate rule, as remediation for this failure is different.
                 */
                if (!connectedMenu) {
                    continue;
                }
                const ariaExpanded = element.getAttribute("aria-expanded");
                const isAriaExpanded = ariaExpanded === "true";
                const isConnectedMenuVisible = classifier.assert(connectedMenu, PerceivableTraitVisible);
                // If the aria-expanded attribute reflects the visibility state of the connected menu correctly, the rule passes
                if (isAriaExpanded === isConnectedMenuVisible) {
                    response.passedNodes.push(element);
                }
                else {
                    response.failedNodes.push(element);
                }
            }
        },
    };

    const CarouselAriaLive = {
        id: "carousel-aria-live",
        metadata: {
            category: "Interactive Content",
            profile: ["Blind"],
            wcagVersion: "2.1",
            wcagLevel: "AA",
        },
        impact: "critical",
        title: "Carousels should not be tagged as live regions",
        description: "When carousels are tagged as live regions, screen readers will interrupt reading and announce every slide change, even when the user isn't interacting with the carousel or is in another section entirely.",
        advice: 'Remove the aria-live attribute and any live region roles, such as role="alert", from the carousel and its content.',
        associatedDetectors: [PerceivableComponentCarousel],
        refs: [
            {
                type: "WCAG",
                id: "4.1.3",
                level: "AA",
                link: "https://www.w3.org/WAI/WCAG22/Understanding/status-messages.html",
            },
            {
                type: "Non-Standard",
                link: "https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-live",
            },
            {
                type: "Non-Standard",
                link: "https://www.tpgi.com/screen-reader-support-aria-live-regions/",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ response, classifier }) {
            const carousels = classifier.getMatched([PerceivableComponentCarousel]);
            for (const carousel of carousels) {
                // includes the carousel itself and its children
                const selector = "[aria-live]";
                const elementsWithAriaLive = Array.from(carousel.querySelectorAll(selector));
                if (carousel.matches(selector)) {
                    elementsWithAriaLive.push(carousel);
                }
                for (const element of elementsWithAriaLive) {
                    const value = element.getAttribute("aria-live");
                    if (value === "" || value === "off") {
                        response.passedNodes.push(element);
                    }
                    else {
                        response.failedNodes.push(element);
                    }
                }
            }
        },
    };

    const SearchFormMismatch = {
        id: "search-form-mismatch",
        metadata: {
            category: "Landmarks",
            profile: ["Blind"],
            wcagVersion: "2.0",
            wcagLevel: "A",
        },
        impact: "moderate",
        title: "A search form should be tagged as a search landmark",
        description: "Screen reader users rely on landmarks to quickly access important regions of a page. Defining a form as a search landmark ensures that users can quickly recognize and navigate to the search form.",
        advice: 'Enclose the search form in a <search> element or assign role="search" to the <form> element.',
        associatedDetectors: [PerceivableComponentSearchForm, CompliantComponentSearch],
        refs: [
            {
                type: "WCAG",
                id: "1.3.1",
                level: "A",
                link: "https://www.w3.org/WAI/WCAG22/Understanding/info-and-relationships.html",
            },
            {
                type: "Non-Standard",
                link: "https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/search_role",
            },
            {
                type: "Non-Standard",
                link: "https://developer.mozilla.org/en-US/docs/Web/HTML/Element/search",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ response, classifier }) {
            const searchForms = classifier.getMatched([PerceivableComponentSearchForm]);
            for (const searchForm of searchForms) {
                const isCompliantSearch = classifier.assert(searchForm, CompliantComponentSearch);
                const compliantSearchParent = classifier.getParent(searchForm, CompliantComponentSearch);
                if (isCompliantSearch || compliantSearchParent) {
                    response.passedNodes.push(searchForm);
                }
                else {
                    response.failedNodes.push(searchForm);
                }
            }
        },
    };

    const IconDiscernible = {
        id: "icon-discernible",
        metadata: {
            category: "Graphics",
            profile: ["Blind"],
            wcagVersion: "2.0",
            wcagLevel: "A",
        },
        impact: "critical",
        title: "Meaningful icons should have a label, while decorative icons should be hidden",
        description: "Smaller graphics used as decorative or complementary elements, such as icons, and that do not provide additional information will often add unnecessary clutter to a screen reader user's browsing experience.",
        advice: 'If the image is meaningful, assign a text alternative with a description of the image content using the alt attribute for image elements, or aria-label for elements with role="img". If the image is decorative, provide an empty alt attribute for image elements, or role="presentation" for elements with role="img".',
        associatedDetectors: [CompliantTraitExposed, PerceivableComponentIcon, PerceivableTraitDiscernibleText],
        refs: [
            {
                type: "WCAG",
                id: "1.1.1",
                level: "A",
                link: "https://www.w3.org/WAI/WCAG22/Understanding/non-text-content.html",
            },
            {
                type: "ACT",
                ruleId: "46ca7f",
                link: "https://act-rules.github.io/rules/46ca7f",
            },
            {
                type: "ACT",
                ruleId: "e88epe",
                link: "https://act-rules.github.io/rules/e88epe",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ classifier, response }) {
            const icons = classifier.getMatched([PerceivableComponentIcon]);
            for (const icon of icons) {
                const isCompliantVisible = classifier.assert(icon, CompliantTraitExposed);
                const hasDiscernibleText = classifier.assert(icon, PerceivableTraitDiscernibleText);
                if (!isCompliantVisible || hasDiscernibleText) {
                    response.passedNodes.push(icon);
                }
                else {
                    response.failedNodes.push(icon);
                }
            }
        },
    };

    const ArticleMisuse = {
        id: "article-misuse",
        metadata: {
            category: "Landmarks",
            profile: ["Blind"],
            wcagVersion: "2.0",
            wcagLevel: "A",
        },
        impact: "minor",
        title: "Only elements that function as articles should be tagged as article regions",
        description: "Using an <article> tag on content that is not self-contained and that cannot stand on its own outside the context of the page, such as a blog post, news story, or forum entry, causes screen readers to announce misleading information about the purpose the content in relation to the main subject of the page.",
        advice: 'Assign role="presentation" to the failing element or use a different HTML tag that is more appropriate for the function of the element.',
        associatedDetectors: [CompliantComponentArticle, PerceivableComponentArticle],
        refs: [
            {
                type: "WCAG",
                id: "1.3.1",
                level: "A",
                link: "https://www.w3.org/WAI/WCAG22/Understanding/info-and-relationships.html",
            },
            {
                type: "WAI",
                link: "https://www.w3.org/WAI/ARIA/apg/patterns/feed/examples/feed/",
            },
            {
                type: "WCAG Technique",
                link: "https://www.w3.org/WAI/GL/wiki/Using_HTML5_article_element",
            },
            {
                type: "Non-Standard",
                link: "https://developer.mozilla.org/en-US/docs/Web/HTML/Element/article",
            },
            {
                type: "Non-Standard",
                link: "https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/article_role",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ classifier, response }) {
            const elements = classifier.getMatched([CompliantComponentArticle]);
            for (const element of elements) {
                const isPerceivableArticle = classifier.assert(element, PerceivableComponentArticle);
                if (!isPerceivableArticle) {
                    response.failedNodes.push(element);
                }
                else {
                    response.passedNodes.push(element);
                }
            }
        },
    };

    const BackgroundImageDiscernible = {
        id: "background-image-discernible",
        metadata: {
            category: "Graphics",
            profile: ["Blind"],
            wcagVersion: "2.0",
            wcagLevel: "A",
        },
        impact: "serious",
        title: "Functional image displayed using CSS background properties should have a text alternative",
        description: "Images require a text alternative when the image conveys meaningful content or serves a functional purpose. Rendering an image using CSS background or background-image properties is acceptable only if the image is decorative.",
        advice: "Assign a text alternative with a description of the functional image's content using aria-label or use aria-labelledby if related text exists on the page.",
        associatedDetectors: [PerceivableComponentBackgroundImage, PerceivableTraitDiscernibleText, PerceivableTraitScreenReaderOnly, CompliantTraitVisible],
        refs: [
            {
                type: "WCAG",
                id: "1.1.1",
                level: "A",
                link: "https://www.w3.org/WAI/WCAG22/Understanding/non-text-content.html",
            },
            {
                type: "W3C",
                link: "https://www.w3.org/WAI/WCAG21/quickref/?showtechniques=211%2C412#non-text-content",
            },
            {
                type: "Non-Standard",
                link: "https://www.davidmacd.com/blog/alternate-text-for-css-background-images.html",
            },
            {
                type: "W3C",
                link: "https://www.w3.org/WAI/GL/wiki/ARIATechnique_usingImgRole_with_aria-label_forCSS-backgroundImage",
            },
            {
                type: "W3C",
                link: "https://www.w3.org/WAI/alt/",
            },
            {
                type: "W3C",
                link: "https://www.w3.org/WAI/tutorials/images/decorative/",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ classifier, response }) {
            const backgroundImages = classifier.getMatched([PerceivableComponentBackgroundImage, CompliantTraitVisible]);
            for (const image of backgroundImages) {
                const { visibilityInfo } = classifier.getOperations(image);
                if (visibilityInfo.isExplicitlyHiddenFromScreenReader) {
                    continue;
                }
                const discernibleElements = classifier.getMatchedDirect([PerceivableTraitDiscernibleText], image);
                if (discernibleElements.length === 0) {
                    response.failedNodes.push(image);
                    continue;
                }
                const firstDiscernibleElement = discernibleElements[0];
                const isScreenReaderOnly = classifier.assert(firstDiscernibleElement, PerceivableTraitScreenReaderOnly);
                if (!isScreenReaderOnly) {
                    response.failedNodes.push(image);
                }
                else {
                    response.passedNodes.push(image);
                }
            }
        },
    };

    const BackgroundImageDiscernibleImage = {
        id: "background-image-discernible-image",
        metadata: {
            category: "Graphics",
            profile: ["Blind"],
            wcagVersion: "2.0",
            wcagLevel: "A",
        },
        impact: "serious",
        title: "Functional image displayed using CSS background properties should be tagged for assistive technology",
        description: 'Functional images presented using CSS background or background-image properties should be marked up using role="img" so that they can be identified as images by screen reader users.',
        advice: 'Add role="img" to elements that present functional images using CSS.',
        associatedDetectors: [PerceivableComponentBackgroundImage, PerceivableTraitDiscernibleText, PerceivableTraitScreenReaderOnly, CompliantComponentImage, CompliantTraitVisible],
        refs: [
            {
                type: "WCAG",
                id: "1.1.1",
                level: "A",
                link: "https://www.w3.org/WAI/WCAG22/Understanding/non-text-content.html",
            },
            {
                type: "W3C",
                link: "https://www.w3.org/WAI/WCAG21/quickref/?showtechniques=211%2C412#non-text-content",
            },
            {
                type: "Non-Standard",
                link: "https://www.davidmacd.com/blog/alternate-text-for-css-background-images.html",
            },
            {
                type: "W3C",
                link: "https://www.w3.org/WAI/GL/wiki/ARIATechnique_usingImgRole_with_aria-label_forCSS-backgroundImage",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ classifier, response }) {
            const backgroundImages = classifier.getMatched([PerceivableComponentBackgroundImage, CompliantTraitVisible]);
            for (const image of backgroundImages) {
                const discernibleElements = classifier.getMatched([PerceivableTraitDiscernibleText], image);
                if (discernibleElements.length === 0) {
                    /**
                     * Non-discernible background images are handled in a different rule (background-image-discernible)
                     */
                    continue;
                }
                const firstDiscernibleElement = discernibleElements[0];
                const isScreenReaderOnly = classifier.assert(firstDiscernibleElement, PerceivableTraitScreenReaderOnly);
                if (!isScreenReaderOnly) {
                    /**
                     * Non-discernible background images are handled in a different rule (background-image-discernible)
                     */
                    continue;
                }
                const isImage = classifier.assert(firstDiscernibleElement, CompliantComponentImage);
                if (!isImage) {
                    response.failedNodes.push(firstDiscernibleElement);
                }
                else {
                    response.passedNodes.push(firstDiscernibleElement);
                }
            }
        },
    };

    const MenuTriggerClickable = {
        id: "menu-trigger-clickable",
        metadata: {
            category: "Interactive Content",
            profile: ["Blind"],
            wcagVersion: "2.0",
            wcagLevel: "A",
        },
        impact: "serious",
        title: "ARIA relationship and state attributes should only be applied to elements with appropriate roles",
        description: "Interactive elements that trigger additional content should only have relationship and state ARIA attributes, such as aria-expanded and aria-controls, if they have interactive roles, such as button, tab, combobox and in rarer cases, link.",
        advice: "Make sure relationship and state ARIA attributes are only applied to elements with interactive roles, such as button, tab, and combobox. In rare cases, aria-expanded can be applied to link elements or elements with role='link', however this should only be done when the link both navigates and expands content.",
        associatedDetectors: [CompliantComponentButton, CompliantComponentLink, CompliantComponentMenuTrigger],
        refs: [
            {
                type: "WCAG",
                id: "1.3.1",
                level: "A",
                link: "https://www.w3.org/WAI/WCAG22/Understanding/info-and-relationships.html",
            },
            {
                type: "Non-Standard",
                link: "https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-expanded",
            },
            {
                type: "Non-Standard",
                link: "https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-haspopup",
            },
            {
                type: "Non-Standard",
                link: "https://dequeuniversity.com/rules/axe/4.3/aria-required-attr",
            },
            {
                type: "Non-Standard",
                link: "https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-controls",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ classifier, response }) {
            const elements = classifier.getMatched([CompliantComponentMenuTrigger]);
            for (const element of elements) {
                if (classifier.assert(element, CompliantComponentButton) || classifier.assert(element, CompliantComponentLink)) {
                    response.passedNodes.push(element);
                }
                else {
                    response.failedNodes.push(element);
                }
            }
        },
    };

    const HeadingMismatch = {
        id: "heading-mismatch",
        metadata: {
            category: "General",
            profile: ["Blind"],
            wcagVersion: "2.0",
            wcagLevel: "A",
        },
        impact: "serious",
        title: "Headings should be tagged for assistive technology",
        description: "Text that visually functions as a heading for sighted users should also be tagged as a heading for screen reader users.",
        advice: 'If you specifically coded headings without native HTML tags (like h1, h2, etc.) for SEO reasons or otherwise, use role="heading" and aria-level="1/2/3/4/5/6" (the appropriate heading level) to make sure that screen readers announce them as headings. For example, role="heading" aria-level="3" will be treated by screen readers as a h3 heading. Alternatively, you can directly code those elements as native HTML headings.',
        associatedDetectors: [CompliantComponentHeading, PerceivableComponentHeading],
        refs: [
            {
                type: "WCAG",
                id: "1.3.1",
                level: "A",
                link: "https://www.w3.org/WAI/WCAG22/Understanding/info-and-relationships.html",
            },
            {
                type: "Non-Standard",
                link: "https://www.a11yproject.com/posts/how-to-accessible-heading-structure/",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ response, classifier }) {
            const headings = classifier.getMatched([PerceivableComponentHeading]);
            for (const heading of headings) {
                const isCompliant = classifier.assert(heading, CompliantComponentHeading);
                if (isCompliant) {
                    response.passedNodes.push(heading);
                }
                else {
                    response.failedNodes.push(heading);
                }
            }
        },
    };

    const RegionFooter = {
        id: "region-footer",
        metadata: {
            category: "General",
            profile: ["Cognitive Disability"],
            wcagVersion: "2.0",
            wcagLevel: "A",
        },
        impact: "serious",
        title: "Footer region should be correctly marked up",
        description: "Ensure that the footer region is correctly marked up.",
        advice: "Add a footer element or use role=contentInfo to define the footer of the document.",
        associatedDetectors: [CompliantComponentFooter],
        refs: [
            {
                id: "WCAG-1.1.1",
                type: "WCAG",
                level: "A",
                link: "https://www.w3.org/TR/WCAG20-TECHS/ARIA11.html",
            },
            {
                type: "W3C",
                link: "https://www.w3.org/WAI/tutorials/page-structure/regions/",
            },
            {
                type: "WAI",
                link: "https://www.w3.org/WAI/ARIA/apg/patterns/landmarks/examples/contentinfo.html",
            },
            {
                type: "Non-Standard",
                link: "https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/contentinfo_role/",
            },
            {
                type: "Non-Standard",
                link: "https://www.digitala11y.com/contentinfo-role/",
            },
        ],
        passCondition: PassCondition.PassedNodesAndNoFailedNodes,
        async validate({ response, classifier }) {
            const footer = classifier.getMatched([CompliantComponentFooter])[0];
            if (footer) {
                response.passedNodes.push(footer);
            }
        },
    };

    const RegionFooterMismatch = {
        id: "region-footer-mismatch",
        metadata: {
            category: "Landmarks",
            profile: ["Blind"],
            wcagVersion: "General Guidelines",
            wcagLevel: "N/A",
        },
        impact: "moderate",
        title: "Global site information that appears at the end of each page is contained in a contentinfo landmark (footer)",
        description: "The contentinfo region, typically represented by the <footer> element, is found at the end of each page and provides screen reader users with information about the website, such as copyright, contact details, legal information, and navigation links.",
        advice: 'Use a <footer> element or assign role="contentinfo" to the section that provides global information and consistently appears at the end of each page.',
        associatedDetectors: [PerceivableComponentFooter, CompliantComponentFooter],
        refs: [
            {
                type: "W3C",
                link: "https://www.w3.org/WAI/tutorials/page-structure/regions/",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ response, classifier }) {
            const footers = await classifier.getMatched([PerceivableComponentFooter]);
            for (const footer of footers) {
                if (classifier.assert(footer, CompliantComponentFooter)) {
                    response.passedNodes.push(footer);
                }
                else {
                    response.failedNodes.push(footer);
                }
            }
        },
    };

    const RegionMainContentMisuse = {
        id: "region-main-content-misuse",
        metadata: {
            category: "Landmarks",
            profile: ["Blind"],
            wcagVersion: "2.0",
            wcagLevel: "A",
        },
        impact: "serious",
        title: "An element without main content is tagged as a main landmark",
        description: "Incorrectly tagging the main landmark may cause screen reader users to misunderstand where the primary content begins or ends, leading to confusion and inefficient navigation.",
        advice: 'If the failing element is a custom main landmark, remove role="main". If the failing element is coded using a HTML <main> tag, change the tag to a <div> or an element with a suitable role.',
        associatedDetectors: [PerceivableComponentMainContent, CompliantComponentMainContent],
        refs: [
            {
                type: "WCAG",
                id: "1.3.1",
                level: "A",
                link: "https://www.w3.org/WAI/WCAG22/Understanding/info-and-relationships.html",
            },
            {
                type: "Non-Standard",
                link: "https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/main_role",
            },
            {
                type: "WAI",
                link: "https://www.digitala11y.com/main-role/",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ response, classifier }) {
            const mainLandmarks = classifier.getMatched([CompliantComponentMainContent]);
            for (const mainLandmark of mainLandmarks) {
                if (await classifier.assert(mainLandmark, PerceivableComponentMainContent)) {
                    response.passedNodes.push(mainLandmark);
                }
                else {
                    response.failedNodes.push(mainLandmark);
                }
            }
        },
    };

    const TableMisuse = {
        id: "table-misuse",
        metadata: {
            category: "Tables",
            profile: ["Blind"],
            wcagVersion: "2.0",
            wcagLevel: "A",
        },
        impact: "serious",
        title: "Only elements that function as data tables should be tagged as table",
        description: "When a layout table is marked up with HTML elements like <table> or <tr>, or assigned table ARIA roles, screen readers announce a data table structure with rows, columns, and headers, even though the table is only used for page layout.",
        advice: 'Avoid using table markup or roles for visual layout. Use CSS for page structure, and if a table must be used for layout, remove semantic roles by adding role="presentation" or role="none".',
        associatedDetectors: [PerceivableComponentTable, CompliantComponentTable],
        refs: [
            {
                type: "WCAG",
                id: "1.3.1",
                level: "A",
                link: "https://www.w3.org/WAI/WCAG22/Understanding/info-and-relationships.html",
            },
            {
                type: "W3C",
                link: "https://www.w3.org/WAI/tutorials/tables/",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ response, classifier }) {
            const tables = classifier.getMatched([CompliantComponentTable]);
            for (const table of tables) {
                if (classifier.assert(table, PerceivableComponentTable)) {
                    response.passedNodes.push(table);
                }
                else {
                    response.failedNodes.push(table);
                }
            }
        },
    };

    const FormSubmitButtonMismatch = {
        id: "form-submit-button-mismatch",
        metadata: {
            category: "Forms",
            profile: ["Blind"],
            wcagVersion: "2.0",
            wcagLevel: "A",
        },
        impact: "minor",
        title: 'Form submission controls should have type="submit"',
        description: 'Adding type="submit" to a control that submits a form ensures that screen readers users expect a change of context when they activate the control.',
        advice: 'Assign type="submit" to <button> or <input> elements when they submit a form.',
        associatedDetectors: [CompliantComponentFormSubmitButton, PerceivableComponentFormSubmitButton, CompliantTraitVisible],
        refs: [
            {
                type: "WCAG",
                id: "3.2.2",
                level: "A",
                link: "https://www.w3.org/WAI/WCAG22/Understanding/on-input.html",
            },
            {
                type: "WCAG Technique",
                link: "https://www.w3.org/TR/2008/WD-WCAG20-TECHS-20080430/H32.html",
            },
        ],
        passCondition: PassCondition.NoFailedNodes,
        async validate({ response, classifier }) {
            const buttons = classifier.getMatched([PerceivableComponentFormSubmitButton, CompliantTraitVisible]);
            for (const button of buttons) {
                const isCompliant = classifier.assert(button, CompliantComponentFormSubmitButton);
                if (isCompliant) {
                    response.passedNodes.push(button);
                }
                else {
                    response.failedNodes.push(button);
                }
            }
        },
    };

    /**
     * @class EngineAuditor
     * @classdesc Generate an accessibility audit report
     * It will run all provided rules against the root element and return a report
     * @param root the root element to classify
     * @param traits the traits to classify the elements with
     * @param ignoreRule a rule to ignore elements
     * @example
     * const auditor = new EngineAuditor(document.body, Rules[]);
     * //Get the report
     * const report = await auditor.getReport();
     * //Get specific rule
     * const rule = report.find((item) => item.rule.id === "rule-id");
     *
     */
    class EngineAuditor extends EventEmitter$1 {
        /**
         * List of all the traits
         */
        rules = [];
        /**
         * List of all the utilities
         */
        root;
        /**
         * List of additional detectors to be added to the classifier instance
         */
        additionalDetectors;
        /**
         * The classifier instance value
         * It will be set when the classifier is accessed and serve as a cache
         */
        classifier;
        /**
         * Service to manage and query modifications provided by the setOptions method
         * @see setOptions
         */
        modificationsService;
        /**
         * @constructor
         * @param root the root element to classify
         * @param rules the traits to classify the elements with
         * @param additionalDetectors additional detectors to be added to the classifier instance
         */
        constructor(root, rules, { additionalDetectors } = {}) {
            super();
            this.rules = rules;
            this.root = root;
            this.additionalDetectors = additionalDetectors || [];
            this.modificationsService = new ModificationsService(this.root);
            const relevantDetectors = this.rules.map((rule) => rule.associatedDetectors).flat(1);
            this.classifier = new EngineClassifier(document.body, [...relevantDetectors, ...this.additionalDetectors]);
        }
        /**
         * Public method that allows adding new rules and additional detectors to the auditor instance after initialization.
         */
        updateRules(rules, { additionalDetectors } = {}) {
            this.rules = [...new Set([...this.rules, ...rules])];
            this.additionalDetectors = [...new Set([...this.additionalDetectors, ...(additionalDetectors || [])])];
            const relevantDetectors = this.rules.map((rule) => rule.associatedDetectors).flat(1);
            this.classifier.updateDetectors([...relevantDetectors, ...this.additionalDetectors]);
        }
        /**
         * Retrieves the report of the audit
         * It will assert against the rules provided in the constructor and return a report
         * the report will contain the failed nodes and the passed nodes
         * @param rules the rules to include in the report
         * @returns the report
         */
        async getReport(rules = this.rules) {
            await this.classifier.run();
            const report = new Set();
            for (const rule of rules) {
                const ruleModification = this.modificationsService.getModificationByRuleId(rule.id);
                const response = new RuleValidateResponse();
                // if manualOnly is true - we skip default rule validation, if also there is no rule modification - we can skip the rule early, it will not show up in the report at all
                if (!ruleModification && this.modificationsService.manualOnly)
                    continue;
                if (!this.modificationsService.manualOnly && (!ruleModification || !this.modificationsService.shouldSkipRule(ruleModification))) {
                    // if manualOnly is true - we skip default rule validation
                    try {
                        await rule.validate({ classifier: this.classifier, root: this.root, response, document: this.root.ownerDocument });
                    }
                    catch (ex) {
                        this.emit("error", `Failed to run audit on element. [rule: ${rule.id}, page: ${window.location.href}]`, ex);
                    }
                }
                if (ruleModification) {
                    this.modificationsService.modifyResponse(ruleModification, response);
                }
                response.passed = this.passed(rule, response);
                const validationResult = {
                    rule,
                    ...response,
                };
                report.add(validationResult);
            }
            return report;
        }
        /**
         * Checks if the rule passed
         * It will check the pass condition of the rule and return true if the rule passed
         * @param rule The rule in question
         * @param response The response from the rule validation
         * @private
         */
        passed(rule, response) {
            switch (rule.passCondition) {
                case PassCondition.NoFailedNodes:
                    return response.failedNodes.length === 0;
                case PassCondition.NoInapplicableNodes:
                    return response.inapplicableNodes.length === 0;
                case PassCondition.PassedNodesAndNoFailedNodes:
                    return response.failedNodes.length === 0 && response.passedNodes.length > 0;
            }
        }
        /**
         * Allows the user to set custom ruling options.
         */
        setOptions({ modifications, manualOnly }) {
            if (modifications) {
                this.modificationsService.setModifications(modifications);
            }
            if (typeof manualOnly === "boolean") {
                this.modificationsService.manualOnly = manualOnly;
            }
        }
    }

    var version$1="3.5.0";

    var version="2.42.0";

    const versionStringToNumber = (version) => {
        const versionNums = version.split(".");
        const major = parseInt(versionNums[0] || "0") * 10_000_000;
        const minor = parseInt(versionNums[1] || "0") * 1_000;
        const patch = parseInt(versionNums[2] || "0");
        return major + minor + patch;
    };
    const excludedRuleNames = [];
    /**
     * Classifier operations from EngineAuditor instance
     * This makes the classifier available to rule functions in a clean way
     */
    let classifierOperations = null;
    /**
     * Set classifier operations from an EngineAuditor instance
     * This should be called after the auditor has run its report
     */
    function setClassifierOperations(operations) {
        classifierOperations = operations;
    }
    /**
     * Get classifier operations for an element
     * This makes the classifier available to rule functions in a clean way
     * @param element - The element to get operations for
     * @returns The operations object for the element, or null if not available
     */
    function getClassifierOperations(element) {
        if (!classifierOperations)
            return null;
        if (!element)
            return classifierOperations;
        // OperationService - use classifier.getOperations(element) to get operations for specific element
        const opsService = classifierOperations;
        // Use the classifier directly to get operations for this element
        if (opsService.classifier && typeof opsService.classifier.getOperations === "function") {
            return opsService.classifier.getOperations(element) || null;
        }
        return null;
    }
    /**
     * Get component type from classifier for an element
     */
    function getComponentType($el) {
        const elOps = getClassifierOperations($el);
        if (!elOps)
            return null;
        try {
            if (typeof elOps.componentMatch === "function") {
                const componentMatch = elOps.componentMatch();
                return componentMatch?.element?.type || null;
            }
            else if (elOps.componentMatch && typeof elOps.componentMatch === "object") {
                const matchObj = elOps.componentMatch;
                return matchObj?.element?.type || null;
            }
        }
        catch (e) {
            // componentMatch might not be available or might throw
        }
        return null;
    }
    var RuleId;
    (function (RuleId) {
        RuleId["RegionMainContent"] = "region-main-content";
        RuleId["RegionMainContentMisuse"] = "region-main-content-misuse";
        RuleId["HeadingDiscernible"] = "heading-discernible";
        RuleId["InputDiscernible"] = "input-discernible";
        RuleId["SVGDiscernible"] = "svg-discernible";
        RuleId["TabbableNonInteractive"] = "tabbable-non-interactive";
        RuleId["AriaLabelledByHasReference"] = "aria-labelledby-has-reference";
        RuleId["AriaDescribedByHasReference"] = "aria-describedby-has-reference";
        RuleId["VisibleTextPartOfAccessibleName"] = "visible-text-part-of-accessible-name";
        RuleId["RegionMainContentSingle"] = "region-main-content-single";
        RuleId["RequiredFormFieldAriaRequired"] = "required-form-field-aria-required";
        RuleId["SalePriceDiscernible"] = "sale-price-discernible";
        RuleId["ColorContrast"] = "color-contrast";
        RuleId["VisibilityMismatch"] = "visibility-mismatch";
        RuleId["HeadingH1"] = "heading-h1";
        RuleId["HeadingSingleH1"] = "heading-single-h1";
        RuleId["HtmlLang"] = "html-lang";
        RuleId["HtmlLangValid"] = "html-lang-valid";
        RuleId["LinkAnchorDiscernible"] = "link-anchor-discernible";
        RuleId["LinkAnchorAmbiguous"] = "link-anchor-ambiguous";
        RuleId["LinkNavigationDiscernible"] = "link-navigation-discernible";
        RuleId["InteractiveNotTabbable"] = "interactive-not-tabbable";
        RuleId["LinkNewWindowWarning"] = "link-new-window-warning";
        RuleId["ListNotEmpty"] = "list-not-empty";
        RuleId["HeadingMismatch"] = "heading-mismatch";
        RuleId["IconDiscernible"] = "icon-discernible";
        RuleId["ImageDiscernible"] = "image-discernible";
        RuleId["PopupFocus"] = "popup-focus";
        RuleId["NoAutofocus"] = "no-autofocus";
        RuleId["MenuTriggerCorrectState"] = "menu-trigger-correct-state";
        RuleId["SkipLinkExists"] = "skip-link-exists";
        RuleId["MenuTriggerClickable"] = "menu-trigger-clickable";
        RuleId["NavigationSubmenuRegion"] = "navigation-submenu-region";
        RuleId["RegionFooter"] = "region-footer";
        RuleId["RegionFooterMismatch"] = "region-footer-mismatch";
        RuleId["NoRoleApplication"] = "no-role-application";
        RuleId["CaptchaAccessibleProviderV2_2"] = "captcha-accessible-provider-v2.2";
        RuleId["MarqueeDeprecated"] = "marquee-deprecated";
        RuleId["SRHiddenTabbable"] = "sr-hidden-tabbable";
        RuleId["TabbableVisible"] = "tabbable-visible";
        RuleId["ListItemWithinList"] = "list-item-within-list";
        RuleId["PageMetaViewportValid"] = "page-meta-viewport-valid";
        RuleId["PageMetaViewport"] = "page-meta-viewport";
        RuleId["FigureDiscernible"] = "figure-discernible";
        RuleId["FontSizes"] = "font-sizes";
        RuleId["HeadingLengthy"] = "heading-lengthy";
        RuleId["TabindexValid"] = "tabindex-valid";
        RuleId["FormSubmitButtonMismatch"] = "form-submit-button-mismatch";
        RuleId["ButtonMismatch"] = "button-mismatch";
        RuleId["TableNotNested"] = "table-not-nested";
        RuleId["TableHeaders"] = "table-headers";
        RuleId["TableColumnHeader"] = "table-column-header";
        RuleId["BreadcrumbsMismatch"] = "breadcrumbs-mismatch";
        RuleId["BreadcrumbsNav"] = "breadcrumbs-nav";
        RuleId["NavigationNotNested"] = "navigation-not-nested";
        RuleId["MenuAvoid"] = "menu-avoid";
        RuleId["MenuBarAvoid"] = "menu-bar-avoid";
        RuleId["MenuItemAvoid"] = "menu-item-avoid";
        RuleId["ArticleMisuse"] = "article-misuse";
        RuleId["TableRowHeader"] = "table-row-header";
        RuleId["PageTitle"] = "page-title";
        RuleId["PageTitleValid"] = "page-title-valid";
        RuleId["SearchFormMismatch"] = "search-form-mismatch";
        RuleId["NameProhibitedNoAriaLabel"] = "name-prohibited-no-aria-label";
        RuleId["TableMisuse"] = "table-misuse";
        RuleId["NavigationItemLink"] = "navigation-item-link";
        RuleId["IframeDiscernible"] = "iframe-discernible";
        RuleId["NavigationMisuse"] = "navigation-misuse";
        RuleId["NoExtraInformationInTitle"] = "no-extra-information-in-title";
        RuleId["DialogModalMismatch"] = "dialog-modal-mismatch";
        RuleId["UserRatingDiscernible"] = "user-rating-discernible";
        RuleId["VisibilityMisuse"] = "visibility-misuse";
        RuleId["BackgroundImageDiscernible"] = "background-image-discernible";
        RuleId["BackgroundImageDiscernibleImage"] = "background-image-discernible-image";
        RuleId["FocusNoticeable"] = "focus-noticeable";
        RuleId["LetterSpacingPositive"] = "letter-spacing-positive";
        RuleId["LinkContext"] = "link-context";
        RuleId["CarouselAriaLive"] = "carousel-aria-live";
        RuleId["CustomSelectTriggerCombobox"] = "custom-select-trigger-combobox";
        RuleId["CustomSelectOptionsListListbox"] = "custom-select-options-list-listbox";
        RuleId["SelectOptionMismatch"] = "select-option-mismatch";
        RuleId["CheckboxDiscernible"] = "checkbox-discernible";
        RuleId["CheckboxAriaChecked"] = "checkbox-aria-checked";
        RuleId["CheckboxMismatch"] = "checkbox-mismatch";
        RuleId["RadioDiscernible"] = "radio-discernible";
        RuleId["RadioAriaChecked"] = "radio-aria-checked";
        RuleId["RadioMismatch"] = "radio-mismatch";
    })(RuleId || (RuleId = {}));
    function getReportObjectById(reportMap, id) {
        return reportMap.get(id);
    }
    /**
     * Helper function for straightforward rules
     * @param report ReportMap - the report to get the report object from
     * @param id RuleId - rule ID of the report object
     * @param confidence number - confidence level of the report object, default is 100
     * @returns Record<string, IReport>
     */
    function getReportById(report, id, confidence = 100) {
        const reports = {};
        const reportObject = getReportObjectById(report, id);
        if (!reportObject)
            return {};
        for (const $el of reportObject.passedNodes) {
            const report = createReportObject($el, confidence);
            report.success = true;
            helper.aggregateReports(reports, report);
        }
        for (const $el of reportObject.failedNodes) {
            const report = createReportObject($el, confidence);
            helper.aggregateReports(reports, report);
        }
        return reports;
    }
    function createReportObject($el, confidence, suggestionLabel, suggestionType) {
        const report = helper.reportObject($el, confidence, suggestionLabel, suggestionType);
        report.engineVersions = {
            classifierVersion: version,
            classifierVersionCode: versionStringToNumber(version),
            auditorVersion: version$1,
            auditorVersionCode: versionStringToNumber(version$1),
        };
        return report;
    }
    function mergeAggregateReports(reportsA, resportsB) {
        const reports = {};
        for (const key in reportsA) {
            helper.aggregateReports(reports, reportsA[key]);
        }
        for (const key in resportsB) {
            helper.aggregateReports(reports, resportsB[key]);
        }
        return reports;
    }

    function emptyLinks(report) {
        const reportA = getReportById(report, RuleId.LinkAnchorDiscernible);
        const reportB = getReportById(report, RuleId.LinkNavigationDiscernible);
        return mergeAggregateReports(reportA, reportB);
    }
    function newWindowLinks(report) {
        return getReportById(report, RuleId.LinkNewWindowWarning);
    }
    function buttonRoles(report) {
        const reports = {};
        const reportObject = report.get(RuleId.ButtonMismatch);
        if (!reportObject)
            return {};
        for (const $el of reportObject.passedNodes) {
            const report = createReportObject($el, 91);
            report.success = true;
            helper.aggregateReports(reports, report);
        }
        for (const $el of reportObject.failedNodes) {
            const report = createReportObject($el, 91);
            if (!report.success) {
                const componentType = getComponentType($el);
                if (componentType) {
                    report.suggestionType = "button";
                    report.suggestionLabel = componentType;
                }
            }
            helper.aggregateReports(reports, report);
        }
        return reports;
    }
    function linkContext(report) {
        const reports = {};
        const reportObject = getReportObjectById(report, RuleId.LinkContext);
        if (!reportObject)
            return {};
        const processNodes = (nodes, success) => {
            for (const $el of nodes) {
                const report = createReportObject($el, 88);
                report.success = success;
                report.suggestionType = "link";
                const componentType = getComponentType($el);
                if (componentType) {
                    report.suggestionLabel = componentType;
                }
                helper.aggregateReports(reports, report);
            }
        };
        processNodes(reportObject.passedNodes, true);
        processNodes(reportObject.failedNodes, false);
        return reports;
    }
    function ambiguousLinks(report) {
        return getReportById(report, RuleId.LinkAnchorAmbiguous);
    }

    function mainLandmark(report) {
        const reportObject = getReportObjectById(report, RuleId.RegionMainContent);
        if (!reportObject)
            return {};
        const el = reportObject.passedNodes[0];
        const r = createReportObject(el, 84, "main", "landmark");
        if (reportObject.passed) {
            r.success = true;
        }
        else {
            r.HTML = "<main></main>";
            r.selector = "body > main";
            r.isDummySelector = true;
        }
        return { [r.selector]: r };
    }
    function multiMainLandmarks(report) {
        return getReportById(report, RuleId.RegionMainContentSingle);
    }
    function incorrectMainLandmark(report) {
        const reportObject = getReportObjectById(report, RuleId.RegionMainContentMisuse);
        if (!reportObject)
            return {};
        const el = reportObject.failedNodes[0] || reportObject.passedNodes[0];
        const r = createReportObject(el, 84);
        if (reportObject.passed) {
            r.success = true;
        }
        else {
            r.HTML = "<main></main>";
            r.selector = "body > main";
            r.isDummySelector = true;
        }
        return { [r.selector]: r };
    }
    function footerLandmark(report) {
        const reportObject = getReportObjectById(report, RuleId.RegionFooter);
        if (reportObject?.failedNodes.length || reportObject?.passedNodes.length) {
            const reports = {};
            const processNodes = (nodes, success) => {
                for (const $el of nodes) {
                    const report = createReportObject($el, 84, "footer", "landmark");
                    report.success = success;
                    helper.aggregateReports(reports, report);
                }
            };
            processNodes(reportObject.passedNodes, true);
            processNodes(reportObject.failedNodes, false);
            return reports;
        }
        else {
            const r = createReportObject(null, 84, "footer", "landmark");
            r.HTML = "<footer></footer>";
            r.isDummySelector = true;
            r.selector = "body > footer";
            return { ["body > footer"]: r };
        }
    }
    function articleSetup(report) {
        return getReportById(report, RuleId.ArticleMisuse);
    }
    function iframeLabeling(report) {
        return getReportById(report, RuleId.IframeDiscernible);
    }
    function popupTagging(report) {
        return getReportById(report, RuleId.DialogModalMismatch);
    }
    function userRating(report) {
        const reportObject = getReportObjectById(report, RuleId.UserRatingDiscernible);
        const reports = {};
        if (!reportObject)
            return {};
        const processNodes = (nodes, success) => {
            for (const $el of nodes) {
                const report = createReportObject($el, 87);
                report.success = success;
                report.suggestionLabel = "5/5";
                report.suggestionType = "rating";
                helper.aggregateReports(reports, report);
            }
        };
        processNodes(reportObject.passedNodes, true);
        processNodes(reportObject.failedNodes, false);
        return reports;
    }
    function salePrices(report) {
        return getReportById(report, RuleId.SalePriceDiscernible, 92);
    }

    // export function languageReport(report: ReportMap) {
    //   const reportA = getReportById(report, RuleId.HtmlLang);
    //   const reportB = getReportById(report, RuleId.HtmlLangValid);
    //   return mergeAggregateReports(reportA, reportB);
    // }
    function viewportScalability(report) {
        const reportA = getReportById(report, RuleId.PageMetaViewportValid);
        const reportB = getReportById(report, RuleId.PageMetaViewport);
        return mergeAggregateReports(reportA, reportB);
    }
    function pageTitle(report) {
        const reportA = getReportById(report, RuleId.PageTitle);
        const reportB = getReportById(report, RuleId.PageTitleValid);
        const reportObjects = mergeAggregateReports(reportA, reportB) || {};
        // Add a default report object if none exist
        if (Object.keys(reportObjects).length === 0)
            reportObjects["obj"] = createReportObject(null, 100);
        const reports = {};
        const enrichReport = ($title, success) => {
            const report = createReportObject($title, 94);
            report.success = success;
            report.selector = "head > title";
            report.HTML = $title ? report.HTML : "<title></title>";
            if (!$title)
                report.isDummySelector = true;
            helper.aggregateReports(reports, report);
        };
        for (const key in reportObjects) {
            const report = reportObjects[key];
            const $title = document.head.querySelector("title") || null;
            enrichReport($title, report.success);
        }
        return reports;
    }

    function brokenAriaReference(report) {
        const reportA = getReportById(report, RuleId.AriaLabelledByHasReference);
        const reportB = getReportById(report, RuleId.AriaDescribedByHasReference);
        return mergeAggregateReports(reportA, reportB);
    }
    function brokenAriaLabels(report) {
        return getReportById(report, RuleId.VisibleTextPartOfAccessibleName);
    }
    // export function hiddenVisibleContent(report: ReportMap) {
    //   return getReportById(report, RuleId.VisibilityMismatch);
    // }
    // export function emptyList(report: ReportMap) {
    //   return getReportById(report, RuleId.ListNotEmpty);
    // }
    function loadAutofocus(report) {
        return getReportById(report, RuleId.NoAutofocus);
    }
    function marquee(report) {
        return getReportById(report, RuleId.MarqueeDeprecated);
    }
    function brokenList(report) {
        return getReportById(report, RuleId.ListItemWithinList);
    }
    function roleApplications(report) {
        return getReportById(report, RuleId.NoRoleApplication);
    }
    function ariaLabelMisuse(report) {
        const reportObj = getReportById(report, RuleId.NameProhibitedNoAriaLabel);
        return reportObj;
    }
    function titleMisuse(report) {
        return getReportById(report, RuleId.NoExtraInformationInTitle);
    }
    function fakeHiddenContent(report) {
        return getReportById(report, RuleId.VisibilityMisuse);
    }

    // export function fieldLabel(report: ReportMap) {
    //   const reportObject = getReportObjectById(report, RuleId.InputDiscernible);
    //   const reports: Record<string, IReport> = {};
    //   if (!reportObject) return {};
    //   const processNodes = (nodes: Elem[], success: boolean) => {
    //     for (const $el of nodes) {
    //       const report = createReportObject($el, 91);
    //       const type = $el?.getAttribute("type");
    //       report.success = success;
    //       if (type) {
    //         report.suggestionLabel = type;
    //         report.suggestionType = "field";
    //       }
    //       helper.aggregateReports(reports, report);
    //     }
    //   };
    //   processNodes(reportObject.passedNodes, true);
    //   processNodes(reportObject.failedNodes, false);
    //   return reports;
    // }
    function captcha(report) {
        return getReportById(report, RuleId.CaptchaAccessibleProviderV2_2);
    }
    function missingFormButton(report) {
        return getReportById(report, RuleId.FormSubmitButtonMismatch);
    }
    function searchFormTagging(report) {
        return getReportById(report, RuleId.SearchFormMismatch);
    }
    function fieldRequired(report) {
        const reportObject = getReportObjectById(report, RuleId.RequiredFormFieldAriaRequired);
        const reports = {};
        if (!reportObject)
            return {};
        const processNodes = (nodes, success) => {
            for (const $el of nodes) {
                const report = createReportObject($el, 100, "required", "field");
                report.success = success;
                helper.aggregateReports(reports, report);
            }
        };
        processNodes(reportObject.passedNodes, true);
        processNodes(reportObject.failedNodes, false);
        return reports;
    }
    // export function customSelectField(report: ReportMap) {
    //   const reports: Record<string, IReport> = {};
    //   const ruleIds = [
    //     RuleId.CustomSelectTriggerCombobox,
    //     RuleId.CustomSelectOptionsListListbox,
    //     RuleId.SelectOptionMismatch,
    //   ];
    //   for (const ruleId of ruleIds) {
    //     const ruleReport = getReportById(report, ruleId, 100);
    //     for (const key in ruleReport) {
    //       const reportObj = ruleReport[key];
    //       reportObj.suggestionLabel = "customSelect";
    //       reportObj.suggestionType = "field";
    //       helper.aggregateReports(reports, reportObj);
    //     }
    //   }
    //   return reports;
    // }
    // export function customControlField(report: ReportMap) {
    //   const reports: Record<string, IReport> = {};
    //   const ruleIds = [
    //     RuleId.CheckboxDiscernible,
    //     RuleId.CheckboxAriaChecked,
    //     RuleId.CheckboxMismatch,
    //     RuleId.RadioDiscernible,
    //     RuleId.RadioAriaChecked,
    //     RuleId.RadioMismatch,
    //   ];
    //   for (const ruleId of ruleIds) {
    //     const ruleReport = getReportById(report, ruleId, 89);
    //     for (const key in ruleReport) {
    //       const reportObj = ruleReport[key];
    //       reportObj.suggestionLabel = "customControl";
    //       reportObj.suggestionType = "field";
    //       helper.aggregateReports(reports, reportObj);
    //     }
    //   }
    //   return reports;
    // }

    function svgContent(report) {
        return getReportById(report, RuleId.SVGDiscernible);
    }
    function altText(report) {
        const reportObject = getReportObjectById(report, RuleId.ImageDiscernible);
        const reports = {};
        if (!reportObject)
            return {};
        const processNodes = (nodes, success) => {
            for (const $el of nodes) {
                const imgEl = $el;
                const report = createReportObject(imgEl, 100);
                report.success = success;
                if (imgEl.src) {
                    report.src = imgEl.src.includes("data:") ? imgEl.src.substring(0, 20) : helper.uris.format(imgEl.src);
                }
                else {
                    report.src = "";
                }
                helper.aggregateReports(reports, report, "src");
            }
        };
        processNodes(reportObject.passedNodes, true);
        processNodes(reportObject.failedNodes, false);
        return reports;
    }
    function decorativeContent(report) {
        const reportObject = getReportObjectById(report, RuleId.IconDiscernible);
        const reports = {};
        if (!reportObject)
            return {};
        const processNodes = (nodes, success) => {
            for (const $el of nodes) {
                const report = helper.reportObject($el, 96);
                report.success = success;
                report.suggestionLabel = "decorativeContent";
                helper.aggregateReports(reports, report);
            }
        };
        processNodes(reportObject.passedNodes, true);
        processNodes(reportObject.failedNodes, false);
        return reports;
    }
    function backgroundImages(report) {
        const reportA = getReportById(report, RuleId.BackgroundImageDiscernible);
        const reportB = getReportById(report, RuleId.BackgroundImageDiscernibleImage);
        return mergeAggregateReports(reportA, reportB);
    }
    function figureSetup(report) {
        return getReportById(report, RuleId.FigureDiscernible, 100);
    }

    // export function emptyHeadings(report: ReportMap) {
    //   return getReportById(report, RuleId.HeadingDiscernible);
    // }
    function mainHeading(report) {
        return getReportById(report, RuleId.HeadingH1);
    }
    function multipleMainHeadings(report) {
        return getReportById(report, RuleId.HeadingSingleH1);
    }
    function untaggedHeadings(report) {
        return getReportById(report, RuleId.HeadingMismatch);
    }
    function longHeadings(report) {
        return getReportById(report, RuleId.HeadingLengthy);
    }

    function noninteractiveTabindex(report) {
        return getReportById(report, RuleId.TabbableNonInteractive);
    }
    function keyboardNavigation(report) {
        const reportObject = getReportObjectById(report, RuleId.InteractiveNotTabbable);
        if (!reportObject)
            return {};
        const reports = {};
        const enrichReport = ($el, success) => {
            const report = createReportObject($el, 94);
            report.suggestionLabel = "navigableElement";
            report.success = success;
            helper.aggregateReports(reports, report);
        };
        reportObject.passedNodes.forEach(($el) => enrichReport($el, true));
        reportObject.failedNodes.forEach(($el) => enrichReport($el, false));
        return reports;
    }
    function popupFocus(report) {
        return getReportById(report, RuleId.PopupFocus);
    }
    function skipLinks(report) {
        const reportObject = getReportObjectById(report, RuleId.SkipLinkExists);
        if (!reportObject)
            return {};
        const reports = {};
        reportObject.passedNodes.forEach(($el) => {
            const report = createReportObject($el, 92);
            report.suggestionLabel = "skipLink";
            if (reportObject.passed) {
                report.success = true;
            }
            else {
                report.HTML = '<a href="#content">Skip to content</a>';
                report.selector = "body > a.skip-link";
                report.isDummySelector = true;
            }
            helper.aggregateReports(reports, report);
        });
        return reports;
    }
    // export function fakeHiddenInteractive(report: ReportMap) {
    //   const reportA = getReportById(report, RuleId.SRHiddenTabbable);
    //   const reportB = getReportById(report, RuleId.TabbableVisible);
    //   const unifiedReport = mergeAggregateReports(reportA, reportB);
    //   return unifiedReport;
    // }
    function brokenTabindex(report) {
        return getReportById(report, RuleId.TabindexValid);
    }
    function focusNoticeable(report) {
        const reportObject = getReportObjectById(report, RuleId.FocusNoticeable);
        const reports = {};
        if (!reportObject)
            return {};
        const processNodes = (nodes, success) => {
            for (const $el of nodes) {
                const report = createReportObject($el, 100);
                report.selector = "a[href], button, [tabindex]";
                report.isDummySelector = true;
                report.success = success;
                helper.aggregateReports(reports, report);
            }
        };
        processNodes(reportObject.passedNodes, true);
        processNodes(reportObject.failedNodes, false);
        return reports;
    }

    function submenuState(report) {
        return getReportById(report, RuleId.MenuTriggerCorrectState);
    }
    function brokenSubmenuIndication(report) {
        return getReportById(report, RuleId.MenuTriggerClickable);
    }
    function breadcrumbs(report) {
        const reportA = getReportById(report, RuleId.BreadcrumbsMismatch);
        const reportB = getReportById(report, RuleId.BreadcrumbsNav);
        return mergeAggregateReports(reportA, reportB);
    }
    function nestedNavigation(report) {
        return getReportById(report, RuleId.NavigationNotNested);
    }
    function brokenNavTagging(report) {
        const menuAvoid = getReportById(report, RuleId.MenuAvoid);
        const menuBarAvoid = getReportById(report, RuleId.MenuBarAvoid);
        return mergeAggregateReports(menuAvoid, menuBarAvoid);
    }
    function brokenNavItems(report) {
        return getReportById(report, RuleId.MenuItemAvoid);
    }
    function missingNavItems(report) {
        return getReportById(report, RuleId.NavigationItemLink);
    }
    function misusedNavTagging(report) {
        return getReportById(report, RuleId.NavigationMisuse);
    }
    function submenuTagging(report) {
        return getReportById(report, RuleId.NavigationSubmenuRegion);
    }

    // @TODO: Wait for update of unified engine to fix false positives for colorContrast
    // export function colorContrast(report: ReportMap) {
    //   return getReportById(report, RuleId.ColorContrast);
    // }
    function fontSizes(report) {
        return getReportById(report, RuleId.FontSizes);
    }
    function letterSpacing(report) {
        return getReportById(report, RuleId.LetterSpacingPositive);
    }

    function nestedTables(report) {
        return getReportById(report, RuleId.TableNotNested);
    }
    function tableLayouts(report) {
        return getReportById(report, RuleId.TableMisuse);
    }
    function rowTableHeaders(report) {
        const reportObject = getReportObjectById(report, RuleId.TableRowHeader);
        const reports = {};
        if (!reportObject)
            return {};
        const processNodes = (nodes, success) => {
            for (const $el of nodes) {
                const report = helper.reportObject($el, 84);
                report.success = success;
                report.suggestionLabel = "rowHeader";
                helper.aggregateReports(reports, report);
            }
        };
        processNodes(reportObject.passedNodes, true);
        processNodes(reportObject.failedNodes, false);
        return reports;
    }
    function columnTableHeaders(report) {
        const reportObject = getReportObjectById(report, RuleId.TableColumnHeader);
        const reports = {};
        if (!reportObject)
            return {};
        const processNodes = (nodes, success) => {
            for (const $el of nodes) {
                const report = helper.reportObject($el, 88);
                report.success = success;
                report.suggestionLabel = "columnHeader";
                helper.aggregateReports(reports, report);
            }
        };
        processNodes(reportObject.passedNodes, true);
        processNodes(reportObject.failedNodes, false);
        return reports;
    }
    function headlessTables(report) {
        return getReportById(report, RuleId.TableHeaders, 91);
    }

    function liveCarousels(report) {
        return getReportById(report, RuleId.CarouselAriaLive);
    }

    var rules = /*#__PURE__*/Object.freeze({
        __proto__: null,
        altText: altText,
        ambiguousLinks: ambiguousLinks,
        ariaLabelMisuse: ariaLabelMisuse,
        articleSetup: articleSetup,
        backgroundImages: backgroundImages,
        breadcrumbs: breadcrumbs,
        brokenAriaLabels: brokenAriaLabels,
        brokenAriaReference: brokenAriaReference,
        brokenList: brokenList,
        brokenNavItems: brokenNavItems,
        brokenNavTagging: brokenNavTagging,
        brokenSubmenuIndication: brokenSubmenuIndication,
        brokenTabindex: brokenTabindex,
        buttonRoles: buttonRoles,
        captcha: captcha,
        columnTableHeaders: columnTableHeaders,
        decorativeContent: decorativeContent,
        emptyLinks: emptyLinks,
        fakeHiddenContent: fakeHiddenContent,
        fieldRequired: fieldRequired,
        figureSetup: figureSetup,
        focusNoticeable: focusNoticeable,
        fontSizes: fontSizes,
        footerLandmark: footerLandmark,
        headlessTables: headlessTables,
        iframeLabeling: iframeLabeling,
        incorrectMainLandmark: incorrectMainLandmark,
        keyboardNavigation: keyboardNavigation,
        letterSpacing: letterSpacing,
        linkContext: linkContext,
        liveCarousels: liveCarousels,
        loadAutofocus: loadAutofocus,
        longHeadings: longHeadings,
        mainHeading: mainHeading,
        mainLandmark: mainLandmark,
        marquee: marquee,
        missingFormButton: missingFormButton,
        missingNavItems: missingNavItems,
        misusedNavTagging: misusedNavTagging,
        multiMainLandmarks: multiMainLandmarks,
        multipleMainHeadings: multipleMainHeadings,
        nestedNavigation: nestedNavigation,
        nestedTables: nestedTables,
        newWindowLinks: newWindowLinks,
        noninteractiveTabindex: noninteractiveTabindex,
        pageTitle: pageTitle,
        popupFocus: popupFocus,
        popupTagging: popupTagging,
        roleApplications: roleApplications,
        rowTableHeaders: rowTableHeaders,
        salePrices: salePrices,
        searchFormTagging: searchFormTagging,
        skipLinks: skipLinks,
        submenuState: submenuState,
        submenuTagging: submenuTagging,
        svgContent: svgContent,
        tableLayouts: tableLayouts,
        titleMisuse: titleMisuse,
        untaggedHeadings: untaggedHeadings,
        userRating: userRating,
        viewportScalability: viewportScalability
    });

    var unifiedRules = [
        RegionMainContent,
        // HeadingDiscernible,
        SVGDiscernible,
        // InputDiscernible,
        TabbableNonInteractive,
        AriaLabelledByHasReference,
        AriaDescribedByHasReference,
        VisibleTextPartOfAccessibleName,
        RegionMainContentSingle,
        RegionMainContentMisuse,
        SalePriceDiscernible,
        //ColorContrast,
        VisibilityMismatch,
        HeadingH1,
        HeadingSingleH1,
        HtmlLang,
        HtmlLangValid,
        LinkAnchorDiscernible,
        LinkAnchorAmbiguous,
        LinkContext,
        LinkNavigationDiscernible,
        InteractiveNotTabbable,
        LinkNewWindowWarning,
        // ListNotEmpty,
        HeadingMismatch,
        IconDiscernible,
        ImageDiscernible,
        DialogModalFocus,
        FocusNoticeable,
        NoAutofocus,
        MenuTriggerCorrectState,
        SkipLinkExists,
        MenuTriggerClickable,
        NavigationSubmenuRegion,
        RegionFooter,
        RegionFooterMismatch,
        CaptchaAccessibleProvider_v2_2,
        MarqueeDeprecated,
        // TabbableVisible,
        // SRHiddenTabbable,
        TableRowHeader,
        ListItemWithinList,
        PageMetaViewportValid,
        PageMetaViewport,
        FontSizes,
        FigureDiscernible,
        LetterSpacingPositive,
        HeadingLengthy,
        TabindexValid,
        FormSubmitButtonMismatch,
        ButtonMismatch,
        TableNotNested,
        TableHeaders,
        TableColumnHeader,
        NameProhibitedNoAriaLabel,
        BreadcrumbsMismatch,
        BreadcrumbsNav,
        NavigationNotNested,
        MenuAvoid,
        MenuBarAvoid,
        MenuItemAvoid,
        ArticleMisuse,
        NoRoleApplication,
        PageTitle,
        PageTitleValid,
        SearchFormMismatch,
        RequiredFormFieldAriaRequired,
        TableMisuse,
        NavigationItemLink,
        IframeDiscernible,
        NavigationMisuse,
        NoExtraInformationInTitle,
        DialogModalMismatch,
        UserRatingDiscernible,
        VisibilityMisuse,
        BackgroundImageDiscernible,
        BackgroundImageDiscernibleImage,
        CarouselAriaLive,
        // CustomSelectTriggerCombobox,
        // CustomSelectOptionsListListbox,
        // SelectOptionMismatch,
        // CheckboxDiscernible,
        // CheckboxAriaChecked,
        // CheckboxMismatch,
        // RadioDiscernible,
        // RadioAriaChecked,
        // RadioMismatch,
    ];

    function getReport(element) {
        const auditor = new EngineAuditor(element, unifiedRules);
        // Capture classifier operations from the auditor instance for use in rule functions
        // The classifier is available immediately after creating the auditor instance
        setClassifierOperations(auditor.classifier?.getOperations?.(element) || null);
        return auditor.getReport();
    }
    function convertReportIntoMap(report) {
        const reportMap = new Map();
        for (const reportItem of report) {
            if (!isValidRuleId(reportItem.rule.id))
                continue;
            reportMap.set(reportItem.rule.id, reportItem);
        }
        return reportMap;
    }
    function convertReportIntoMapWithSetNodes(report) {
        const reportMap = new Map();
        for (const reportItem of report) {
            if (!isValidRuleId(reportItem.rule.id))
                continue;
            reportMap.set(reportItem.rule.id, {
                ...reportItem,
                passedNodes: new Set(reportItem.passedNodes),
                failedNodes: new Set(reportItem.failedNodes),
            });
        }
        return reportMap;
    }
    async function runAudit(element) {
        const report = await getReport(element);
        return convertReportIntoMap(report);
    }
    function mergeNewReportIntoOldReport(report, oldReport) {
        const converted = {};
        for (const rule of Object.values(rules)) {
            const newReport = rule(report);
            if (isValidRuleFunctionName(rule.name) && !excludedRuleNames.includes(rule.name)) {
                for (const key in newReport) {
                    newReport[key].newEngine = true;
                }
                const ruleName = rule.name;
                converted[ruleName] = newReport;
            }
        }
        return { ...oldReport, ...converted };
    }
    function removePastAuditedReports(currentAudit, pastAudit) {
        for (const item of currentAudit) {
            if (pastAudit.has(item[0])) {
                const reportItemFromPastAudit = pastAudit.get(item[0]);
                //remove report item without passed or failed nodes that has the same report
                if (item[1].passedNodes.length === 0 &&
                    item[1].failedNodes.length === 0 &&
                    reportItemFromPastAudit?.passedNodes.size === 0 &&
                    reportItemFromPastAudit?.failedNodes.size === 0 &&
                    item[1].passed === reportItemFromPastAudit?.passed) {
                    currentAudit.delete(item[0]);
                }
                //remove already audited nodes
                item[1].passedNodes = item[1].passedNodes.filter((node) => !reportItemFromPastAudit?.passedNodes.has(node));
                item[1].failedNodes = item[1].failedNodes.filter((node) => !reportItemFromPastAudit?.failedNodes.has(node));
            }
        }
        return currentAudit;
    }
    function isValidRuleFunctionName(ruleFunctionName) {
        return ruleFunctionName in rules;
    }
    function isValidRuleId(id) {
        return Object.values(RuleId).includes(id);
    }

    const criterias = {
        READABILITY,
        NAVIGATION,
        CLICKABLES,
        CAROUSELS,
        GRAPHICS,
        HEADINGS,
        DOCUMENT,
        KEYBOARD,
        CONTEXT,
        ERRORS,
        TABLES,
        FORMS,
    };
    function sleep(ms) {
        return new Promise((r) => setTimeout(r, ms));
    }
    var auditor = {
        timepass: 0,
        clickProcess: false,
        ready: false,
        domChangeDetail: null,
        $funnelEls: [],
        criterias,
        async loadAudit() {
            if (!this.ready) {
                await this._prepare();
                await this._setBases();
            }
            return await this._audit();
        },
        /* istanbul ignore next */
        async dynamicAudit() {
            if (!this.ready) {
                await this._prepare();
                await this._setBases();
                await this._audit();
                await this._initObserver();
            }
            return await (async () => {
                const data = {};
                const clicked = [];
                const $queue = helper.elements.filterHiddens(document.querySelectorAll("[data-aflw-button]"));
                document.addEventListener("aflwDOMChanged", (e) => {
                    if (!e.detail.clickProcess || e.detail.$toProcess.length < 1)
                        return;
                    setTimeout(async () => {
                        await this._setBases(e.detail.$toProcess);
                        for (const $el of e.detail.$toProcess) {
                            if ($el.matches("[data-aflw-button]") &&
                                !$el.closest('[data-aflw-hidden="true"]') &&
                                !$queue.includes($el)) {
                                $queue.push($el);
                            }
                            for (const $btn of helper.elements.filterHiddens($el.querySelectorAll("[data-aflw-button]"))) {
                                if (!$queue.includes($btn))
                                    $queue.push($btn);
                            }
                        }
                        const audits = await this._audit(true, e.detail.$toProcess, e.detail);
                        for (const k in audits) {
                            if (!data[k])
                                data[k] = {};
                            for (const k2 in audits[k])
                                data[k][k2] = audits[k][k2];
                        }
                    }, 1000);
                });
                await (async () => {
                    await sleep(500);
                    for (const $el of $queue) {
                        if ($el.closest('[data-aflw-hidden="true"]'))
                            continue;
                        const $form = $el.closest("[data-aflw-role=form]");
                        const selector = helper.elements.generateSelector($el);
                        if ($el.type === "submit" ||
                            clicked.includes(selector) ||
                            ($form && $el.tagName === "BUTTON" && $form.querySelectorAll("button").length === 1)) {
                            continue;
                        }
                        clicked.push(selector);
                        if ("click" in $el)
                            $el.click();
                        await sleep(2000);
                    }
                })();
                return data;
            })();
        },
        async startFunnelAudit() {
            if (!this.ready) {
                await this._prepare();
                await this._setBases();
                await this._audit();
                await this._initObserver();
            }
            const unifiedReport = await getReport(document.body);
            window.globalReport = convertReportIntoMapWithSetNodes(unifiedReport);
            try {
                window.accessFlowData.actions = JSON.parse(window.accessFlowData.actions);
            }
            catch (err) { }
            if (!window.accessFlowData.actions ||
                window.accessFlowData.actions.constructor.name !== "Array") {
                window.accessFlowData.actions = window.accessFlowData.actions || [];
            }
            this.$funnelEls = [];
            for (const obj of window.accessFlowData.actions) {
                try {
                    const $el = document.querySelector(obj.actionSelector);
                    if ($el)
                        this.$funnelEls.push($el);
                }
                catch (err) { }
            }
            this.domChangeDetail = null;
            document.addEventListener("aflwDOMChanged", (e) => {
                if (e.detail.$toProcess.length < 1)
                    return;
                e.detail.$toProcess = [
                    ...new Set([
                        ...this.$funnelEls,
                        ...e.detail.$toProcess,
                        ...(this.domChangeDetail?.$toProcess || []),
                    ]),
                ];
                this.domChangeDetail = e.detail;
            });
        },
        async funnelAudit() {
            const data = {};
            await sleep(1000);
            if (this.domChangeDetail) {
                const audit = await runAudit(document.body);
                const unifiedAudit = removePastAuditedReports(audit, window.globalReport);
                await this._setBases(this.domChangeDetail.$toProcess);
                const audits = await this._audit(true, this.domChangeDetail.$toProcess, this.domChangeDetail);
                const mergedAudits = mergeNewReportIntoOldReport(unifiedAudit, audits);
                for (const k in mergedAudits) {
                    if (!data[k])
                        data[k] = {};
                    for (const k2 in mergedAudits[k])
                        data[k][k2] = mergedAudits[k][k2];
                }
            }
            return data;
        },
        async _audit(dynamic, $els, data) {
            $els = $els?.filter((d) => {
                return d?.isConnected;
            });
            await this._setBases($els);
            return {
                ...(await READABILITY.audit(dynamic, $els)),
                ...(await NAVIGATION.audit(dynamic, $els)),
                ...(await CLICKABLES.audit(dynamic, $els)),
                ...(await CAROUSELS.audit(dynamic, $els)),
                ...(await DOCUMENT.audit(dynamic, $els)),
                ...(await GRAPHICS.audit(dynamic, $els)),
                ...(await HEADINGS.audit(dynamic, $els)),
                ...(await KEYBOARD.audit(dynamic, $els, data)),
                ...(await CONTEXT.audit(dynamic, $els)),
                ...(await ERRORS.audit(dynamic, $els)),
                ...(await TABLES.audit(dynamic, $els)),
                ...(await FORMS.audit(dynamic, $els)),
            };
        },
        async _setBases($els) {
            await this._setRoleEquivalents($els);
            await this._setVisibility($els);
            await this._setSrVisibility($els);
            await this._setSkipLinks();
            await this._setClickability($els);
            await this._setNavigability($els);
            await this._setCarousels();
            await this._setNavigations();
            await this._setSrOnly();
            await this._setTextualContext($els);
            await this._setTextualType();
            await this._setFooterLandmark();
            await this._setMainLandmark();
            await this._setNavigationLabels();
            await this._setUntaggedHeading($els);
            await this._setLinkPresets($els);
            await this._setActivePopups($els);
        },
        async _initObserver() {
            if (helper.dynamic)
                return;
            helper.dynamic = true;
            let $changes = [];
            let throttler = [];
            let clicksInRow = 0;
            const scrollPosition = 0;
            let styleChanged = false;
            let newElements = false;
            document.addEventListener("click", (e) => {
                const target = e.target;
                if (!target.closest("[data-aflw-clickable]"))
                    return;
                clicksInRow = clicksInRow + 1;
                setTimeout(() => (clicksInRow = 0), 500);
                if (target.tagName === "A")
                    e.preventDefault();
                if (this.clickProcess || clicksInRow > 1 || typeof target.closest !== "function")
                    return;
                this.clickProcess = true;
                setTimeout(() => (this.clickProcess = false), 1000);
            });
            document.addEventListener("DOMNodeInserted", (e) => {
                const target = e.target;
                if (target.nodeType !== Node.ELEMENT_NODE ||
                    target.closest("[data-acsb], [data-aflw-sr-only]") ||
                    throttler.includes(target) ||
                    ["BODY", "SCRIPT", "STYLE"].includes(target.tagName) ||
                    $changes.includes(target)) {
                    return;
                }
                newElements = true;
                $changes.push(target);
                throttler.push(target);
            });
            new MutationObserver((records) => {
                for (const record of records) {
                    if (!(record.target instanceof HTMLElement) ||
                        record.type !== "attributes" ||
                        (record.attributeName === "class" && record.target["className"] === record.oldValue) ||
                        record.target.closest("[data-acsb], [data-aflw-sr-only]") ||
                        record.attributeName?.substring(0, 9) === "data-acsb" ||
                        $changes.includes(record.target) ||
                        throttler.includes(record.target)) {
                        continue;
                    }
                    if (["class", "style"].includes(record.attributeName || "") ||
                        record.attributeName?.substring(0, 5) === "data-") {
                        if (record.attributeName === "style")
                            styleChanged = true;
                        $changes.push(record.target);
                        throttler.push(record.target);
                        if (record.target.nextElementSibling &&
                            record.target.nextElementSibling.getAttribute("data-aflw-hidden")) {
                            $changes.push(record.target.nextElementSibling);
                            throttler.push(record.target);
                        }
                    }
                }
            }).observe(document, {
                attributeOldValue: true,
                attributes: true,
                subtree: true,
                childList: false,
            });
            setInterval(() => (throttler = []), 1000);
            setInterval(() => {
                if ($changes.length < 1)
                    return;
                const $toProcess = [];
                const bodyChanged = $changes.includes(document.body) ||
                    $changes.includes(document.querySelector("html"));
                if (bodyChanged) {
                    for (const $el of document.body.querySelectorAll(allSelector))
                        if (!$el.closest("[data-acsb]"))
                            $toProcess.push($el);
                    $toProcess.unshift(document.body);
                }
                else {
                    for (const $el of $changes) {
                        for (const $innerEl of $el.querySelectorAll(allSelector))
                            $toProcess.push($innerEl);
                        $toProcess.unshift($el);
                        const $hiddenParent = $el.closest('[data-aflw-hidden="true"]');
                        if ($hiddenParent)
                            $toProcess.unshift($hiddenParent);
                    }
                }
                if ($toProcess.length < 1)
                    return;
                document.dispatchEvent(new CustomEvent("aflwDOMChanged", {
                    bubbles: true,
                    detail: {
                        bodyChanged,
                        newElements,
                        styleChanged,
                        scrollPosition,
                        $toProcess,
                        $changes,
                        clickProcess: this.clickProcess,
                    },
                }));
                $changes = [];
                newElements = false;
                styleChanged = false;
            }, 100);
        },
        async _prepare() {
            if (this.ready)
                return;
            setInterval(() => (this.timepass = this.timepass + 1000), 1000);
            if (document.readyState !== "complete") {
                return new Promise((resolve) => setTimeout(async () => resolve(await this._prepare()), 100));
            }
            return await new Promise((resolve) => {
                let resolved = false;
                document.documentElement.scrollTo({ left: 0, top: 0 });
                setTimeout(async () => {
                    setTimeout(() => (resolved ? null : resolve()), 5000);
                    await helper.elements.scroll(document.documentElement, document.body.scrollHeight);
                    setTimeout(async () => {
                        await helper.elements.scroll(document.documentElement, 0);
                        resolved = this.ready = true;
                        return resolve();
                    }, 500);
                }, 1000);
            });
        },
        async _setRoleEquivalents($els) {
            $els = $els || document.body.querySelectorAll(allSelector);
            const roleMap = {
                link: ["a[href]", "area[href]"],
                article: ["article"],
                complementary: ["aside"],
                blockquote: ["blockquote"],
                button: [
                    "button",
                    "input[type=button]",
                    "input[type=image]",
                    "input[type=reset]",
                    "input[type=submit]",
                    "summary",
                ],
                caption: ["caption"],
                code: ["code"],
                listbox: ["datalist", "select[multiple]", "select[size]"],
                deletion: ["del", "s"],
                group: ["details", "fieldset", "optgroup"],
                term: ["dfn"],
                dialog: ["dialog"],
                emphasis: ["em"],
                figure: ["figure"],
                contentinfo: ["footer"],
                generic: ["div", "span"],
                form: ["form"],
                banner: ["header"],
                separator: ["hr"],
                document: ["html"],
                img: ["img[alt]:not([alt=''])", "img:not([alt])"],
                presentation: ["img[alt='']"],
                checkbox: ["input[type=checkbox]"],
                // @TODO: handle [list] inputs
                textbox: [
                    "input[type=email]",
                    "input[type=tel]",
                    "input[type=text]",
                    "input:not([type])",
                    "input[type=url]",
                    "textarea",
                ],
                spinbutton: ["input[type=number]"],
                radio: ["input[type=radio]"],
                slider: ["input[type=range]"],
                searchbox: ["input[type=search]"],
                insertion: ["ins"],
                listitem: ["li"],
                main: ["main"],
                math: ["math"],
                list: ["menu", "ol", "ul"],
                meter: ["meter"],
                navigation: ["nav"],
                option: ["option"],
                status: ["output"],
                paragraph: ["p"],
                progressbar: ["progress"],
                search: ["search"],
                region: ["section[aria-label]", "section[aria-labelledby]"],
                combobox: ["select:not([multiple]):not([size])"],
                strong: ["strong"],
                subscript: ["sub"],
                superscript: ["sup"],
                table: ["table"],
                rowgroup: ["tbody", "tfoot", "thead"],
                time: ["time"],
                row: ["tr"],
                heading: ["h1", "h2", "h3", "h4", "h5", "h6"],
            };
            for (const role in roleMap) {
                const selector = `[role=${role}], ${roleMap[role]
                .map((a) => `${a}:not([role])`)
                .join(", ")}`;
                const found = [...$els].filter(($el) => $el.matches(selector));
                found.forEach(($el) => {
                    $el.setAttribute("data-aflw-role", role);
                });
            }
            [...$els].forEach(($el) => {
                if ($el.getAttribute("data-aflw-role")) {
                    return;
                }
                const role = $el.getAttribute("role");
                if (role) {
                    $el.setAttribute("data-aflw-role", role);
                }
            });
            const cellsOnly = {
                columnheader: ["[data-aflw-role=table] th"],
                cell: ["[data-aflw-role=table] td"],
                gridcell: [
                    "[data-aflw-role=grid] th",
                    "[data-aflw-role=treegrid] th",
                    "[data-aflw-role=grid] td",
                    "[data-aflw-role=treegrid] td",
                ],
            };
            for (const role in cellsOnly) {
                const selector = `${cellsOnly[role]
                .map((a) => `${a}:not([data-aflw-role])`)
                .join(", ")}`;
                const found = [...$els].filter(($el) => $el.matches(selector));
                found.forEach(($el) => {
                    $el.setAttribute("data-aflw-role", role);
                });
            }
            const noRoleSelector = `*:not([data-aflw-role]):is(a, img, section, area, th, td)`;
            const found = [...$els].filter(($el) => $el.matches(noRoleSelector));
            found.forEach(($el) => {
                $el.setAttribute("data-aflw-no-role", "true");
            });
            const roleGroups = {
                input: [
                    "[data-aflw-role=textbox]",
                    "[data-aflw-role=checkbox]",
                    "[data-aflw-role=radio]",
                    "[data-aflw-role=combobox]",
                    "[data-aflw-role=spinbutton]",
                    "[data-aflw-role=slider]",
                    "[data-aflw-role=searchbox]",
                    "[data-aflw-role=listbox]",
                    "input[type]:not([type=hidden], [type=button], [type=image], [type=reset], [type=submit], [role])",
                ],
                table: ["[data-aflw-role=table]", "[data-aflw-role=grid]", "[data-aflw-role=treegrid]"],
                cell: [
                    "[data-aflw-role=rowheader]",
                    "[data-aflw-role=columnheader]",
                    "[data-aflw-role=cell]",
                    "[data-aflw-role=gridcell]",
                ],
                formatting: [
                    "[data-aflw-role=strong]",
                    "[data-aflw-role=subscript]",
                    "[data-aflw-role=superscript]",
                    "[data-aflw-role=deletion]",
                    "[data-aflw-role=insertion]",
                    "[data-aflw-role=emphasis]",
                    "strike",
                    "b",
                    "i",
                    "u",
                ],
                img: [
                    "img:not([role])",
                    "[role=img]",
                    "svg:not([role])",
                    "img[role=presentation]",
                    "svg[role=presentation]",
                ],
                section: ["section:not([role])", "[data-aflw-role=region]"],
                landmark: [
                    "[data-aflw-role=complementary]",
                    "[data-aflw-role=contentinfo]",
                    "[data-aflw-role=main]",
                    "[data-aflw-role=navigation]",
                    "[data-aflw-role=region]",
                    "[data-aflw-role=search]",
                    "[data-aflw-role=banner]",
                    "[data-aflw-role=form]",
                ],
            };
            for (const role in roleGroups) {
                const selector = `${roleGroups[role].join(", ")}`;
                const found = [...$els].filter(($el) => $el.matches(selector));
                found.forEach(($el) => {
                    $el.setAttribute(`data-aflw-group-${role}`, "true");
                });
            }
            [...$els]
                .filter(($el) => $el.matches("[data-aflw-role=rowheader], [data-aflw-role=columnheader]"))
                .forEach(($el) => {
                $el.setAttribute("data-aflw-table-header", "true");
            });
            [...$els]
                .filter(($el) => $el.matches("textarea:not([role]), [role=textbox][aria-multiline=true]"))
                .forEach(($el) => {
                $el.setAttribute("data-aflw-textarea", "true");
            });
        },
        _setSrOnly() {
            const selectors = [
                ".sr-only",
                ".sronly",
                ".sr-text",
                ".srtext",
                ".show-for-sr",
                ".text-for-sr",
                ".visually-hidden",
                ".screen-reader",
                ".screen-reader-only",
                ".screen-reader-text",
                ".screen-reader-only-text",
                ".elementor-screen-only",
                "[data-acsb-sr-only]",
                "[data-aflw-sr-only]",
            ];
            for (const $el of document.querySelectorAll([
                "[data-aflw-role=generic]",
                "[data-aflw-role=link]",
                "[data-aflw-group-formatting]",
                "[data-aflw-role=paragraph]",
                "label",
            ]
                .map((tag) => `${tag}[data-aflw-hidden="true"]`)
                .join(","))) {
                if (helper.isElementAudited($el, "aflwSrOnlyChecked") ||
                    $el.closest("[data-acsb], [data-aflw-sr-only]") ||
                    (!helper.elements.getText($el) && !$el.getAttribute("aria-label")) ||
                    helper.elements.getStyle($el, "background-image") !== "none") {
                    continue;
                }
                helper.checkElementAudited($el, "aflwSrOnlyChecked");
                if ($el.matches(selectors.join(","))) {
                    $el.setAttribute("data-aflw-sr-only", "true");
                    continue;
                }
                if ($el.getAttribute("data-acsb-force-hidden") === "true" ||
                    $el.getAttribute("data-aflw-clickable") === "true" ||
                    $el.getAttribute("data-aflw-hidden") !== "true") {
                    continue;
                }
                let spansOnly = true;
                const $children = $el.querySelectorAll(allSelector);
                for (const $child of $children) {
                    if ($child.tagName !== "SPAN" || $child.getAttribute("data-aflw-clickable") === "true") {
                        spansOnly = false;
                        break;
                    }
                }
                if ($children.length > 0 && !spansOnly)
                    continue;
                $el.setAttribute("data-aflw-sr-only", "true");
            }
            for (const $el of document.querySelectorAll(selectors.join(","))) {
                if ($el.closest("[data-aflw-sr-hidden]"))
                    continue;
                $el.setAttribute("data-aflw-sr-only", "true");
            }
        },
        _setTextualType() {
            for (const $el of document.body.querySelectorAll("[data-aflw-role=form]")) {
                if (helper.isElementAudited($el, "aflwTextualTypeChecked") ||
                    $el.closest('[data-aflw-hidden="true"]'))
                    continue;
                helper.checkElementAudited($el, "aflwTextualTypeChecked");
                for (const $el of document.querySelectorAll("[data-aflw-group-input]")) {
                    const textualType = this.textualType.getType($el);
                    if (textualType)
                        $el.setAttribute("data-aflw-textual-type", textualType);
                }
            }
        },
        _setFooterLandmark() {
            let $footer;
            for (const $el of document.querySelectorAll("[data-aflw-role=contentinfo]")) {
                if (helper.isElementAudited($el, "aflwFooterLandmarkChecked") ||
                    $el.closest('[data-aflw-hidden="true"]'))
                    continue;
                helper.checkElementAudited($el, "aflwFooterLandmarkChecked");
                // @TODO make this check more robust
                if ($el.outerHTML.trim().length > 100 && !$el.closest('[data-aflw-hidden="true"]'))
                    $footer = $el;
            }
            if (!$footer) {
                const $candidates = [];
                // @TODO: duplicates
                const selectors = [
                    'div[class*="footer" i]',
                    'div[class*="footer" i]',
                    'div[id*="footer" i]',
                    'div[id*="footer" i]',
                    '[data-aflw-group-section][class*="footer" i]',
                    '[data-aflw-group-section][class*="footer" i]',
                    '[data-aflw-group-section][id*="footer" i]',
                    '[data-aflw-group-section][id*="footer" i]',
                ];
                for (const $el of document.querySelectorAll(selectors.join(","))) {
                    if (helper.checkElementAudited($el, "aflwFooterLandmarkChecked"))
                        continue;
                    if ($el.closest("[data-acsb]") ||
                        $el.querySelector("[data-aflw-main]") ||
                        $el.querySelectorAll("a, p, ul").length < 5 ||
                        helper.elements.getOffsets($el).top <= window.innerHeight) {
                        continue;
                    }
                    let footerCandidate = true;
                    for (const $candidate of $candidates) {
                        if (!$candidate.contains($el))
                            continue;
                        footerCandidate = false;
                        break;
                    }
                    if (footerCandidate)
                        $candidates.push($el);
                }
                $footer = $candidates.pop();
            }
            if ($footer)
                $footer.setAttribute("data-aflw-footer", "true");
        },
        _setSkipLinks() {
            for (const $el of document.querySelectorAll("[data-aflw-role=link]")) {
                if (helper.isElementAudited($el, "aflwSkipLinksChecked") ||
                    $el.closest('[data-aflw-hidden="true"] ,[data-aflw-sr-hidden=true]'))
                    continue;
                helper.checkElementAudited($el, "aflwSkipLinksChecked");
                if (!helper.elements.getText($el).toLowerCase().includes("skip"))
                    continue;
                let inFixed = helper.elements.getStyle($el, "position") === "fixed";
                if (!inFixed) {
                    let $parent = $el.parentElement;
                    while ($parent) {
                        if (inFixed || ["BODY", "HTML", "HEAD"].includes($parent.tagName)) {
                            $parent = null;
                            break;
                        }
                        inFixed = helper.elements.getStyle($parent, "position") === "fixed";
                        $parent = $parent.parentElement;
                    }
                }
                if (!inFixed)
                    continue;
                $el.setAttribute("data-aflw-sr-only", "true");
                $el.setAttribute("data-aflw-skip-link", "true");
            }
        },
        _setMainLandmark() {
            const $main = [...document.querySelectorAll("[data-aflw-role=main]")];
            if ($main.length === 1 && !$main[0].closest('[data-aflw-hidden="true"]'))
                return $main[0].setAttribute("data-aflw-main", "true");
            let $heading;
            let $result;
            let $els = [];
            for (const selector of [
                "h1",
                "h2",
                '[role="heading"][aria-level="2"]',
                "h3",
                '[role="heading"][aria-level="3"]',
                "h4",
                '[role="heading"][aria-level="4"]',
            ]) {
                $els = [...$els, ...Array.from(document.querySelectorAll(selector))];
            }
            for (const $el of $els) {
                if (helper.isElementAudited($el, "aflwMainLandmarkChecked") ||
                    $el.closest('[data-aflw-hidden="true"]'))
                    continue;
                helper.checkElementAudited($el, "aflwMainLandmarkChecked");
                if (!helper.elements.getText($el, "visible") ||
                    $el.closest("[data-acsb], [data-aflw-sr-only], [data-aflw-nav], [data-aflw-footer]")) {
                    continue;
                }
                $heading = $el;
                break;
            }
            if ($heading) {
                let $parent = $heading.parentElement;
                const headingText = helper.elements.getText($heading);
                while ($parent && $parent.tagName !== "BODY") {
                    const trimmed = $parent.outerHTML.trim().replace(/data-aflw-[-\w]+="[^"]+"/g, "");
                    if (headingText !== helper.elements.getText($parent) && trimmed.length > 100) {
                        $result = $parent;
                        break;
                    }
                    $parent = $parent.parentElement;
                }
            }
            if (!$result) {
                for (const $el of document.querySelectorAll("[data-aflw-role=paragraph]")) {
                    if (helper.isElementAudited($el, "aflwMainLandmarkChecked") ||
                        $el.closest('[data-aflw-hidden="true"]'))
                        continue;
                    helper.checkElementAudited($el, "aflwMainLandmarkChecked");
                    if ($el.closest("[data-acsb]"))
                        continue;
                    $result = $el;
                    break;
                }
            }
            if (!$result) {
                for (const $el of document.querySelectorAll("[data-aflw-role=link]")) {
                    if (helper.isElementAudited($el, "aflwMainLandmarkChecked") ||
                        $el.closest('[data-aflw-hidden="true"]'))
                        continue;
                    helper.checkElementAudited($el, "aflwMainLandmarkChecked");
                    if ($el.closest("[data-acsb]"))
                        continue;
                    $result = $el;
                    break;
                }
            }
            if ($result)
                $result.setAttribute("data-aflw-main", "true");
        },
        _setCarousels() {
            const selectors = [
                "[data-acsb-carousel]",
                "[data-aflw-carousel]",
                '[each="cards"]',
                ".owl-carousel",
                ".slick-slider",
                ".jcarousel",
                ".rslides",
                ".nivoSlider",
                ".fusion-carousel",
                ".flexslider",
                ".uk-slideshow",
                ".cycle-slideshow",
                ".et_pb_slider",
                ".q_slider",
                ".bxslider",
                ".flickity-enabled",
                ".bx-viewport",
                ".rev_slider_wrapper",
                ".rev_slider",
                ".ls-container",
                "[data-ride]",
                ".swiper-container",
                ".yotpo-reviews-carousel",
                '[data-creator="Smart Slider 3"]',
                '[id="cycler"]',
                ".bootslider",
                ".n2-ss-slider",
                ".n2-ow",
                /*the generic ones must be last so they aren't picked up first*/
                ".carousel",
                ".slider",
                '[class*="carousel" i]',
                '[class*="slider" i]',
                '[class*="slides" i]',
                '[class*="slideshow" i]',
                '[id*="carousel" i]',
                '[id*="slider" i]',
                '[id*="slides" i]',
                '[id*="slideshow" i]',
            ];
            for (const $el of document.body.querySelectorAll(selectors.join(","))) {
                if (helper.isElementAudited($el, "aflwCarouselChecked") ||
                    $el.closest('[data-aflw-hidden="true"]'))
                    continue;
                helper.checkElementAudited($el, "aflwCarouselChecked");
                if (!$el.matches("[data-aflw-role=list], div, [data-aflw-group-section]") ||
                    $el.closest("[data-aflw-carousel]") ||
                    !$el.querySelector('[data-aflw-hidden="true"]') ||
                    $el.querySelector("[data-aflw-carousel], [data-aflw-nav]") ||
                    (!helper.elements.getText($el) &&
                        !$el.querySelector("[data-aflw-group-img], [data-aflw-role=link], [data-aflw-clickable]"))) {
                    continue;
                }
                $el.setAttribute("data-aflw-carousel", "true");
            }
        },
        _setNavigations() {
            const setCMSNav = () => {
                for (const $el of document.querySelectorAll(".Header-nav, #SITE_HEADER nav")) {
                    if (helper.isElementAudited($el, "aflwCheckedCMSNavigation") ||
                        $el.closest('[data-aflw-hidden="true"]'))
                        continue;
                    helper.checkElementAudited($el, "aflwCheckedCMSNavigation");
                    $el.setAttribute("data-aflw-nav", "true");
                }
            };
            const setListNav = () => {
                for (const $el of document.querySelectorAll("[data-aflw-role=list], [data-aflw-nav-ul]")) {
                    if (helper.isElementAudited($el, "aflwCheckedListNavigation") ||
                        $el.closest('[data-aflw-hidden="true"]'))
                        continue;
                    helper.checkElementAudited($el, "aflwCheckedListNavigation");
                    if (!this.__isListMenu($el))
                        continue;
                    let $nav = $el.parentElement?.tagName === "BODY" ? $el : $el.parentElement;
                    $nav =
                        $el.closest("[data-aflw-fake-menu]") ||
                            $el.querySelector("[data-aflw-fake-menu]") ||
                            $nav;
                    for (const $inner of $nav?.querySelectorAll("h1, h2, [data-aflw-role=form], [data-aflw-role=navigation], [data-aflw-group-table], [data-aflw-role=list], [data-aflw-nav]") || []) {
                        if ($inner.closest('[data-aflw-hidden="true"]') || $inner === $el || $el.contains($inner))
                            continue;
                        $nav = $el.closest("[data-aflw-role=navigation], [data-aflw-fake-menu]") || $el;
                        break;
                    }
                    $nav?.setAttribute("data-aflw-nav", "true");
                    for (const $li of helper.elements.filterHiddens($el.querySelectorAll("[data-aflw-role=listitem], [data-aflw-nav-li]"))) {
                        if ($li.parentElement?.closest("[data-aflw-role=listitem], [data-aflw-nav-li]"))
                            continue;
                        $li.setAttribute("data-aflw-nav-root", "true");
                        let $item;
                        for (const $inner of helper.elements.filterHiddens($li.querySelectorAll("[data-aflw-navigable]"))) {
                            if (!$el.matches("span, [data-aflw-role=link], [data-aflw-role=button]") ||
                                !helper.elements.getText($inner, "visible")) {
                                continue;
                            }
                            $item = $inner;
                            break;
                        }
                        if (!$item) {
                            const liText = helper.elements.getText($li, "visible");
                            for (const $inner of helper.elements.filterHiddens($li.querySelectorAll(allSelector))) {
                                if (!liText.includes(helper.elements.getText($inner, "visible")))
                                    continue;
                                $item = $inner;
                                break;
                            }
                        }
                        if (!$item)
                            continue;
                        let $dropdown;
                        $item.setAttribute("data-aflw-nav-root-link", "true");
                        for (const $el of $li.querySelectorAll('[data-aflw-hidden="true"]')) {
                            if ($el.closest("[data-aflw-nav-dd]") ||
                                !$el.matches("[data-aflw-role=generic], [data-aflw-role=list], [data-aflw-role=navigation], [data-aflw-group-section]") ||
                                !$el.querySelector("[data-aflw-clickable], [data-aflw-role=form], [data-aflw-group-input], iframe")) {
                                continue;
                            }
                            $dropdown = $el;
                            break;
                        }
                        if (!$dropdown &&
                            $li.matches("[data-aflw-role=listitem]") &&
                            $li.nextElementSibling &&
                            !$li.nextElementSibling.matches("[data-aflw-role=listitem]") &&
                            !$li.nextElementSibling.closest('[data-aflw-hidden="true"], [data-aflw-nav-dd]') &&
                            $li.nextElementSibling.querySelector("[data-aflw-role=link], [data-aflw-role=form], [data-aflw-group-input], iframe, [role=button]") &&
                            $li.nextElementSibling.matches("[data-aflw-role=list], [data-aflw-role=navigation], [data-aflw-role=generic], [data-aflw-group-section]")) {
                            $dropdown = $li.nextElementSibling;
                        }
                        if (!$dropdown)
                            continue;
                        $dropdown.setAttribute("data-aflw-nav-dd", "true");
                        $item.setAttribute("data-aflw-nav-dd-trigger", "true");
                    }
                }
            };
            const setFakeNav = () => {
                for (const $el of document.querySelectorAll("[data-aflw-role=navigation], div, [data-aflw-role=banner]")) {
                    if (helper.isElementAudited($el, "aflwCheckedFakeNavigation") ||
                        $el.closest('[data-aflw-hidden="true"]'))
                        continue;
                    helper.checkElementAudited($el, "aflwCheckedFakeNavigation");
                    if ($el.closest("[data-acsb], [data-aflw-nav]"))
                        continue;
                    const $fakeNav = this.__getFakeNav($el);
                    // @TODO dead code - _getFakeNav will always return null
                    if (!$fakeNav)
                        continue;
                    /* istanbul ignore next */
                    {
                        const $navLinks = helper.elements
                            .filterHiddens($fakeNav.querySelectorAll("[data-aflw-clickable][data-aflw-navigable]"))
                            .filter(($el) => helper.elements.getText($el, "visible"));
                        $fakeNav.setAttribute("data-aflw-fake-nav", "true");
                        $fakeNav.setAttribute("data-aflw-nav-ul", "true");
                        for (const $el of $navLinks)
                            $el.setAttribute("data-aflw-nav-a", "true");
                        for (const $link of $navLinks) {
                            let $parent = $link.parentElement;
                            let $candidate;
                            while ($parent) {
                                if ($parent.querySelectorAll("[data-aflw-nav-a]").length > 1) {
                                    $parent = null;
                                    break;
                                }
                                $candidate = $parent;
                                $parent = $parent.parentElement;
                            }
                            if ($candidate)
                                $candidate.setAttribute("data-aflw-nav-li", "true");
                        }
                    }
                }
                setListNav();
            };
            setCMSNav();
            setListNav();
            setFakeNav();
        },
        _setNavigationLabels() {
            let $mainNav = null;
            let navCount = 0;
            for (const $el of document.querySelectorAll("[data-aflw-nav]:not([data-aflw-nav-type])")) {
                if (helper.isElementAudited($el, "aflwMainNavLabelsChecked") ||
                    $el.closest('[data-aflw-hidden="true"]'))
                    continue;
                helper.checkElementAudited($el, "aflwMainNavLabelsChecked");
                const $clickables = helper.elements.filterHiddens($el.querySelectorAll("[data-aflw-clickable]"));
                if ($el.closest("[data-acsb]") ||
                    $clickables.length < 1 ||
                    helper.elements.getOffsets($el, true).top > 350) {
                    continue;
                }
                if ($clickables.length <= navCount)
                    continue;
                $mainNav = $el;
                navCount = $clickables.length;
            }
            if ($mainNav)
                $mainNav.setAttribute("data-aflw-nav-type", "main");
            const $footer = document.querySelector("[data-aflw-footer]");
            if ($footer) {
                const headings = 'h2, h3, h4, h5, h6, [role="heading"]';
                for (const $el of $footer.querySelectorAll("[data-aflw-nav]")) {
                    if (helper.isElementAudited($el, "aflwFooterNavLabelsChecked") ||
                        $el.closest('[data-aflw-hidden="true"]'))
                        continue;
                    helper.checkElementAudited($el, "aflwFooterNavLabelsChecked");
                    if ($el.getAttribute("aria-label") || $el === $mainNav)
                        continue;
                    let type = null;
                    const $firstLi = $el.querySelector("[data-aflw-role=listitem]");
                    if ($el.querySelector("[data-aflw-nav-ul]") && !$el.matches("[data-aflw-nav-ul]")) {
                        type = helper.elements.getText($el, "visible", true, ["[data-aflw-nav-ul]"]);
                    }
                    if (!type &&
                        $el.previousElementSibling &&
                        $el.previousElementSibling.matches(`${headings}, b, [data-aflw-role=strong], [data-aflw-role=paragraph], span`)) {
                        const text = helper.elements.getText($el.previousElementSibling);
                        const words = text.split(" ");
                        if (text.length > 1 && words.length > 0 && words.length <= 3)
                            type = text;
                    }
                    if (!type && $firstLi && !$firstLi.querySelector("[data-aflw-clickable]")) {
                        const firstLiText = helper.elements.getText($firstLi, "visible");
                        if (firstLiText.length > 0)
                            type = firstLiText;
                    }
                    if (!type) {
                        const $visibleEls = [];
                        for (const $heading of $el.querySelectorAll(headings)) {
                            if ($visibleEls.length > 0) {
                                type = null;
                                break;
                            }
                            if (!$heading.closest('[data-aflw-hidden="true"]')) {
                                type = helper.elements.getText($heading);
                                $visibleEls.push($heading);
                            }
                        }
                    }
                    if (!type)
                        type = helper.elements.getTextNodesText($el);
                    if (!type)
                        type = "footer";
                    $el.setAttribute("data-aflw-nav-type", type);
                }
            }
            const $header = document.querySelector("[data-aflw-role=banner]");
            if ($header) {
                for (const $el of $header.querySelectorAll("[data-aflw-nav]:not([data-aflw-nav-type])")) {
                    if ($el !== $mainNav)
                        $el.setAttribute("data-aflw-nav-type", "header");
                }
            }
            for (const $el of document.querySelectorAll("[data-aflw-nav]:not([data-aflw-nav-type])")) {
                if (helper.isElementAudited($el, "aflwHeaderNavLabelsChecked") ||
                    $el.closest('[data-aflw-hidden="true"]'))
                    continue;
                helper.checkElementAudited($el, "aflwHeaderNavLabelsChecked");
                if ($el !== $mainNav)
                    $el.setAttribute("data-aflw-nav-type", "page");
            }
            for (const $el of document.querySelectorAll('body [class*="breadc" i]')) {
                if (helper.isElementAudited($el, "aflwBreadcrumbsNavLabelsChecked") ||
                    $el.closest('[data-aflw-hidden="true"]'))
                    continue;
                helper.checkElementAudited($el, "aflwBreadcrumbsNavLabelsChecked");
                if (!$el.matches("[data-aflw-role=generic], [data-aflw-role=list], [data-aflw-role=navigation]") ||
                    $el.querySelectorAll("[data-aflw-role=link]").length < 2) {
                    continue;
                }
                let $nav = $el.closest("[data-aflw-nav]");
                if (!$nav) {
                    $nav = $el.querySelector("[data-aflw-nav]");
                    $nav = $nav ? $nav : $el;
                }
                $nav.setAttribute("data-aflw-nav-type", "breadcrumbs");
            }
        },
        _setLinkPresets($els) {
            $els = $els || document.body.querySelectorAll("a[href]");
            const pagePresets = {
                feed: ["rss"],
                search: ["find"],
                favorites: ["wishlist", "saves"],
                contact: ["quote", "offer", "proposal"],
                cart: ["basket", "basket", "bag", "checkout"],
                locations: ["stores", "locator", "locate", "shops"],
                account: [
                    "register",
                    "join",
                    "signup",
                    "profile",
                    "sign-up",
                    "login",
                    "log-in",
                    "sign up",
                    "log in",
                ],
            };
            const socialPresets = {
                "facebook.com": "facebook",
                "yahoo.com": "yahoo",
                "yandex.com": "yandex",
                "xing.com": "xing",
                "medium.com": "medium",
                "linkedin.com": "linkedin",
                "dribbble.com": "dribbble",
                "waze.com": "waze",
                "github.com": "github",
                "snapchat.com": "snapchat",
                "instagram.com": "instagram",
                "twitter.com": "twitter",
                "tripadvisor.com": "trip advisor",
                "yelp.com": "yelp",
                "tiktok.com": "tiktok",
                "whatsapp.com": "whatsapp",
                "whatsapp://": "whatsapp",
                "youtube.com": "youtube",
                "reddit.com": "reddit",
                "tumblr.com": "tumblr",
                "flickr.com": "flickr",
                "pinterest.com": "pinterest",
                "maps.google.com": "google maps",
            };
            for (const $el of $els) {
                if (helper.isElementAudited($el, "aflwLinkPresetChecked") ||
                    $el.closest('[data-aflw-hidden="true"]'))
                    continue;
                helper.checkElementAudited($el, "aflwLinkPresetChecked");
                if ($el.closest("[data-acsb], [data-aflw-button]") || !$el.matches("a[href]"))
                    continue;
                const href = $el.getAttribute("href");
                if (!href)
                    continue;
                let preset = "";
                const searchHref = href
                    .replace(window.location.hostname.replace("www", ""), "")
                    .toLowerCase()
                    .split("?")[0]
                    .split("#")[0];
                if ($el.href === document.location.origin ||
                    $el.href.substring(0, $el.href.length - 1) === document.location.origin) {
                    preset = "home";
                }
                if (!preset) {
                    if (href.includes(".pdf")) {
                        preset = "pdf";
                    }
                    else if (href.includes("mailto:")) {
                        preset = "email";
                    }
                    else if (href.includes("tel:")) {
                        preset = "phone";
                    }
                }
                if (!preset) {
                    for (const v of ["png", "jpg", "jpeg", "webp", "gif", "svg"]) {
                        if (!href.includes(`.${v}`))
                            continue;
                        preset = "image";
                        break;
                    }
                }
                if (!preset) {
                    for (const k in socialPresets) {
                        if (!searchHref.includes(k))
                            continue;
                        preset = socialPresets[k];
                        break;
                    }
                }
                if (!preset && searchHref.match(/users?$/)) {
                    preset = "user";
                    break;
                }
                if (!preset) {
                    for (const k in pagePresets) {
                        const words = [k, ...pagePresets[k]];
                        for (const k2 of words) {
                            const reg = new RegExp(`\\b${k2}s?\\b`, "i");
                            if (!reg.test(searchHref))
                                continue;
                            let part = searchHref.substring(searchHref.indexOf(k2), searchHref.length);
                            if (part.substr(-1) === "/")
                                part = part.substr(0, part.length - 1);
                            if (part.includes("/"))
                                continue;
                            preset = k2;
                            break;
                        }
                    }
                }
                if (preset)
                    $el.setAttribute("data-aflw-link-preset", preset);
            }
        },
        _setVisibility($els) {
            $els = $els || document.body.querySelectorAll(allSelector);
            for (const $el of $els) {
                if ($el.parentElement?.closest('[data-aflw-hidden="true"]') ||
                    helper.skipTags.includes($el.tagName)) {
                    continue;
                }
                // SVG elements are exceptional, we mark them with [data-aflw-hidden] while they are not hidden
                const visible = helper.elements.isVisible($el);
                if ($el.getAttribute("data-aflw-hidden")) {
                    $el.setAttribute("data-aflw-hidden", String(!visible));
                }
                else if (!visible) {
                    $el.setAttribute("data-aflw-hidden", "true");
                }
            }
        },
        _setSrVisibility($els) {
            $els = $els || document.body.querySelectorAll(allSelector);
            for (const $el of $els) {
                let isHidden = false;
                if ($el.matches("[aria-hidden=true], [hidden]")) {
                    isHidden = true;
                }
                else {
                    const display = helper.elements.getStyle($el, "display");
                    const visibility = helper.elements.getStyle($el, "visibility");
                    isHidden =
                        display === "none" ||
                            visibility === "hidden" ||
                            $el.offsetHeight === 0 ||
                            $el.offsetWidth === 0;
                }
                if (isHidden) {
                    $el.setAttribute("data-aflw-sr-hidden", "true");
                }
            }
        },
        // Elements that are links, buttons, or cursor: pointer (marked as aflw-clickable), and
        // clickables that are buttons (marked as aflw-button) that are links with button-like href, or
        // not images larger than 50px, or elements not larger than window, and dont contain forms, inputs,
        // nav, or iframe, or are labels that are not inside forms
        _setClickability($els) {
            $els = $els || document.body.querySelectorAll(allSelector);
            for (const $el of $els) {
                if (helper.isElementAudited($el, "aflwClickabilityChecked") ||
                    $el.closest('[data-aflw-hidden="true"]'))
                    continue;
                helper.checkElementAudited($el, "aflwClickabilityChecked");
                if ($el.closest("[data-aflw-clickable]") ||
                    helper.skipTags.includes($el.tagName) ||
                    !helper.elements.isClickable($el)) {
                    continue;
                }
                $el.setAttribute("data-aflw-clickable", "true");
                if ($el.offsetWidth >= window.innerWidth ||
                    $el.offsetHeight >= window.innerHeight ||
                    $el.parentElement?.closest("[data-aflw-role=link], [data-aflw-button]") ||
                    ($el.matches("[data-aflw-role=img]") && ($el.offsetWidth > 50 || $el.offsetHeight > 50)) ||
                    $el.querySelectorAll("[data-aflw-role=form], [data-aflw-group-input], iframe, [data-aflw-nav]").length > 0) {
                    continue;
                }
                let isButton = false;
                if (!$el.getAttribute("data-aflw-skip-link")) {
                    isButton = helper.elements.isButton($el);
                    if ($el.tagName === "A") {
                        try {
                            const href = $el.getAttribute("href");
                            if (!href || href.substr(0, 10).toLowerCase() === "javascript" || href === "#")
                                isButton = true;
                            if (!isButton && href && href.substring(0, 1) === "#" && !document.querySelector(href))
                                isButton = true;
                        }
                        catch (err) { }
                    }
                    if (!isButton &&
                        $el.matches("[data-aflw-role=button], [data-aflw-role=generic], [data-aflw-group-img], [data-aflw-role=listitem], [data-aflw-role=article], i"))
                        isButton = true;
                    if (!isButton && $el.tagName === "LABEL" && !$el.closest("[data-aflw-role=form]"))
                        isButton = true;
                }
                if (isButton)
                    $el.setAttribute("data-aflw-button", "true");
            }
        },
        // See isNavigable() for more details
        _setNavigability($els) {
            $els = $els || document.body.querySelectorAll(allSelector);
            for (const $el of $els) {
                if (helper.isElementAudited($el, "aflwNavigabilityChecked") ||
                    $el.closest('[data-aflw-hidden="true"]'))
                    continue;
                helper.checkElementAudited($el, "aflwNavigabilityChecked");
                if ($el.closest("[data-aflw-navigable]") ||
                    helper.skipTags.includes($el.tagName) ||
                    !helper.elements.isNavigable($el)) {
                    continue;
                }
                $el.setAttribute("data-aflw-navigable", "true");
            }
        },
        textualOpsProcessor: null,
        _setUntaggedHeading($els) {
            const selectors = '[data-aflw-group-formatting], [data-aflw-role=paragraph], [data-aflw-role=generic], [class*="title"], [class*="head"]';
            const badSelectors = [
                "h1",
                "h2",
                "h3",
                "h4",
                "h5",
                "h6",
                "[data-acsb]",
                "[data-aflw-group-table]",
                "[data-aflw-role=form]",
                "[data-aflw-role=button]",
                '[data-aflw-hidden="true"]',
                "[data-aflw-navigable]",
                "[data-aflw-clickable]",
                "[data-aflw-sr-only]",
            ].join(",");
            $els = $els || document.querySelectorAll(selectors);
            for (const $el of $els) {
                if (helper.isElementAudited($el, "aflwUntaggedHeadingChecked") ||
                    $el.closest('[data-aflw-hidden="true"]'))
                    continue;
                helper.checkElementAudited($el, "aflwUntaggedHeadingChecked");
                const text = helper.elements.getText($el);
                if (text.length > 160 ||
                    $el.closest(badSelectors) ||
                    !$el.matches(selectors) ||
                    $el.querySelector(badSelectors) ||
                    $el.parentElement?.closest("[data-aflw-untagged-heading]") ||
                    ($el.tagName === "LABEL" && !$el.closest("[data-aflw-role=form]"))) {
                    continue;
                }
                if (text.length <= 3 ||
                    parseInt(helper.elements.getStyle($el, "font-size").replace("px", "")) < 20 ||
                    text.split(" ").length > 20 ||
                    helper.strings.isNumber(text.replace(/[\W\-_.]/gm, ""))) {
                    continue;
                }
                const $p = $el.closest("[data-aflw-role=paragraph]");
                let oneLineP = false;
                if ($p) {
                    const pText = helper.elements.getText($p);
                    if (pText.length > 0 && $p.innerText.split("\n").length === 1)
                        oneLineP = true;
                    if (pText.length > text.length && !oneLineP)
                        continue;
                }
                if (text.length > 100 && !oneLineP)
                    continue;
                $el.setAttribute("data-aflw-untagged-heading", "true");
            }
        },
        _setTextualContext($els) {
            $els = $els || document.body.querySelectorAll(allSelector);
            for (const $el of $els) {
                if (helper.isElementAudited($el, "aflwTextualContext") ||
                    $el.closest('[data-aflw-hidden="true"]'))
                    continue;
                helper.checkElementAudited($el, "aflwTextualContext");
                if ($el.getAttribute("data-aflw-clickable") !== "true")
                    continue;
                let matches = {
                    close: {
                        occurs: {},
                        total: 0,
                        text: "CLOSE",
                        exacts: ["x", "×"],
                        strings: ["close", "dismiss", "hide", "cancel", "exit", "times"],
                    },
                    remove: {
                        occurs: {},
                        total: 0,
                        text: "REMOVE",
                        exacts: [],
                        strings: ["remove", "trash", "bin", "delete", "cross"],
                    },
                    next: {
                        occurs: {},
                        total: 0,
                        text: "NEXT",
                        exacts: [],
                        strings: ["next", "nxt", "arrow", "right"],
                    },
                    previous: {
                        occurs: {},
                        total: 0,
                        text: "PREVIOUS",
                        exacts: [],
                        strings: ["previous", "prev", "prv", "left"],
                    },
                    contact: {
                        occurs: {},
                        total: 0,
                        text: "CONTACT",
                        exacts: [],
                        strings: ["contact", "envelop", "mail", "phone"],
                    },
                    search: {
                        occurs: {},
                        total: 0,
                        text: "SEARCH",
                        exacts: [],
                        strings: ["search", "srch", "magnifier"],
                    },
                    cart: {
                        occurs: {},
                        total: 0,
                        text: "CART",
                        exacts: [],
                        strings: ["cart", "bag", "basket", "shop"],
                    },
                    menu: {
                        occurs: {},
                        total: 0,
                        text: "MENU",
                        exacts: [],
                        strings: ["burger", "menu", "nav", "bars", "lines"],
                    },
                    download: {
                        occurs: {},
                        total: 0,
                        text: "DOWNLOAD",
                        exacts: [],
                        strings: ["download"],
                    },
                    order: {
                        occurs: {},
                        total: 0,
                        text: "ORDER",
                        exacts: [],
                        strings: ["order"],
                    },
                    share: {
                        occurs: {},
                        total: 0,
                        text: "SHARE",
                        exacts: [],
                        strings: ["share"],
                    },
                    move: {
                        occurs: {},
                        total: 0,
                        text: "MOVE",
                        exacts: [],
                        strings: ["slide", "range", "move"],
                    },
                    checkmark: {
                        occurs: {},
                        total: 0,
                        text: "CHECKMARK",
                        exacts: [],
                        strings: ["check", "accept", "verify"],
                    },
                    account: {
                        occurs: {},
                        total: 0,
                        text: "ACCOUNT",
                        exacts: [],
                        strings: [
                            "login",
                            "log-in",
                            "signup",
                            "sign-up",
                            "register",
                            "user",
                            "account",
                            "profile",
                        ],
                    },
                    date: {
                        occurs: {},
                        total: 0,
                        text: "DATE",
                        exacts: [],
                        strings: ["date", "picker"],
                    },
                    address: {
                        occurs: {},
                        total: 0,
                        text: "ADDRESS",
                        exacts: [],
                        strings: ["pin", "address", "map", "location"],
                    },
                    subscribe: {
                        occurs: {},
                        total: 0,
                        text: "ADDRESS",
                        exacts: [],
                        strings: ["newsletter", "subscribe"],
                    },
                    favorites: {
                        occurs: {},
                        total: 0,
                        text: "FAVORITES",
                        exacts: [],
                        strings: ["wishlist", "favorite", "heart"],
                    },
                    enlarge: {
                        occurs: {},
                        total: 0,
                        text: "ENLARGE",
                        exacts: [],
                        strings: ["zoom", "large", "big"],
                    },
                    print: {
                        occurs: {},
                        total: 0,
                        text: "PRINT",
                        exacts: [],
                        strings: ["print"],
                    },
                    plus: {
                        occurs: {},
                        total: 0,
                        text: "PLUS",
                        exacts: ["+"],
                        strings: ["plus", "inc"],
                    },
                    minus: {
                        occurs: {},
                        total: 0,
                        text: "MINUS",
                        exacts: ["-"],
                        strings: ["min", "dec", "decrease", "reduce"],
                    },
                    video: {
                        occurs: {},
                        total: 0,
                        text: "VIDEO",
                        exacts: [],
                        strings: ["video", "play", "youtube", "vimeo"],
                    },
                    color: {
                        occurs: {},
                        total: 0,
                        exacts: [],
                        text: "COLOR",
                        strings: ["color", "colour", "swatch", "palette"],
                    },
                    pause: {
                        occurs: {},
                        total: 0,
                        text: "PAUSE",
                        exacts: [],
                        strings: ["pause", "stop", "halt", "hold"],
                    },
                    country: {
                        occurs: {},
                        total: 0,
                        text: "COUNTRY",
                        exacts: [],
                        strings: ["flag", "lang", "country", "usa", "english"],
                    },
                    scroll: {
                        occurs: {},
                        total: 0,
                        text: "SCROLL",
                        exacts: [],
                        strings: ["scroll", "up", "top"],
                    },
                };
                const html = (() => {
                    let res = helper.strings.removeChars($el.outerHTML.toLowerCase(), [
                        "data-acsb-navigable",
                        "data-acsb-now-navigable",
                        "data-acsb-menu-root-link",
                        "menuitem",
                        "pinterest",
                        "shipping",
                        "shopping",
                        "desktop",
                        "research",
                        "tabindex",
                        "backup",
                        "holder",
                        "group",
                        "setup",
                        "topic",
                        "stop",
                        "index",
                        "closed",
                        "bind",
                        "binary",
                        "binge",
                        "left:",
                        "right:",
                        "popup",
                        "upload",
                        "ping",
                        "pine",
                        "data-acsb-menu",
                        "prevent",
                        "display",
                        "player",
                    ]);
                    for (const $icon of $el.querySelectorAll("span, i")) {
                        res = `${res}${helper.elements.getText($icon)}`;
                    }
                    if ($el.closest('[data-acsb-menu="a"], [role="menuitem"]')) {
                        res = helper.strings.removeChars(res, ["nav", "menu"]);
                    }
                    const bgImage = helper.elements.getStyle($el, "background-image");
                    if (bgImage !== "none")
                        res = `${res} ${bgImage}`;
                    for (const obj of $el.attributes) {
                        if (obj.nodeName.substr(0, 9) !== "data-aflw")
                            continue;
                        res = res.replace(`${obj.nodeName}="${obj.nodeValue}"`, "");
                    }
                    return res
                        .replace(/  +/g, "")
                        .replace(location.hostname.replace("www", ""), "")
                        .toLowerCase();
                })();
                const text = helper.elements.getText($el).toLowerCase();
                if (typeof this.textualOpsProcessor !== "function") {
                    this.textualOpsProcessor = (type, texts, exacts, text, html, matches) => {
                        for (const v of exacts) {
                            if (text !== v)
                                continue;
                            matches[type].total = matches[type].total + 1;
                            matches[type].occurs[v] = 1;
                        }
                        for (const v of texts) {
                            matches[type].total = matches[type].total + helper.strings.getOccurrences(html, v);
                            matches[type].occurs[v] = helper.strings.getOccurrences(html, v);
                        }
                        return matches;
                    };
                }
                matches = this.textualOpsProcessor("close", matches.close.strings, matches.close.exacts, text, html, matches);
                if (matches.close.total < 1) {
                    for (const k in matches) {
                        matches = this.textualOpsProcessor(k, matches[k].strings, matches[k].exacts, text, html, matches);
                    }
                }
                let occurs = 0;
                let method = null;
                for (const k in matches) {
                    if (matches[k].total <= occurs)
                        continue;
                    occurs = matches[k].total;
                    method = k;
                }
                if (method)
                    $el.setAttribute("data-aflw-textual-context", method);
            }
        },
        _setActivePopups($els) {
            const selectors = "div, [data-aflw-role=navigation], [data-aflw-role=banner], [data-aflw-group-section], [data-aflw-role=dialog], [data-aflw-role=complementary], iframe";
            $els = $els || document.body.querySelectorAll(selectors);
            for (const $el of $els) {
                if (!$el.matches(selectors) ||
                    $el.closest('[data-acsb-hidden="true"], [data-aflw-nav-dd], [data-aflw-carousel], [data-aflw-popup], [data-acsb]')) {
                    continue;
                }
                if (!this.__isActivePopup($el))
                    continue;
                $el.setAttribute("data-aflw-popup", "true");
            }
        },
        __isListMenu($el) {
            if ($el.closest('[data-acsb], [data-aflw-hidden="true"], [data-aflw-carousel], [data-aflw-nav]'))
                return false;
            const $li = $el.querySelector("[data-aflw-role=listitem]");
            if (!$li)
                return false;
            if (helper.elements.getStyle($el, "display") === "flex" &&
                helper.elements.getStyle($li, "display") === "list-item" &&
                !helper.elements.getStyle($li, "list-style").includes("none")) {
                return false;
            }
            const $items = helper.elements.filterHiddens($el.querySelectorAll("[data-aflw-clickable]"));
            if ($items.length <= 1)
                return false;
            for (const $item of $items) {
                const $img = $item.querySelector("[data-aflw-group-img]");
                if ($img &&
                    $img.offsetWidth > 50 &&
                    $img.offsetHeight > 50 &&
                    helper.elements.isVisible($img))
                    return false;
                const shownText = helper.elements.getText($item, "visible");
                if (shownText.split(" ").length >= 7)
                    return false;
                const $badEl = $item.querySelector("[data-aflw-role=heading], [data-aflw-group-table], [data-aflw-role=form]");
                if ($badEl && helper.elements.isVisible($badEl))
                    return false;
            }
            const $parents = [];
            let $parent = $el.parentElement;
            const menuText = helper.elements.getText($el);
            while ($parent) {
                if ($parent.tagName === "BODY" || menuText !== helper.elements.getText($parent)) {
                    $parent = null;
                    break;
                }
                $parents.push($parent);
                $parent = $parent.parentElement;
            }
            for (const $parent of $parents) {
                if ($parent.matches('[data-aflw-role=navigation], [data-aflw-role=banner], [class*="nav" i], [class*="menu" i], [class*="header" i], [data-aflw-role=menu], [data-aflw-role="menubar"]')) {
                    return true;
                }
            }
            const $lis = helper.elements.filterHiddens($el.querySelectorAll("[data-aflw-role=listitem]"));
            if ($lis.length < 2)
                return false;
            const ulHTML = helper.elements.getHTML($el).toLowerCase();
            const parentHTML = helper.elements.getHTML($el.parentElement).toLowerCase();
            for (const keyword of ["menu", "nav"])
                if (ulHTML.includes(keyword) || parentHTML.includes(keyword))
                    return true;
            if ($items.length === $lis.length) {
                let noText = false;
                let badLis = false;
                for (const $link of $items) {
                    if (helper.elements.getText($link))
                        continue;
                    noText = true;
                    break;
                }
                if (!noText) {
                    for (const $li of $lis) {
                        const shownText = helper.elements.getText($li, "visible");
                        if (shownText.length > 50) {
                            badLis = true;
                            break;
                        }
                        let interactiveText = "";
                        for (const $child of $li.querySelectorAll('[data-aflw-clickable="true"]')) {
                            if ($child.closest("[data-aflw-hidden]"))
                                continue;
                            interactiveText = interactiveText + helper.elements.getText($child);
                        }
                        if (shownText.length > interactiveText.length &&
                            shownText.replace(interactiveText, "").length > interactiveText.length) {
                            badLis = true;
                            break;
                        }
                        if (helper.elements.getTextNodesText($li)) {
                            badLis = true;
                            break;
                        }
                        for (const $innerEl of $li.querySelectorAll("[data-aflw-role=paragraph], [data-aflw-group-img], [data-aflw-role=heading]")) {
                            if ($innerEl.closest('[data-aflw-hidden="true"]') ||
                                ($innerEl.matches("[data-aflw-group-img]") &&
                                    $innerEl.offsetWidth >= 75 &&
                                    $innerEl.offsetHeight >= 75)) {
                                continue;
                            }
                            badLis = true;
                            break;
                        }
                    }
                }
                if (!noText && !badLis)
                    return true;
            }
            return false;
        },
        __getFakeNav($el) {
            if ($el.offsetHeight > 100 ||
                !helper.elements.getText($el, "visible") ||
                !(["DIV"].includes($el.tagName) ||
                    $el.matches("[data-aflw-role=navigation], [data-aflw-role=banner]")) ||
                ($el.closest("[data-aflw-nav]") && $el.matches("[data-aflw-role=navigation]")) ||
                $el.closest('[data-acsb], [data-aflw-carousel], [data-aflw-fake-nav], [data-aflw-hidden="true"]') ||
                $el.querySelector("[data-aflw-role=banner], [data-aflw-nav], [data-aflw-carousel], [data-aflw-fake-nav]")) {
                return null;
            }
            let html = $el.outerHTML.toLowerCase();
            for (const word of [
                "-navigable",
                "-unnavigable",
                "acsb-menu",
                "navigate",
                "<nav",
                "<header",
                "nav/>",
                "header/>",
            ]) {
                html = html.replaceAll(word, "");
            }
            if (!html.includes("menu") && !html.includes("nav") && !html.includes("header"))
                return null;
            const hrefs = [];
            const $navLinks = helper.elements.filterHiddens($el.querySelectorAll("[data-aflw-clickable][data-aflw-navigable]"));
            if ($navLinks.length < 3)
                return null;
            for (const $link of $navLinks) {
                if (hrefs.includes($link.href))
                    return null;
                if ($link.href && $link.href.length > 0)
                    hrefs.push($link.href);
            }
            for (const $innerEl of $el.querySelectorAll("[data-aflw-group-img], iframe, [data-aflw-role=form], [data-aflw-role=heading]")) {
                if (!$innerEl.closest('[data-aflw-hidden="true"]'))
                    return null;
            }
            for (const $link of $navLinks) {
                let interactiveText = "";
                const shownText = helper.elements.getText($link, "visible");
                if (!shownText)
                    return null;
                // navLinks are clickables and you cannot have clickables inside clickables
                for (const $child of $link.querySelectorAll('[data-aflw-clickable="true"]')) {
                    if ($child.closest("[data-aflw-hidden]"))
                        continue;
                    interactiveText = interactiveText + helper.elements.getText($child);
                }
                // @TODO dead code from here on
                if (shownText.length > interactiveText.length &&
                    shownText.replace(interactiveText, "").length > interactiveText.length) {
                    return null;
                }
                /* istanbul ignore next */
                if (helper.elements.getTextNodesText($link))
                    return null;
                /* istanbul ignore next */
                for (const $innerEl of $link.querySelectorAll("[data-aflw-role=paragraph], [data-aflw-group-img], [data-aflw-role=heading]")) {
                    if ($innerEl.closest('[data-aflw-hidden="true"]') ||
                        ($innerEl.matches("[data-aflw-group-img]") &&
                            $innerEl.offsetWidth >= 75 &&
                            $innerEl.offsetHeight >= 75)) {
                        continue;
                    }
                    return null;
                }
            }
            /* istanbul ignore next */
            let $fakeNav = $navLinks[0].parentElement;
            /* istanbul ignore next */
            while ($fakeNav) {
                const $navigables = helper.elements.filterHiddens($fakeNav.querySelectorAll("[data-aflw-clickable][data-aflw-navigable]"));
                if ($navigables.length > 1)
                    break;
                $fakeNav = $fakeNav.parentElement;
            }
            /* istanbul ignore next */
            if ($fakeNav?.matches("[data-aflw-role=list]"))
                $fakeNav = $fakeNav?.parentElement || null;
            /* istanbul ignore next */
            for (const $node of $fakeNav?.childNodes || [])
                if ($node.nodeType === Node.TEXT_NODE)
                    return null;
            /* istanbul ignore next */
            if (!helper.elements.getText($fakeNav, "visible"))
                return null;
            /* istanbul ignore next */
            return $fakeNav;
        },
        __isActivePopup($el) {
            if ($el.closest('[data-acsb-hidden="true"], [data-acsb-overlay].acsb-active, [data-acsb]') ||
                document.body.scrollHeight <= $el.offsetHeight) {
                return false;
            }
            const position = helper.elements.getStyle($el, "position");
            const zIndex = helper.elements.getStyle($el, "z-index");
            if (parseInt(zIndex) < 1 ||
                helper.elements.getStyle($el, "pointer-events") === "none" ||
                !["fixed", "absolute"].includes(position) ||
                !helper.elements.isVisible($el)) {
                return false;
            }
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            const offsets = helper.elements.getOffsets($el, true);
            const widthPercent = Math.ceil(($el.offsetWidth * 100) / windowWidth);
            const heightPercent = Math.ceil(($el.offsetHeight * 100) / windowHeight);
            let $topElement = document.elementFromPoint(offsets.left, offsets.top);
            let middleBlocker = false;
            if ($el !== $topElement && !$el.contains($topElement)) {
                $topElement = document.elementFromPoint(offsets.left + 50, offsets.top + 50);
            }
            if (widthPercent < 70 && heightPercent < 70) {
                if (position === "fixed") {
                    const $elFromCenter = document.elementFromPoint(windowWidth / 2, windowHeight / 2);
                    if ($elFromCenter === $topElement || $el.contains($elFromCenter))
                        middleBlocker = true;
                }
                if (!middleBlocker)
                    return false;
            }
            let overlayType = null;
            let fixedParallax = false;
            const childrenCount = $el.querySelectorAll(allSelector).length;
            (() => {
                if (!helper.dynamic &&
                    position === "absolute" &&
                    $el.querySelector("[data-aflw-nav]") &&
                    ($el.offsetHeight >= windowHeight || $el.scrollHeight >= windowHeight)) {
                    return;
                }
                if (position === "absolute" &&
                    (widthPercent < 90 || heightPercent < 90 || $el.parentElement?.tagName !== "BODY")) {
                    return;
                }
                if ((widthPercent < 70 || heightPercent < 70) && !middleBlocker)
                    return;
                if (childrenCount < 5 &&
                    $el.querySelectorAll("iframe").length < 1 &&
                    $el.tagName !== "IFRAME")
                    return;
                const $focused = helper.elements.getFocused();
                const $bottomElement = $focused ? null : document.elementFromPoint(offsets.left, offsets.top);
                if (!$bottomElement ||
                    !$focused ||
                    $focused.tagName === "BODY" ||
                    $el.contains($focused) ||
                    $el.contains($bottomElement)) {
                    overlayType = "popup";
                }
            })();
            (() => {
                if (overlayType ||
                    childrenCount >= 5 ||
                    widthPercent < 70 ||
                    heightPercent < 70 ||
                    !(["DIV"].includes($el.tagName) || $el.matches("[data-aflw-role=complementary]"))) {
                    return;
                }
                if (position === "absolute" &&
                    (widthPercent < 90 || heightPercent < 90 || $el.parentElement?.tagName !== "BODY")) {
                    return;
                }
                let isOnTop = $topElement === $el;
                if (!isOnTop) {
                    const windowPoints = [
                        { x: 30, y: 30 },
                        { x: 30, y: window.innerHeight - 30 },
                        { x: 30, y: window.innerHeight / 2 },
                        { x: window.innerWidth - 30, y: 30 },
                        { x: window.innerWidth / 2, y: 30 },
                        { x: window.innerWidth - 30, y: window.innerHeight / 2 },
                        { x: window.innerWidth - 30, y: window.innerHeight - 30 },
                        { x: window.innerWidth / 2, y: window.innerHeight / 2 },
                        { x: window.innerWidth / 2, y: window.innerHeight - 30 },
                    ];
                    for (const point of windowPoints) {
                        if (document.elementFromPoint(point.x, point.y) === $el) {
                            isOnTop = true;
                            break;
                        }
                    }
                }
                if (isOnTop)
                    overlayType = "blocker";
            })();
            (() => {
                if (overlayType ||
                    !this.clickProcess ||
                    widthPercent < 70 ||
                    $el.offsetHeight < 150 ||
                    childrenCount < 10 ||
                    !$el.getAttribute("data-aflw-hidden")) {
                    return;
                }
                if ($el !== $topElement && !$el.contains($topElement))
                    return;
                let inFixed = false;
                let inAbsolute = false;
                if (position !== "fixed" && position !== "absolute") {
                    for (const $parent of helper.elements.getParents($el)) {
                        const parentPosition = helper.elements.getStyle($parent, "position");
                        if (parentPosition === "fixed") {
                            inFixed = true;
                            break;
                        }
                        if (parentPosition === "isInAbsolute") {
                            inAbsolute = true;
                            break;
                        }
                    }
                }
                if (position === "fixed" || position === "absolute" || inFixed || inAbsolute)
                    overlayType = "popbar";
            })();
            (() => {
                if (overlayType ||
                    position !== "fixed" ||
                    !this.clickProcess ||
                    heightPercent < 70 ||
                    widthPercent > 50 ||
                    $el.offsetWidth < 150 ||
                    childrenCount < 10) {
                    return;
                }
                const top = parseInt(helper.elements.getStyle($el, "top"));
                const right = parseInt(helper.elements.getStyle($el, "right"));
                const left = parseInt(helper.elements.getStyle($el, "left"));
                if (top === 0 &&
                    (right === 0 || left === 0) &&
                    ($el === $topElement || $el.contains($topElement))) {
                    overlayType = "sidebar";
                }
            })();
            (() => {
                if (helper.dynamic ||
                    this.clickProcess ||
                    position !== "fixed" ||
                    overlayType !== "popup" ||
                    childrenCount > 10 ||
                    heightPercent < 100 ||
                    widthPercent < 100 ||
                    this.timepass > 300 ||
                    $el.tagName === "IFRAME") {
                    return;
                }
                if (helper.elements.getText($el, "any").length > 30 ||
                    $el.querySelector('[data-aflw-role=list], [data-aflw-role=form], [data-aflw-group-input], [data-aflw-role=button], [data-aflw-role=link], iframe, [data-aflw-role=heading], [data-aflw-nav], [data-aflw-textual-context="close"]')) {
                    return;
                }
                overlayType = "loader";
            })();
            if (!helper.dynamic &&
                position === "fixed" &&
                ["visible", "auto"].includes(helper.elements.getStyle(document.body, "overflow-y"))) {
                for (const $el of document.querySelectorAll("div, [data-aflw-group-section]")) {
                    if ($el.contains($el) ||
                        $el.closest("[data-acsb]") ||
                        helper.elements.getStyle($el, "position") !== "relative" ||
                        !helper.elements.isVisible($el)) {
                        continue;
                    }
                    const elZindex = helper.elements.getStyle($el, "z-index");
                    if (elZindex === "auto" || +zIndex >= parseInt(elZindex))
                        continue;
                    fixedParallax = true;
                    break;
                }
            }
            return !fixedParallax && overlayType && helper.elements.isOverlaying($el);
        },
        textualType: {
            getType($field) {
                const $label = helper.elements.getFieldLabel($field);
                const type = $field.getAttribute("type");
                if ($field.tagName !== "SELECT") {
                    if (this._isEmail($field, $label))
                        return "email";
                    if (type === "search" || this._textsMatched($field, $label, ["search"]))
                        return "search";
                    if (type === "password" || this._textsMatched($field, $label, ["password"]))
                        return "password";
                    if (this._textsMatched($field, $label, ["phone", "mobile", "tele"]))
                        return "phone";
                    if (this._textsMatched($field, $label, ["message", "comment", "msg", "note"]))
                        return "message";
                    if (this._textsMatched($field, $label, ["captcha"]))
                        return "captcha";
                    if (this._textsMatched($field, $label, ["subject", "topic"]))
                        return "subject";
                    if (this._textsMatched($field, $label, ["company"]))
                        return "company";
                    if (this._textsMatched($field, $label, ["zip", "postal"]))
                        return "zip";
                    if (this._textsMatched($field, $label, ["website", "link"]))
                        return "link";
                    if (this._textsMatched($field, $label, ["address", "addr", "street"]))
                        return "address";
                    if (this._textsMatched($field, $label, ["promo", "coupon", "voucher"]))
                        return "coupon";
                    if (this._textsMatched($field, $label, ["fullname", "full_name", "full-name"]))
                        return "fullname";
                    if (this._textsMatched($field, $label, ["lname", "last_name", "lastname", "last-name"]))
                        return "lastname";
                    if (this._textsMatched($field, $label, ["name", "first_name", "firstname", "first-name"]))
                        return "firstname";
                }
                if (this._textsMatched($field, $label, ["city"]))
                    return "city";
                if (this._textsMatched($field, $label, ["country"]))
                    return "country";
                if (this._textsMatched($field, $label, ["slide", "range"]))
                    return "range";
                if (this._textsMatched($field, $label, ["state", "province"]))
                    return "state";
                if (this._textsMatched($field, $label, ["quantity", "qty", "quantities", "update"]))
                    return "quantity";
                if ($field.tagName !== "SELECT")
                    if (this._isName($field, $label))
                        return "name";
                return null;
            },
            _textsMatched($field, $label, texts) {
                let matched = false;
                let fieldHTML = $field.tagName === "SELECT" ? helper.elements.getHTML($field) : $field.outerHTML;
                let labelHTML = $label ? $label.outerHTML : "";
                fieldHTML = fieldHTML.replace(/name="/gi, "");
                labelHTML = labelHTML.replace(/name="/gi, "");
                fieldHTML = fieldHTML.replace(/opacity/gi, "");
                labelHTML = labelHTML.replace(/opacity/gi, "");
                fieldHTML = fieldHTML.toLowerCase();
                labelHTML = labelHTML.toLowerCase();
                for (const text of texts) {
                    if (fieldHTML.includes(text)) {
                        matched = true;
                        break;
                    }
                    if (labelHTML.includes(text)) {
                        matched = true;
                        break;
                    }
                    for (const $parent of helper.elements.getParents($field, "[data-aflw-role=form]", true)) {
                        const $parentFields = $parent.querySelectorAll("[data-aflw-group-input]");
                        if ($parentFields.length === 1 &&
                            $parentFields[0] === $field &&
                            helper.elements
                                .getHTML($parent)
                                .toLowerCase()
                                .replace(/opacity/gi, "")
                                .includes(text)) {
                            matched = true;
                            break;
                        }
                    }
                    if (matched &&
                        text === "address" &&
                        (fieldHTML.includes("mail address") || labelHTML.includes("mail address"))) {
                        matched = false;
                    }
                    if (matched)
                        break;
                }
                return matched;
            },
            _isEmail($field, $label) {
                if (!$field.matches("[data-aflw-group-input]"))
                    return false;
                return $field.type === "email" || this._textsMatched($field, $label, ["mail"]);
            },
            _isName($field, $label) {
                let fieldHTML;
                if ($field.tagName === "SELECT") {
                    fieldHTML = helper.elements
                        .getHTML($field)
                        .toLowerCase()
                        .replace(/name="/gi, "");
                }
                else {
                    fieldHTML = $field.outerHTML.toLowerCase().replace(/name="/, "");
                }
                if (fieldHTML.includes("name") || $label?.outerHTML.toLowerCase().includes("name"))
                    return true;
                let matched = false;
                for (const $parent of helper.elements.getParents($field, "form", true)) {
                    const html = helper.elements
                        .getHTML($parent)
                        .toLowerCase()
                        .replace(/name="/gi, "");
                    if (!html.includes("name"))
                        continue;
                    matched = true;
                    break;
                }
                return matched;
            },
        },
    };

    const FEATURE_FLAG_PREFIX = "aflwEngine";
    window.accessFlow = {
        getExcludedRules() {
            excludedRuleNames.length = 0;
            const flags = window.accessFlowData?.flags || {};
            Object.entries(flags).forEach(([key, value]) => {
                if (key.startsWith(FEATURE_FLAG_PREFIX) && value === false) {
                    const keyWithoutPrefix = key.replace(FEATURE_FLAG_PREFIX, "");
                    const keyWithLowerCaseFirstChar = keyWithoutPrefix.charAt(0).toLowerCase() + keyWithoutPrefix.slice(1);
                    excludedRuleNames.push(keyWithLowerCaseFirstChar);
                }
            });
        },
        async getLoadAudits() {
            this.getExcludedRules();
            const unifiedEngineAudit = await runAudit(document.body);
            const legacyAudit = await auditor.loadAudit();
            return mergeNewReportIntoOldReport(unifiedEngineAudit, legacyAudit);
        },
        /* istanbul ignore next */
        async getDynamicAudits() {
            return await auditor.dynamicAudit();
        },
        async startFunnelAudits() {
            return await auditor.startFunnelAudit();
        },
        async getFunnelAudits() {
            return await auditor.funnelAudit();
        },
        async getWebpaths() {
            return new Promise((resolve) => {
                const webpaths = [];
                try {
                    for (const $link of document.querySelectorAll("a[href]:not([download])")) {
                        const href = helper.uris.getDomainWebpath($link.href);
                        if (href &&
                            !webpaths.includes(href) &&
                            !href.includes("/logout") &&
                            !href.includes("/log-out")) {
                            webpaths.push(href);
                        }
                    }
                }
                catch (err) { }
                return resolve(webpaths);
            });
        },
        async getAssets() {
            const assets = [];
            const cache = {};
            const checkExtension = /\.(pdf|docx?|pptx?|xlsx?|mp3|wav|wma|mov|wmv|m4v|webm|avi|mp4)$/i;
            try {
                for (const $link of document.querySelectorAll("a[href], source, video, audio")) {
                    const src = helper.uris.format($link.href || $link.src);
                    if (cache[src])
                        continue;
                    if (!checkExtension.test($link.download || src) &&
                        !($link.textContent?.trim().toLocaleLowerCase() === "download" &&
                            $link.target === "_blank" &&
                            $link.href.includes("pdf")))
                        continue;
                    cache[src] = true;
                    assets.push(src);
                }
                for (const $iframe of document.querySelectorAll("iframe[src]")) {
                    const src = helper.uris.format($iframe.src);
                    if (cache[src])
                        continue;
                    for (const type of ["youtube.com/embed/", "player.vimeo.com/video/"]) {
                        if (!src.includes(type))
                            continue;
                        cache[src] = true;
                        assets.push(src);
                    }
                }
            }
            catch (err) { }
            return assets;
        },
        addStylesheet(css) {
            const sheet = new CSSStyleSheet();
            sheet.replaceSync(css);
            document.adoptedStyleSheets.push(sheet);
        },
    };

})();
//# sourceMappingURL=auditor.js.map
